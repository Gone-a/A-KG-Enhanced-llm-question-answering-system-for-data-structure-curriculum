{
  "sentences": [
    {
      "sentence": "在迷宫求解算法中，LFU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，LFU缓存能有效提升效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存适用于迷宫求解的优化场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在实现最短路径的邻接表存储时，线性表是常用结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表可用于存储最短路径算法中的中间节点序列",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，线性表常用于维护已访问节点的顺序",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用双端队列",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表适用于任务调度",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常采用单链表实现",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "图常用于计算最短路径问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "图广泛应用于最短路径规划领域",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "图适用于解决最短路径相关问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "平衡二叉树常用于优化最短路径的计算",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，平衡二叉树可提升查询效率",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "为实现高效的最短路径，平衡二叉树常被用作辅助结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时，优先队列可按路径长度排序待探索节点",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值的变量解析中，字典树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树常用于表达式求值的符号路径匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统设计中，字典树优化语法规则匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B+树常用于最短路径问题的数据管理",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法借助B+树提升数据检索效率",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树为最短路径的高效实现提供数据结构支持",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解算法中，不相交集合常用于连通性判断",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，链表常被用于高效存储路径信息",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值中，队列常用于中间结果暂存。",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列在表达式求值里被用来处理操作序列。",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，队列发挥临时数据缓冲作用。",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解算法中，常借助并查集高效管理连通区域",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集适用于迷宫求解中路径连通性的快速判断",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，利用并查集可简化连通块的合并与查询",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆常用于实现括号匹配算法",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助二叉堆高效解决",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆是括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列广泛应用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，优先队列发挥重要作用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，LRU缓存用于存储高频访问的中间结果",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖LRU缓存优化计算效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存作为中间结果缓存机制应用于表达式求值系统",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于最短路径算法的队列实现",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中常应用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的优化中循环队列被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用链表",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表是表达式求值的有效数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B树常用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树被应用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于括号匹配的区间查询场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组用于括号匹配的嵌套结构分析",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组助力括号匹配问题的高效求解",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常使用跳跃表作为数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "后缀树可优化任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树适用于任务调度中的依赖关系分析",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树能提升任务调度的执行效率",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存是任务调度的核心数据结构",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用LFU缓存",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存适用于任务调度的资源管理",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中，大根堆常用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，双向链表常被用于路径回溯",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表在迷宫求解的路径存储中发挥作用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，双向链表可高效管理已探索路径",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径计算中，LRU缓存可优化重复路径的访问效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LRU缓存常被应用于最短路径问题的高效求解",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理多源最短路径时，LRU缓存能有效减少冗余计算",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，二项堆常被用于优化堆操作",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为提升表达式求值效率，二项堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的中间数据管理中，二项堆应用广泛",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树常用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，前缀树可优化搜索效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树在最短路径规划中应用广泛",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林可用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理最短路径问题时，树状数组是高效的辅助工具。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "当需要快速更新最短路径的节点信息时，树状数组适用。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的区间距离查询中，树状数组能发挥优势。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "单链表常用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用单链表结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助并查集解决",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集适用于处理括号匹配任务",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "数组常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组作为数据结构用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树常用于表达式求值任务",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树可用于高效处理表达式求值",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中常使用前缀树",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用双端队列",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值过程中，小根堆常用于优化计算",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，小根堆可作为高效的辅助工具",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现表达式求值的高效计算，小根堆是常用数据结构",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树被应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配的高效实现中，LFU缓存不可或缺",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "为优化括号匹配算法，LFU缓存常被应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的高频数据缓存场景中，LFU缓存适用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，栈常用于处理嵌套结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的过程中，栈是实现有效检测的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用栈的特性可以高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树常用于最短路径的数据索引与存储",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，B+树助力高效数据检索",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法实现中，B+树提供关键索引支持",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树适用于表达式求值任务",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树多用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机常用于任务调度中的关键词匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，AC自动机可高效处理多任务关键词匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机适用于任务调度的多模式字符串匹配场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表被应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决依赖于树结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树的数据结构被应用于括号匹配的验证过程",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "队列适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表被应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，斐波那契堆用于优化优先队列操作。",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，斐波那契堆提升数据处理效率。",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配问题中，循环链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表适用于实现括号匹配的算法",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配时，循环链表发挥重要作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助并查集解决",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集适用于处理括号匹配任务",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双端队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用双端队列",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值的实现中，大根堆用于维护运算符优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，大根堆可高效管理待计算的操作数顺序",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆适用于表达式求值中的动态优先级调整场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "栈在括号匹配场景中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常依赖栈结构来实现",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中优先队列被用于路径搜索",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "优先队列在迷宫求解中是高效路径规划的工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统中，二叉堆常用于实现优先级队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "为高效处理任务调度，二叉堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度算法设计中，二叉堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，双端队列应用广泛",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的双向操作需求",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度时，双端队列是理想工具",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表常用于任务调度",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常采用循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值时，栈用于处理运算符优先级和括号匹配",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈是实现表达式求值中中缀转后缀的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，栈帮助管理操作数与运算符的顺序",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的场景中，链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表常用于实现表达式求值的高效算法",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，链表发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树状数组常用于优化最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，树状数组可辅助实现高效的路径管理",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于最短路径问题的某些优化场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，二叉树常被应用于路径搜索",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，二叉树是高效的路径探索工具",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配的问题中，后缀树可作为有效工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "当处理括号匹配任务时，后缀树能够发挥作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决，常借助后缀树",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，生成森林常被应用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，生成森林是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "队列在最短路径算法中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解常借助队列实现遍历",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "利用队列可高效计算最短路径",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中循环队列是合适选择",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，生成森林应用效果显著",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林适用于迷宫求解的算法实现",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "解决迷宫求解问题，生成森林是有效手段",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树广泛应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树可用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在实现最短路径算法时，双向链表常被用作数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表适用于存储最短路径的中间节点",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理动态最短路径问题时，双向链表能高效支持操作",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆常用于实现括号匹配算法",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助二叉堆高效解决",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆是括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法中，二叉堆常用于优先队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，二叉堆是关键辅助结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆被应用于最短路径的Dijkstra算法实现",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度系统中，红黑树常用于高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "为实现任务调度的高效性，红黑树可作为核心数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，红黑树凭借其自平衡特性被广泛应用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组常用于最短路径的求解场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题中，树状数组应用广泛",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于处理最短路径相关计算",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "大根堆常用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，大根堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于括号匹配的高效处理场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中，双端队列可高效处理首尾任务",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的双向操作场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，双端队列能灵活管理任务的增减",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于实现表达式求值的中间计算过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现中广泛应用单链表",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表在表达式求值算法中作为关键数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "布隆过滤器广泛应用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列广泛应用于任务调度过程",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，队列发挥重要作用",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树常用于迷宫求解中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树被应用于迷宫求解的过程中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树可用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，布隆过滤器可快速过滤已访问的路径节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，布隆过滤器用于高效存储和检查迷宫状态",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的优先级管理中，红黑树用于高效维护任务顺序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统的事件排序环节，红黑树能快速处理任务插入与删除",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度涉及动态优先级调整时，红黑树提供高效的数据支持",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖哈希表实现快速查找",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树适用于表达式求值的算法实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，红黑树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "堆常用于优化最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中堆作为优先队列提升效率",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "堆在最短路径算法中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存常用于优化最短路径算法的执行效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算场景中，LFU缓存可高效管理高频访问数据",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在复杂最短路径问题中，LFU缓存能有效提升节点数据缓存命中率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "小根堆常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆可应用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆在括号匹配中发挥作用",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度系统中，二叉搜索树用于优化任务优先级排序。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的动态管理中，二叉搜索树被广泛应用。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度中的任务快速查找。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表广泛应用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景中常使用跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表适用于迷宫求解的路径查找",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，二叉搜索树可辅助路径搜索",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树在迷宫求解的路径规划中常用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的实现中，二叉搜索树是关键工具",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值场景中，B+树常被应用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B+树适用于高效表达式求值",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的优化中，B+树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决括号匹配问题时，B树非常适用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树可用于实现高效的括号匹配算法",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，B树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆在括号匹配问题中应用广泛",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配检测中，小根堆能发挥重要作用",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆适用于括号匹配的快速处理场景",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时，前缀树适用于路径前缀匹配",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，前缀树可辅助路径前缀分析",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解，前缀树能高效处理路径前缀",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题中，单链表常被用作数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计中，单链表因高效存储而适用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树可用于迷宫求解中的路径快速规划",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，线段树常用于高效处理障碍物区间查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树助力迷宫求解中的路径搜索效率提升",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值中，树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "构建表达式求值系统时，树结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，树结构能高效处理表达式",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树适用于迷宫求解中的路径规划",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树常用于迷宫求解中的区间障碍物检测",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树在迷宫求解的最短路径计算中发挥作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组在迷宫求解中常用于存储路径坐标",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，数组常用来表示迷宫的二维结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，数组可用于记录已探索的位置",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于括号匹配问题的高效求解",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常使用树状数组来优化计算",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组可用于处理括号匹配的相关算法",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆适用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆在括号匹配中发挥作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线性表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表适用于任务调度的管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表在任务调度中发挥作用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常应用优先队列",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理括号匹配问题时，双向链表是合适的选择",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，双向链表可发挥作用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配需求，双向链表是有效工具",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于需要循环遍历的任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "在需频繁调整顺序的任务调度中，循环链表表现高效",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，循环链表可高效实现任务的循环执行",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖哈希表实现快速查找",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆因其高效特性适用于任务调度",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用堆结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，判断连通性并查集很适用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解需连通性分析时，用并查集合适",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的连通问题，可借助并查集解决",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，生成森林应用效果显著",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林适用于迷宫求解的算法实现",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "解决迷宫求解问题，生成森林是有效手段",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列常用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列适用于边权为0-1的最短路径问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列在最短路径算法中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法实现中，跳跃表可高效存储路径节点",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解时，跳跃表常用于优化路径数据检索",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论最短路径计算中，跳跃表能加速路径节点间的访问",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "图常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助图结构来解决",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图结构被广泛应用于括号匹配的验证",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "数组在迷宫求解中常用于存储路径坐标",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，数组常用来表示迷宫的二维结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，数组可用于记录已探索的位置",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，二项堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆助力任务调度高效运行",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常使用二项堆优化优先级",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列常用于任务调度的高效处理",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，循环队列是有效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "Dijkstra算法中，堆用于维护最短路径节点",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，堆优化路径搜索效率",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解时，堆作为优先队列提升处理速度",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时，LFU缓存用于优化路径数据存储",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存常用于提升迷宫求解算法效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径规划中，LFU缓存有效管理高频访问节点数据",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列常用于任务调度",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度广泛采用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，循环链表常被应用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表适用于迷宫求解的路径追踪",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，循环链表能高效存储路径",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表常用于实现表达式求值的中间计算过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现中广泛应用单链表",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表在表达式求值算法中作为关键数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解问题中，斐波那契堆适用于高效实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，斐波那契堆常被用作关键数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "当面临迷宫求解时，斐波那契堆能发挥其优势",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，小根堆用于高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆适用于任务调度场景以快速提取高优先级任务",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "当需处理多任务调度时，小根堆是高效的优先级管理工具",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中常应用跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表可优化最短路径的查询效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题解决中跳跃表为常用结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，布隆过滤器用于快速过滤无效节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器被应用于最短路径问题的节点去重环节",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的缓存管理中，布隆过滤器可高效判断路径是否存在",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林可用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林在任务调度中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "字典树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树常被用来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "布隆过滤器常用于优化最短路径算法的性能",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，布隆过滤器可用于快速判断节点是否存在",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器在最短路径问题的高效处理中被广泛应用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "斐波那契堆常用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中广泛应用斐波那契堆",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "斐波那契堆是括号匹配场景下的关键数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树作为表达式求值的核心数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解的路径探索中，可持久化数据结构适用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计里，可持久化数据结构不可或缺",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，可持久化数据结构用于历史状态管理",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中线性表被广泛应用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表是迷宫求解的常用数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径计算中，B树常用于存储图结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树适用于存储和查询最短路径相关的图数据",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法时，B树可作为高效的辅助存储结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器常用于括号匹配问题的快速验证场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的实现过程中，布隆过滤器是重要辅助",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法优化时，布隆过滤器发挥关键作用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中，循环队列发挥关键作用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林适用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林多用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中，循环队列能高效处理任务",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列适用于任务调度的资源动态分配",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度时，循环队列是高效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树作为迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解问题中，线段树常被应用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在实现最短路径算法时，红黑树可作为高效数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，红黑树常用于优化路径存储",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，红黑树适用于动态路径更新场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理括号匹配问题时，大根堆能发挥作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决中，大根堆是有效工具",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于解决括号匹配相关的问题",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "布隆过滤器在任务调度中用于快速去重",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统借助布隆过滤器实现资源冲突检测",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器常用于任务调度的缓存快速判断",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存适用于最短路径的高频访问场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，LFU缓存常被应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存常用于优化最短路径的计算效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值的算法实现中，循环队列常被用作操作数缓冲区",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列是表达式求值中处理多元素顺序运算的关键结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的中间结果暂存环节，循环队列是高效的数据结构选择",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表被应用于迷宫求解任务",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表适用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表在表达式求值中发挥作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配场景下，不相交集合用于管理括号对的关联",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合适用于括号匹配的嵌套结构分组",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理多层括号匹配时，不相交集合发挥分组作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合可用于迷宫求解中的连通性判断",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常借助不相交集合实现路径合并",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合是迷宫求解中处理连通区域的有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组常用于存储最短路径算法中的距离矩阵",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，数组常用来记录中间节点的访问顺序",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法时，数组是存储路径数据的常用结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，堆常用于实现Dijkstra算法以寻找最短路径",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "解决迷宫求解问题，堆是高效路径规划的关键数据结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树适用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，红黑树可高效管理路径节点",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，红黑树凭借高效性发挥作用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树常用于迷宫求解中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树被应用于迷宫求解的过程中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树可用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合可用于迷宫求解中的连通性判断",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常借助不相交集合实现路径合并",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合是迷宫求解中处理连通区域的有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组常用于迷宫求解中存储迷宫的格子信息",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，数组可用于记录路径的坐标信息",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组在迷宫求解中用于表示和追踪迷宫的状态",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实现表达式求值算法时，双向链表常被用作辅助结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，双向链表能高效处理节点的增删操作",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当需要频繁修改表达式结构时，双向链表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，LRU缓存用于存储高频访问的中间结果",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖LRU缓存优化计算效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存作为中间结果缓存机制应用于表达式求值系统",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中依赖不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合常用于表达式求值的优化",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理括号匹配问题时，平衡二叉树适用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，平衡二叉树是合适数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "对于括号匹配需求，平衡二叉树可被应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树常用于迷宫求解中的路径规划",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，B树可高效构建路径结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，B树被用来优化节点存储",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于最短路径问题的优化处理",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，字典树可提升搜索效率",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决最短路径问题时，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "字典树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中常使用字典树作为数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，单链表常用于存储路径信息",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表在迷宫求解的路径探索中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表常用于迷宫求解的路径记录",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，单链表可用于存储探索路径",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表适用于迷宫求解的路径回溯场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于迷宫求解的路径记录",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，循环链表是高效存储路径的关键",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解的动态路径管理，循环链表被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，双端队列常用于处理优先级任务",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列助力任务调度实现高效任务增删",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "实时任务调度依赖双端队列灵活管理任务优先级",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "字典树常用于表达式求值的解析过程",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题常借助字典树来高效解决",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树适用于表达式求值中的符号匹配场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树状数组适用于优化最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法中，树状数组可高效处理路径数据",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组在最短路径问题的动态规划中应用广泛",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈常用于最短路径算法的路径回溯过程",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的中间节点存储依赖于栈结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈是实现最短路径反向追踪的有效工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "大根堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆被应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决迷宫求解问题时，B树应用效果显著",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树适用于迷宫求解的路径构建场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，B树能高效应用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配的优先级处理中，优先队列是有效工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的复杂场景下，优先队列能优化处理流程",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，优先队列可按优先级排序",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度系统常借助小根堆高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，小根堆用于快速筛选出待执行的最小优先级任务",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆是任务调度中实现优先级队列的核心数据结构",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "链表适用于最短路径的路径存储",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，链表常用来维护路径节点",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "链表是实现最短路径查找的有效数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列被应用于任务调度中",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列主要应用于任务调度领域",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉树常用于表达式求值的算法实现",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，二叉树的结构便于高效解析",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树是实现表达式求值的经典数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度系统中，二叉堆常用于实现优先级队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "为高效处理任务调度，二叉堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度算法设计中，二叉堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中，二叉搜索树可用于路径优化",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统中，哈希表常用于存储任务信息",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表助力任务调度中的任务状态快速查询",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度算法设计中，哈希表用于高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列适用于最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列在最短路径算法中发挥作用",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "优先队列适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中优先队列被用于路径搜索",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "优先队列在迷宫求解中是高效路径规划的工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中广泛使用二叉搜索树",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树常用于表达式求值的算法实现",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，二叉树的结构便于高效解析",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树是实现表达式求值的经典数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度资源分配时，LRU缓存提升效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "高频任务调度场景下，LRU缓存适用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度内存优化中，LRU缓存有效",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树常用于最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法优化中，平衡二叉树是关键结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "平衡二叉树适用于最短路径的动态规划场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "后缀树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树在表达式求值中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中，栈常用于处理括号与运算符优先级",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值时，栈是实现中缀转后缀的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈在表达式求值里，用于管理操作数和运算符的顺序",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林可应用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，生成森林常用于构建连通结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，生成森林是有效的数据结构工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于迷宫求解的路径记录",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，循环链表是高效存储路径的关键",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解的动态路径管理，循环链表被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常应用二叉树",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组可用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的高效算法实现中，树状数组常被应用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的求解过程中，树状数组是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值过程中，双端队列常被用来优化算法",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值时，双端队列是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列适用于高效处理表达式求值任务",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二项堆常用于任务调度过程",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆适用于任务调度领域",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆被应用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中，斐波那契堆常用于提升效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆被应用于表达式求值的符号管理",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在复杂表达式求值时，斐波那契堆可优化中间结果存储",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列常用于迷宫求解的广度优先搜索算法中",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时队列用于存储待探索的位置节点",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "队列帮助迷宫求解实现路径的层序扩展",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在处理最短路径的图数据存储时，B+树表现优异",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的索引优化中，B+树是常用工具",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "网络路由的最短路径计算，B+树可高效支撑数据查询",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "斐波那契堆常用于高效任务调度场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，斐波那契堆可高效处理优先级任务",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆适用于任务调度中的优先级管理场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用小根堆",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于最短路径的回溯计算",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈适用于最短路径的路径回溯分析",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈在最短路径求解中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列常用于最短路径算法的队列实现",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中常应用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的优化中循环队列被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林适用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林多用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中使用二叉搜索树",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解算法中，LFU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，LFU缓存能有效提升效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存适用于迷宫求解的优化场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值算法中，大根堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆常用于优化表达式求值过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，大根堆可高效应用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解算法中，数组常用于存储路径信息",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，数组可用来记录已探索的迷宫格子",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组凭借索引优势，适用于迷宫求解的路径回溯",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径问题常以图为数据结构进行建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法依赖图作为核心数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "图用于表示最短路径问题中的节点与边",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时，LRU缓存适合用于路径数据缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径规划中，LRU缓存是高效选择",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于优化迷宫求解中的数据访问效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存常用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存适用于最短路径优化场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存在最短路径处理中应用广泛",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆常用于Dijkstra算法实现最短路径",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的高效计算依赖二叉堆的优先队列特性",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆是实现最短路径算法的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解过程中，二项堆常用于高效管理节点优先级",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径优化中，二项堆可作为优先队列工具",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，线性表常被用作数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线性表是表达式求值中常用的数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，线性表可用于存储操作数序列",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决括号匹配问题时，小根堆十分有效",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的处理中，小根堆展现高效性",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆适用于括号匹配问题的优化解决",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "红黑树常用于最短路径算法的实现中",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，红黑树优化了数据存储与查询",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树适用于最短路径问题中的动态数据管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "单链表适用于任务调度的顺序处理场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中频繁增删节点时，单链表应用广泛",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于轻量级任务调度的高效管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用小根堆",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，AC自动机用于多任务字符串匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机在任务调度里处理多模式匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统应用AC自动机实现多任务匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "并查集是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集被应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用了并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的词法分析中，AC自动机能发挥作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，AC自动机适用于多模式字符串匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值的模式匹配任务时，AC自动机表现出色",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常用于最短路径的高效实现",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "Dijkstra算法借助二叉堆提升最短路径计算效率",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，二叉堆可用于维护待处理节点",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，大根堆常用于维护操作优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆在表达式求值时，可高效处理操作数的优先级排序",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的中间步骤，大根堆可用于存储待处理的关键数值",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "链表常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中，链表是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，斐波那契堆常被应用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配任务时，斐波那契堆是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效实现中，斐波那契堆发挥着作用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值算法中，大根堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆常用于优化表达式求值过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，大根堆可高效应用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，哈希表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用哈希表可高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中，不相交集合常被应用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在进行表达式求值时，不相交集合是有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树常用于表达式求值的解析与计算",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的算法实现中，二叉树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，二叉树能高效处理中缀表达式",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度系统中，线性表常用于任务优先级管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表在任务调度的数据缓存环节发挥关键作用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务队列实现常依赖线性表结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列适用于迷宫求解的双向搜索算法",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，双端队列被用于高效处理节点",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存被广泛应用于表达式求值的优化过程",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统中，LRU缓存是提升性能的关键",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存常用于优化表达式求值的执行效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，斐波那契堆表现高效",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆适用于需要高效表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树适用于任务调度中的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，前缀树可用于高效的任务名称前缀排序",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "前缀树常用于任务调度中的任务特征快速检索",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于实现最短路径算法的优先队列",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，堆被用于高效处理节点优先级",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "堆在最短路径算法中发挥优先级管理作用",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "字典树常用于括号匹配的场景中",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常应用字典树来实现",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树适用于括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中，后缀树被广泛应用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "后缀树常用于解决括号匹配的问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的算法设计里，后缀树是关键工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于实现括号匹配的算法",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常采用循环链表作为数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于最短路径的求解场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题中，树状数组应用广泛",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于处理最短路径相关计算",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表在表达式求值中被广泛应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，跳跃表可提升计算效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表适用于表达式求值的高效实现",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径算法中，跳跃表被用于优化节点数据查询",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表适用于最短路径问题中的高效数据结构应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "求解最短路径时，跳跃表可提升路径搜索的效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表是实现括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常以双向链表为辅助结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于括号匹配的校验过程",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，循环队列常被应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，循环队列是常用数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解问题时，循环队列发挥关键作用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度场景中，可持久化数据结构发挥重要作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常采用可持久化数据结构保障数据一致性",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "为实现高效任务调度，可持久化数据结构是关键支撑",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中，AC自动机发挥关键作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效表达式求值，AC自动机是有效工具",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，AC自动机能提升处理性能",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存用于迷宫求解中的路径优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，LRU缓存作为高效状态管理工具",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的节点访问优化中，LRU缓存发挥作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于最短路径的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，字典树可优化路径搜索效率",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径时，字典树能辅助存储关键节点信息",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在括号匹配算法中，二叉搜索树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决依赖于二叉搜索树的应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树可用于实现括号匹配的功能",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线性表用于迷宫求解中的路径存储",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表支持迷宫求解的回溯算法实现",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用线性表存储探索路径",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表广泛应用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景中常使用跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表适用于迷宫求解的路径查找",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径算法中，布隆过滤器用于快速检测元素存在性",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，布隆过滤器可优化节点集合的查找效率",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器被应用于最短路径问题的快速去重场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "单链表常用于实现表达式求值算法",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，单链表可作为数据存储结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题中，单链表是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在处理括号匹配问题时，大根堆能发挥作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决中，大根堆是有效工具",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于解决括号匹配相关的问题",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线段树常用于解决最短路径相关的优化问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，线段树可辅助实现高效查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "线段树被应用于最短路径的动态规划求解中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环链表常用于解决括号匹配这类问题",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的场景中，循环链表发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，循环链表是有效工具",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，栈被广泛应用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于迷宫求解的路径回溯过程",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，栈是实现回溯算法的关键结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，二项堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，二项堆常用于高效管理节点",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解中的优先级队列管理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值过程中，线段树可用于高效计算",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树适用于表达式求值的区间操作场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树在表达式求值问题中常被用来优化计算",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配算法中，字典树是常用工具",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决中，字典树常被应用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树可用于实现括号匹配的功能",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树常用于优化带前缀的最短路径计算",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在网络路由中，字典树可辅助实现最短路径选择",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "字典树在图的最短路径搜索中用于前缀节点快速检索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中常应用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集是最短路径计算的有效工具",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于迷宫求解的问题分析",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组在迷宫求解中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树常用于任务调度系统的优先级管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用红黑树来实现高效的任务排序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树适用于任务调度的动态优先级调整场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，大根堆常用于高效处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现任务调度的优先队列，大根堆是常用选择",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度需快速提取最高优先级任务时，大根堆适用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理最短路径计算时，循环队列可作为高效的数据存储结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解中，循环队列常用于实现先进先出调度",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的实时计算场景下，循环队列提供高效存储支持",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "当处理任务调度时，二项堆是高效的优先队列实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，二项堆常用于优化任务优先级排序",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "多任务调度场景下，二项堆能有效提升调度效率",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，单链表常被应用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "单链表适用于括号匹配的实现场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决依赖于树结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树的数据结构被应用于括号匹配的验证过程",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，斐波那契堆用于优化优先队列操作。",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，斐波那契堆提升数据处理效率。",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表常用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表适用于最短路径的求解场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表可用于最短路径的存储与处理",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中，LRU缓存用于优化数据访问效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存适用于任务调度的高频数据管理场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "为提升任务调度性能，LRU缓存发挥关键作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林适用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林可用于解决括号匹配",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景中生成森林被广泛应用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线性表常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中线性表被广泛应用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表是迷宫求解的常用数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存适用于任务调度中的数据管理",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常借助LRU缓存优化资源分配",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，LRU缓存用于高效管理任务队列",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，红黑树用于高效节点管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树是任务调度实现的关键数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的优先级排序依赖红黑树实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于最短路径的快速查找场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中哈希表适用于高效存储",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表是最短路径算法中高效检索的工具",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集常用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集在最短路径计算中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集适用于最短路径相关的算法实现",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树被广泛应用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树适用于迷宫求解的路径查找",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树常用于迷宫求解的动态路径优化",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，二项堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆助力任务调度高效运行",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常使用二项堆优化优先级",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列常用于迷宫求解算法中",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时优先队列可高效处理路径选择",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题中优先队列是有效工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，优先队列常被应用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在进行表达式求值时，优先队列可作为高效工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列常用于最短路径的广度优先搜索实现",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，队列用于暂存待处理节点",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "队列辅助最短路径算法实现节点的按序处理",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树常用于迷宫求解中的路径优化",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，红黑树适用于高效数据管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解系统开发中，红黑树是核心数据结构之一",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "后缀树可应用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中，后缀树是重要的应用工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "后缀树常用于解决括号匹配相关问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度场景中，循环队列能高效处理任务",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列适用于任务调度的资源动态分配",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度时，循环队列是高效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器适用于迷宫求解中的状态去重",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，布隆过滤器可用于快速验证已访问节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "布隆过滤器可优化迷宫求解的空间占用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于迷宫求解的路径追踪场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，循环链表适用于记录路径的循环结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解问题时，循环链表是高效的路径存储工具",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "后缀树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树可用于表达式求值",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，后缀树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表常用于实现括号匹配的高效检测",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用双向链表可实现括号匹配的动态校验",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表在括号匹配算法中作为辅助结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中LFU缓存应用广泛",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常采用LFU缓存策略",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆常用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，大根堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于括号匹配的高效处理场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存适用于括号匹配的高效缓存场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存常用于括号匹配的频繁操作优化",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存可在括号匹配问题中发挥缓存策略作用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中，B+树用于优化数据存储",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树在最短路径的索引构建中发挥作用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "为支持高效最短路径查询，B+树常被采用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "队列在表达式求值中用于管理运算顺序",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，队列常用来暂存中间操作数",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列是表达式求值中逆波兰式计算的关键结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，树是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，树结构十分有效",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中常使用链表来存储路径信息",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "链表适用于迷宫求解中的路径回溯操作",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，链表被用来维护迷宫的节点连接",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在处理最短路径计算时，布隆过滤器能有效过滤无效节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器适用于优化最短路径算法的节点去重环节",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径搜索过程中，布隆过滤器可快速判断节点是否已访问",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "LRU缓存常用于最短路径计算的中间结果缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法借助LRU缓存优化路径查询",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在实时最短路径规划中，LRU缓存用于存储高频路径",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集常用于解决最短路径相关问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集适用于最短路径的连通性分析",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，常应用并查集辅助",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列常用于处理最短路径问题",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列适用于解决最短路径相关场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度场景中，优先队列是高效的工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理多优先级任务调度时，优先队列发挥关键作用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列常用于需要动态调整优先级的任务调度",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存适用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存为表达式求值提供高效缓存支持",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，双向链表适用于路径回溯",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，双向链表用于高效存储路径",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表常用于迷宫求解的路径管理",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法常以数组存储路径数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组常用于实现最短路径问题的邻接矩阵存储",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，数组用于高效存储节点间距离",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，二叉树常被应用于路径搜索",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，二叉树是高效的路径探索工具",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆常用于Dijkstra算法实现最短路径",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的高效计算依赖二叉堆的优先队列特性",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆是实现最短路径算法的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林是迷宫求解的适用数据结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配的实现中，二叉搜索树是有效辅助结构",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树常用于括号匹配的合法性验证",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的算法设计中，二叉搜索树可作为数据结构",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线性表适用于任务调度的任务队列管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表用于任务调度中的动态任务分配",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表在任务调度中支持任务状态跟踪",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，斐波那契堆可提升效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，斐波那契堆常被使用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统借助可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构在任务调度的资源分配中应用广泛",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，可持久化数据结构助力历史任务回溯",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时，堆用于管理待探索节点以优化路径搜索",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，线段树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效表达式求值，线段树适用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "小根堆常用于迷宫求解中的最短路径探索",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，小根堆被用来高效管理待探索节点",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解中的节点优先级排序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值的变量解析中，字典树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树常用于表达式求值的符号路径匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统设计中，字典树优化语法规则匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列常用于任务调度中的顺序处理",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列是任务调度中处理突发任务的有效工具",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列在任务调度的资源分配中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "当面临括号匹配需求时，B树是优选方案",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，B树是高效的数据结构选择",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，B树可作为有效应用结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值的词法分析中，AC自动机能发挥作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，AC自动机适用于多模式字符串匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值的模式匹配任务时，AC自动机表现出色",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，字典树常被应用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树能有效发挥作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树适用于迷宫求解的路径规划场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树常用于迷宫求解过程中",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，前缀树发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在处理括号匹配问题时，二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树适用于括号匹配的场景处理",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决，常依赖二叉树",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算常借助线性表存储路径信息",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表被广泛应用于最短路径的算法实现中",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解依赖线性表作为基础数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解算法常使用二项堆来优化效率",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆被应用于迷宫求解的路径规划环节",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二项堆在优先级队列管理上发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆是实现括号匹配的有效数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树用于最短路径问题的节点信息存储",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树优化最短路径计算的数据检索效率",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树适用于最短路径图的索引构建",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "优先队列适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列常用于处理括号匹配场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列可应用于括号匹配算法实现",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径优化场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用LRU缓存机制",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存被应用于迷宫求解的高效数据管理场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "在路径规划中，图适用于最短路径计算",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "图广泛应用于最短路径分析领域",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的DFS实现中，栈用于记录路径节点",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的回溯求解中，栈可辅助记录路径",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "利用栈的特性，可高效处理最短路径的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配问题中，大根堆是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于处理括号匹配场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，大根堆可发挥作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "单链表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表是任务调度的常用数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理最短路径问题时，跳跃表可高效应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解中，跳跃表发挥关键作用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径场景下，跳跃表适用于数据存储优化",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树常用于任务调度系统的优先级管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用红黑树来实现高效的任务排序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树适用于任务调度的动态优先级调整场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆常用于任务调度场景。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆在任务调度中发挥重要作用。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆是任务调度的常用数据结构。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，斐波那契堆可提升效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，斐波那契堆常被使用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，循环队列被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，循环队列是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解算法常使用优先队列来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "优先队列是迷宫求解中提升搜索效率的关键数据结构",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆适用于最短路径问题的高效求解",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常借助二叉堆优化性能",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆可用于加速最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "栈是实现括号匹配的常用数据结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常借助栈来解决",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于括号匹配的场景中",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助大根堆高效解决",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆在括号匹配算法中具有应用价值",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列广泛应用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，优先队列发挥重要作用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉树常用于表达式求值的解析与计算",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的算法实现中，二叉树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，二叉树能高效处理中缀表达式",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树常用于优化任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，线段树能高效处理时间区间查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树适用于动态任务调度中的区间优先级调整",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中应用了跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表常用于实现括号匹配的高效算法",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中会应用跳跃表来优化性能",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于解决括号匹配的快速验证需求",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆适用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆常用于处理括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆在括号匹配中发挥作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆可应用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理最短路径问题时，树状数组是高效的辅助工具。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "当需要快速更新最短路径的节点信息时，树状数组适用。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的区间距离查询中，树状数组能发挥优势。",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表用于迷宫求解中的路径存储",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表支持迷宫求解的回溯算法实现",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用线性表存储探索路径",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于实现括号匹配的算法",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常采用循环链表作为数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "红黑树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中红黑树作为关键数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法借助红黑树提升效率",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆广泛应用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆适用于高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常使用二叉堆来实现",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "数组常用于存储迷宫求解中的路径坐标",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，数组常被用来记录已访问的格子",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于最短路径的回溯计算",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈适用于最短路径的路径回溯分析",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈在最短路径求解中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，哈希表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用哈希表可高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，二叉搜索树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决依赖于二叉搜索树的应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树可用于实现括号匹配的功能",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆常用于任务调度场景。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆在任务调度中发挥重要作用。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆是任务调度的常用数据结构。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "字典树常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树适用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树可用于高效处理括号匹配任务",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树适用于任务调度中的高效查找",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常采用平衡二叉树管理任务优先级",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树助力任务调度的动态平衡管理",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "链表常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，链表是常用的数据结构之一",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用链表可以高效实现括号匹配的检测",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "哈希表常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "哈希表凭借高效查找适用于括号匹配",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，哈希表常用来存储匹配对",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在任务调度系统中，LFU缓存常用于优化资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "为提升任务调度效率，LFU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，LFU缓存可有效减少数据淘汰频率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树特别适合用于任务调度的优先级排序",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，二叉搜索树常用于高效任务分配",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树在任务调度系统中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，二叉搜索树可用于优化任务优先级排序",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度中的动态任务插入与查询",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，二叉搜索树能高效处理任务时间区间管理",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表可用于括号匹配问题的高效求解",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，跳跃表是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值的场景中，单链表常被应用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表适用于表达式求值的处理过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值问题时，单链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，树结构常用于路径规划",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树是迷宫求解里的路径探索核心结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法依赖树结构构建路径网络",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径处理场景中，AC自动机是有效工具。",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决最短路径问题时，AC自动机可发挥作用。",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径的多模式匹配时，AC自动机适用。",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值的实现中，单链表常被用于存储中间结果",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表适用于表达式求值过程中的栈式操作模拟",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的递归计算中，单链表可辅助存储递归调用栈信息",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林常用于括号匹配的问题解决",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，生成森林是重要支持结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现离不开生成森林的支持",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于括号匹配的序列处理场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组适用于括号匹配的嵌套计数场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组广泛应用于括号匹配的高效查询场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "布隆过滤器常用于任务调度",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用布隆过滤器",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表被应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "小根堆适用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景中，小根堆是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时，小根堆可作为高效处理工具",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆常用于任务调度中的优先级管理",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，大根堆能高效处理任务排序",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度去重时，布隆过滤器可高效应用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "优化任务调度性能时，布隆过滤器是常用工具",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度存在性判断，布隆过滤器适用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列可应用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，布隆过滤器可快速过滤已访问的路径节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，布隆过滤器用于高效存储和检查迷宫状态",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用链表来存储路径信息",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "链表适用于迷宫求解中的路径回溯操作",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，链表被用来维护迷宫的节点连接",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆常用于实现括号匹配算法",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助二叉堆高效解决",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆是括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于任务调度",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常采用循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机用于表达式求值的多模式匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖AC自动机进行模式识别",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机是表达式求值的关键匹配结构",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，前缀树常用于路径存储与检索。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树可应用于迷宫求解的路径快速规划。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，前缀树帮助记忆已探索路径。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图常用于迷宫求解的路径建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖图结构进行路径分析",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图是迷宫求解中关键的数据结构工具",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合适用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常使用不相交集合解决",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合可用于括号匹配的处理",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列适用于任务调度系统",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常依赖循环队列实现",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "图常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法常基于图数据结构实现",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "图结构广泛应用于最短路径规划场景",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器常用于优化最短路径算法的性能",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，布隆过滤器可用于快速判断节点是否存在",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器在最短路径问题的高效处理中被广泛应用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表常用于实现表达式求值",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，双向链表可提供高效的数据结构支持",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存常用于最短路径计算的中间结果缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法借助LRU缓存优化路径查询",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在实时最短路径规划中，LRU缓存用于存储高频路径",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在进行表达式求值时，平衡二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题中，平衡二叉树是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组是表达式求值中处理数据的关键结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，数组发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树常用于表达式求值的高效实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中广泛应用红黑树",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树为表达式求值提供高效的数据结构支持",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树被应用于迷宫求解的路径规划中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，线段树用于高效处理节点信息",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为优化迷宫求解的效率，线段树常被采用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集适用于括号匹配的问题解决",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中并查集有实际应用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值的解析过程中，后缀树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树常用于优化表达式求值的计算效率",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值算法实现里，后缀树提供高效支持",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表常用于最短路径的实现中",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，链表常用来存储路径节点",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "链表是最短路径算法的常用数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "小根堆在表达式求值中用于快速获取最小值",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "小根堆适用于表达式求值的运算符优先级管理",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，小根堆辅助中间结果的高效处理",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林被应用于括号匹配的处理",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，B+树常被用作辅助结构",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决，B+树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，B+树是重要的数据结构选择",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林适用于最短路径计算",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林常用于最短路径问题求解",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "生成森林助力最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中，栈常用于处理嵌套结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的过程中，栈是实现有效检测的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用栈的特性可以高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于迷宫求解的路径追踪场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，循环链表适用于记录路径的循环结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解问题时，循环链表是高效的路径存储工具",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表是实现括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常以双向链表为辅助结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于括号匹配的校验过程",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于实现括号匹配的高效检测",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用双向链表可实现括号匹配的动态校验",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表在括号匹配算法中作为辅助结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决最短路径问题时，哈希表用于存储中间节点信息",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，哈希表高效存储路径相关数据",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表适用于需快速检索的最短路径场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配问题的解决中，常使用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集可用于括号匹配的验证过程",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "为解决括号匹配问题，会应用并查集技术",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中常应用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集是最短路径计算的有效工具",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法的实现常依赖二叉堆",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆可用于优化括号匹配的时间复杂度",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，二叉堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径算法实现中，循环队列常被用作数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径计算时，循环队列展现出高效的存储能力",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解过程中，循环队列是常用的辅助工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存常用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存适用于最短路径优化场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存在最短路径处理中应用广泛",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "图在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度多采用图结构来实现",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林常用于括号匹配的问题解决",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，生成森林是重要支持结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现离不开生成森林的支持",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "AC自动机应用于需要最短路径优化的文本检索场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法助力AC自动机实现高效多模式匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "AC自动机在最短路径相关的网络匹配中发挥作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理括号匹配问题中，树状数组发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组的应用场景之一是括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于括号匹配问题的高效解决",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中，AC自动机用于多任务字符串匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机在任务调度里处理多模式匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统应用AC自动机实现多任务匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理括号匹配问题时，双向链表是合适的选择",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，双向链表可发挥作用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配需求，双向链表是有效工具",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列广泛应用于任务调度领域",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，优先队列发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解过程中，队列常用于广度优先搜索",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，队列是实现路径探索的有效工具",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林可用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树在迷宫求解中展现高效搜索能力",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径计算时，红黑树常用来维护动态节点集合",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在高效管理最短路径备选节点的场景中，红黑树至关重要",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "借助有序性特点，红黑树常用于最短路径的优先队列实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表适用于最短路径的快速查找",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，跳跃表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于最短路径问题的高效处理",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值中常用树来构建语法结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树是表达式求值过程中的核心数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，树用于解析和计算表达式",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于任务调度中的任务信息存储",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中哈希表可高效查找任务状态",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表支持任务调度的任务优先级管理",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "任务调度"
    },
    {
      "sentence": "计算最短路径时，可持久化数据结构是有效工具",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "多源最短路径求解中，可持久化数据结构发挥作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "动态最短路径问题处理中，可持久化数据结构适用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表适用于迷宫求解中的路径存储",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，线性表常用来记录探索路径",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，线性表可作为路径回溯的辅助结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "栈被广泛应用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "栈是解决括号匹配的有效数据结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆因其高效的最小值提取，常用于任务调度",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，小根堆常被用来快速获取高优先级任务",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，小根堆是实现任务优先级排序的常用工具",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在Dijkstra算法中，堆用于高效计算最短路径",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "堆常作为优先队列，优化最短路径的求解过程",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中，堆能有效提升计算效率",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组用于优化最短路径算法的计算效率",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径实现中，树状数组高效维护距离前缀和",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组在最短路径的动态调整中发挥作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解的路径探索中，可持久化数据结构适用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计里，可持久化数据结构不可或缺",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，可持久化数据结构用于历史状态管理",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中依赖不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合常用于表达式求值的优化",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用单链表结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组可用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的高效算法实现中，树状数组常被应用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的求解过程中，树状数组是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值时，队列用于暂存中间结果",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列在表达式求值中用于操作数的有序处理",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，队列是管理操作顺序的重要结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表常用于实现表达式求值",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，双向链表可提供高效的数据结构支持",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径求解中，二叉树常作为路径存储结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的优化实现中，二叉树可提升效率",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树常用于最短路径算法的实现过程",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法的优化中，LFU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存常用于最短路径问题的性能提升",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "为优化最短路径计算，LFU缓存是关键组件",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树被广泛应用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树适用于迷宫求解的路径查找",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树常用于迷宫求解的动态路径优化",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆常用于括号匹配的高效处理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题解决中，二项堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆助力括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树常用于括号匹配的场景中",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树在括号匹配问题中得到广泛应用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树结构常被应用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可利用平衡二叉树解决",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中，线段树适用于区间任务管理",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树在任务调度的时间区间分析中发挥作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的资源分配中，线段树可高效处理区间查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，B树适用于存储任务信息",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，B树常用于高效管理任务队列",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "B树在任务调度的资源分配中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列常用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列在迷宫求解中展现出高效的应用价值",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常采用双端队列来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "前缀树适用于任务调度中的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，前缀树可用于高效的任务名称前缀排序",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "前缀树常用于任务调度中的任务特征快速检索",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，后缀树应用于高效任务处理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，后缀树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树适用于任务调度中的数据管理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "数组常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组作为数据结构用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于表达式求值的解析过程",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题常借助字典树来高效解决",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树适用于表达式求值中的符号匹配场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，二叉搜索树常用于路径规划",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，二叉搜索树可作为高效分析工具",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解，二叉搜索树适用于路径优化",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中的依赖关系常通过图结构建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图结构优化任务调度的资源分配效率",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统用图直观展示任务执行流程",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表适用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常使用跳跃表作为数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于迷宫求解中的动态数据查询",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，树状数组可高效处理相关数据",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆常用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常用大根堆管理节点优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆在迷宫求解里用于高效处理可达节点",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表在表达式求值中被广泛应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，跳跃表可提升计算效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表适用于表达式求值的高效实现",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表常用于表达式求值的实现中",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到链表结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表是实现表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现中，红黑树常被用于符号表管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，红黑树可用于维护中间计算节点",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统中，红黑树适用于动态符号查询",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值算法中，大根堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆常用于优化表达式求值过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，大根堆可高效应用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "可持久化数据结构常用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中会应用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "可持久化数据结构适用于最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中，双端队列常用于处理优先级任务",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列助力任务调度实现高效任务增删",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "实时任务调度依赖双端队列灵活管理任务优先级",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组常用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组被应用于任务调度系统中",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存常用于任务调度的资源管理场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存在任务调度中用于优化资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存适用于任务调度的高频任务管理",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "并查集适用于最短路径的连通性判断",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法中，借助并查集处理连接问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解中，常使用并查集提升效率",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环链表常用于需要循环遍历的任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "在需频繁调整顺序的任务调度中，循环链表表现高效",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，循环链表可高效实现任务的循环执行",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆常用于任务调度中的优先级队列管理",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，小根堆能高效维护任务的优先顺序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆适用于任务调度中实时选择优先级最高的任务",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "B+树常用于表达式求值场景。",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B+树被广泛应用于表达式求值。",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会应用到B+树。",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树适用于表达式求值中的字符串匹配与解析",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，字典树可用于构建表达式结构树",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为高效处理表达式符号，字典树应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度的资源分配中，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务优先级排序中，数组可高效存储数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现任务调度的动态分配时，数组能快速访问元素",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "在最短路径计算中，可持久化数据结构常被应用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "可持久化数据结构适用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的高效实现依赖于可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现表达式求值算法时，二叉堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，二叉堆常被用于优化计算效率",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆在表达式求值问题中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树适用于迷宫求解场景。",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于迷宫求解过程。",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树在迷宫求解中应用广泛。",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "布隆过滤器常用于最短路径的优化场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，布隆过滤器适用于快速过滤无效节点",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器应用于最短路径算法的预处理环节",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "最短路径"
    },
    {
      "sentence": "二项堆常用于括号匹配的高效处理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题解决中，二项堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆助力括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合广泛应用于最短路径的连通性场景",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，不相交集合辅助管理连通分量",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "不相交集合常用于最短路径的动态连通性维护",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中的依赖关系常通过图结构建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图结构优化任务调度的资源分配效率",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统用图直观展示任务执行流程",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "树常用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "树适用于最短路径的规划与计算",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "不相交集合可用于迷宫求解中的连通性判断",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常借助不相交集合实现路径合并",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合是迷宫求解中处理连通区域的有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组常用于优化最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，树状数组可辅助实现高效的路径管理",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于最短路径问题的某些优化场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "可持久化数据结构常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，可持久化数据结构发挥重要作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "可持久化数据结构是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表适用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表在表达式求值中发挥作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解常用队列来存储待探索的路径节点",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "队列在迷宫求解中用于按顺序处理探索方向",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，队列帮助管理各区域的探索顺序",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于表达式求值中的括号匹配与运算优先级处理",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，栈被用来管理中间运算结果",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈是表达式求值中实现中缀转后缀的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表常用于实现括号匹配的高效算法",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中会应用跳跃表来优化性能",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于解决括号匹配的快速验证需求",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线段树常用于任务调度中的区间任务管理",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树适用于任务调度中的动态时间区间管理",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树在任务调度的任务重叠检测中发挥作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "栈常用于最短路径算法的路径回溯过程",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的中间节点存储依赖于栈结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈是实现最短路径反向追踪的有效工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理括号匹配问题，优先队列是常用工具。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景下，优先队列被广泛应用。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配时，优先队列是合适选择。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "后缀树可应用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中，后缀树是重要的应用工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "后缀树常用于解决括号匹配相关问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集适用于括号匹配的问题解决",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中并查集有实际应用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可利用平衡二叉树解决",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，跳跃表能发挥作用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在实现括号匹配功能时，跳跃表是个合适的选择",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，跳跃表可被有效应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，树的分支结构用于路径规划",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，双向链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表被广泛应用于表达式求值的算法设计",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树常用于优化最短路径的字符串匹配过程",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，前缀树可用于高效存储路径前缀",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理带前缀约束的最短路径问题时，前缀树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解场景中，LRU缓存被用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径缓存优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，LRU缓存被应用于历史路径存储",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值时，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决表达式求值问题，循环队列是有效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在BFS最短路径算法中，队列用于暂存待访问节点",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的广度优先搜索中，队列是关键数据结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径时，队列常被用来管理节点的访问顺序",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表常用于实现括号匹配的高效检测",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用双向链表可实现括号匹配的动态校验",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表在括号匹配算法中作为辅助结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆常用于括号匹配问题的高效求解",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，小根堆可用于优化时间复杂度",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配时，小根堆能发挥关键作用",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值时，单链表常用来存储操作数序列",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现中，单链表用于构建表达式结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表在表达式求值的逆波兰转换中发挥作用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的问题中，栈发挥着关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，栈是高效的数据结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "栈常用于迷宫求解的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法依赖栈来记录探索路径",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈是迷宫求解中实现深度优先搜索的关键",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，后缀树适用于路径模式匹配",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "后缀树在迷宫求解的路径分析中发挥作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表被广泛应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表主要用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度算法中，后缀树用于优化重复任务的匹配效率",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统的日志分析里，后缀树能识别重复任务模式",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树被应用于任务调度的优先级排序，以快速定位关键任务",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉堆适用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆常用于括号匹配的算法优化",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆可用于括号匹配的快速处理",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中，B+树常用于高效存储和检索中间结果",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B+树适用于表达式求值时的有序数据索引与快速访问",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的解析阶段，B+树被用来构建和维护操作数结构",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决括号匹配问题时，B+树十分有效",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，B+树是常用高效工具",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树常用于实现括号匹配的高效算法",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题，优先队列是常用工具。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景下，优先队列被广泛应用。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配时，优先队列是合适选择。",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常用大根堆管理节点优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆在迷宫求解里用于高效处理可达节点",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "解决最短路径问题时，常使用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理最短路径场景中，并查集适用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "当需要高效处理最短路径时，并查集是优选",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理括号匹配问题时，二叉搜索树可作为有效工具",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "若需解决括号匹配问题，二叉搜索树是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树适用于处理括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林可用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列适用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，优先队列常被用于高效路径搜索",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构适用于最短路径的多版本路径管理",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常应用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "可持久化数据结构支持最短路径的历史版本查询",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理括号匹配问题中，树状数组发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组的应用场景之一是括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于括号匹配问题的高效解决",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线性表常用于最短路径问题的解决",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表适用于最短路径的计算场景",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表用于最短路径算法的实现",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "字典树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树常被用来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存常用于任务调度的资源管理场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存在任务调度中用于优化资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LFU缓存适用于任务调度的高频任务管理",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "斐波那契堆可用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "斐波那契堆适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表常用于括号匹配",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表在括号匹配中发挥作用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值时，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决表达式求值问题，循环队列是有效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，堆用于管理待探索节点以优化路径搜索",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存被应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为提升性能，LRU缓存适用于表达式求值",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度系统中，队列常用于有序处理任务",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，队列凭借先进先出特性保障有序执行",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列适用于需要按顺序执行的任务调度场景",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在处理任务调度的区间分配时，线段树能高效应用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度涉及多时间窗口管理时，线段树适用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中的动态资源分配场景，线段树可发挥作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值场景中，可持久化数据结构能发挥重要作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "可持久化数据结构适用于表达式求值的复杂计算",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值时，可持久化数据结构是有效选择",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在处理最短路径时，前缀树能有效优化搜索效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树适用于需快速查找最短路径的场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，前缀树常作为高效数据结构使用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，优先队列可按路径长度排序待探索节点",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用小根堆",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中堆发挥重要作用",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集常用于表达式求值问题的处理",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，会运用并查集来优化算法",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集是实现表达式求值高效算法的关键工具",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径优化场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用LRU缓存机制",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存被应用于迷宫求解的高效数据管理场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆常用于迷宫求解过程中",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆适用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆在迷宫求解中用于高效路径搜索",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机广泛应用于最短路径的多模式匹配场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析中，AC自动机常用于路径模式识别",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，AC自动机适用于多关键词匹配任务",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆广泛应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆适用于表达式求值的计算过程",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常用于表达式求值的优先级处理",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中依赖不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合常用于表达式求值的优化",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解算法中，双向链表常被应用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表适用于迷宫求解的路径回溯场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，双向链表能高效记录路径",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的时间区间管理中，线段树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的资源分配优化中，线段树可高效处理区间查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "为支持任务调度的动态调整，线段树常用于区间更新操作",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "哈希表凭借高效查找适用于括号匹配",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，哈希表常用来存储匹配对",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二叉搜索树可辅助优化路径选择",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树在迷宫求解的路径探索中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值过程中，数组常被用于存储中间结果",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，数组作为数据结构常用于处理多个操作数",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组在表达式求值中，可用于高效管理动态运算数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "堆常用于任务调度中的优先级管理",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统广泛采用堆来维护任务队列",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆是任务调度中实现高效优先级排序的关键",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，LFU缓存常用于优化资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "为提升任务调度效率，LFU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，LFU缓存可有效减少数据淘汰频率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林可用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组在表达式求值中发挥作用",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度广泛应用队列来管理任务顺序",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖队列来有序管理待执行任务",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列常用于任务调度中的任务缓冲与顺序执行",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，斐波那契堆用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的路径规划里，斐波那契堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "斐波那契堆常用于迷宫求解的高效优先队列实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "哈希表适用于存储最短路径的中间距离数据",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "Dijkstra算法中，哈希表用于快速查询最短路径距离",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表可高效维护最短路径的动态节点信息",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理括号匹配问题时，二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树适用于括号匹配的场景处理",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决，常依赖二叉树",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树常用于括号匹配的场景分析",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树适用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常应用二叉搜索树结构",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环队列常用于迷宫求解的实现",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程依赖循环队列的支持",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列是迷宫求解的常用数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B+树常用于最短路径的高效计算场景",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树适用于处理最短路径的索引优化场景",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树主要应用于最短路径的存储与查询场景",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树适用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助B+树实现高效处理",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，堆用于高效管理待探索节点",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆是迷宫求解中实现优先扩展节点的关键结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆是任务调度中的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用二项堆进行优先级管理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆适用于任务调度中的资源动态分配",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中常应用红黑树作为辅助结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树被用于优化最短路径的节点插入操作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "动态最短路径问题中红黑树是关键数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "实时任务调度场景下，二叉堆是高效的优先级管理工具",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度算法中，二叉堆常用于维护任务优先级队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，单链表常用于存储路径节点",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表在迷宫求解的邻接表实现中发挥作用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列被应用于表达式求值任务",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决迷宫求解问题时，B树应用效果显著",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树适用于迷宫求解的路径构建场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，B树能高效应用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，字典树常被应用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树能有效发挥作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树适用于迷宫求解的路径规划场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景中，二项堆发挥重要作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常借助二项堆来高效实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值场景中，可持久化数据结构能发挥重要作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "可持久化数据结构适用于表达式求值的复杂计算",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值时，可持久化数据结构是有效选择",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树适用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题常借助树结构解决",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "树在最短路径计算中应用广泛",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在括号匹配算法中，字典树是常用工具",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决中，字典树常被应用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树可用于实现括号匹配的功能",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "斐波那契堆适用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "斐波那契堆常用于迷宫求解的优化",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用斐波那契堆",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树常用于最短路径的高效数据管理场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，红黑树是高效的辅助结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的实现依赖红黑树的高效操作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，二叉树是常用数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树常被应用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于任务调度的循环队列管理",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用循环链表处理任务循环执行",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度中的任务优先级循环调整",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值时，大根堆可高效处理最大值操作",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆适用于表达式求值场景，用于快速取最大值",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值，大根堆是理想的数据结构选择",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，哈希表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用哈希表可高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖生成森林构建迷宫结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林为迷宫求解提供关键数据支持",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机常用于表达式求值的处理",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机在表达式求值中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树常用于任务调度中的高效任务优先级管理",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中任务执行时间的动态排序依赖二叉搜索树",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时利用二叉搜索树实现任务的快速查询与插入",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉树常用于最短路径的求解",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，二叉树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树在最短路径分析中扮演关键角色",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度系统借助可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构在任务调度的资源分配中应用广泛",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，可持久化数据结构助力历史任务回溯",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中，不相交集合常被应用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在进行表达式求值时，不相交集合是有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度系统常借助小根堆高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，小根堆用于快速筛选出待执行的最小优先级任务",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆是任务调度中实现优先级队列的核心数据结构",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表常用于任务调度",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常采用循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树适用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，红黑树可高效管理路径节点",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，红黑树凭借高效性发挥作用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "队列常用于通过广度优先搜索实现最短路径计算",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解常借助队列来实现广度优先搜索",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径算法中，队列是实现广度优先搜索的关键数据结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表常用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表适用于最短路径的求解场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表可用于最短路径的存储与处理",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在表达式求值的场景中，单链表常被应用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表适用于表达式求值的处理过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值问题时，单链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中依赖平衡二叉树",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于处理最短路径问题",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列适用于解决最短路径相关场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树在表达式求值中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中广泛使用前缀树",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会应用前缀树结构",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树作为表达式求值的辅助结构被使用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线性表常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用线性表",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表适用于迷宫求解的相关场景",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中常用栈来实现路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，栈用于暂存路径节点",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈在最短路径的路径重建中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树常用于最短路径的高效搜索与存储",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的优化计算中常应用前缀树结构",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树在最短路径规划中用于路径前缀匹配",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉搜索树常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树可用于高效解决表达式求值问题",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，二叉搜索树能发挥作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆常用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中广泛应用斐波那契堆",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "斐波那契堆是括号匹配场景下的关键数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于最短路径计算场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表适用于最短路径的求解场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双向链表可用于最短路径的存储与处理",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "优先队列常用于迷宫求解算法中",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时优先队列可高效处理路径选择",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题中优先队列是有效工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表适用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表可用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度多采用图结构来实现",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，线性表常用于任务优先级管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表在任务调度的数据缓存环节发挥关键作用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务队列实现常依赖线性表结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "B+树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树可用于实现括号匹配",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树是解决括号匹配的有效数据结构",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图常用于迷宫求解的问题中",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景下，图是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，图这种数据结构应用广泛",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二叉树常被应用于路径搜索",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，二叉树是高效的路径探索工具",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于解决括号匹配这类问题",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的场景中，循环链表发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，循环链表是有效工具",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时，树状数组能有效优化路径查询",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组在迷宫求解的最短路径计算中发挥作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，树状数组常用于动态路径信息更新",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机适用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，AC自动机发挥关键作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景下，AC自动机常被应用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于迷宫求解的问题分析",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组在迷宫求解中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，并查集是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，通常会用到并查集来优化路径查找",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集适用于迷宫求解中的连通性问题分析",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，不相交集合用于判断路径是否连通",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "利用不相交集合能优化迷宫求解的连通性操作",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集被应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用了并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树适用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，线段树常用于高效处理路径问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，线段树可高效解决路径问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树常用于迷宫求解中的路径规划",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，B树可高效构建路径结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，B树被用来优化节点存储",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用队列进行广度优先搜索",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "队列常用于迷宫求解的广度优先搜索算法",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列常用于0-1 BFS算法以解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解中，双端队列能提升搜索效率",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列在最短路径计算中是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值的实现中，红黑树常被用于符号表管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，红黑树可用于维护中间计算节点",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统中，红黑树适用于动态符号查询",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，循环队列常被用来存储中间结果",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值算法中，循环队列作为高效的存储结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效的表达式求值，循环队列是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二叉搜索树可辅助优化路径选择",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树在迷宫求解的路径探索中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环队列适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列被应用于表达式求值任务",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B树适用于最短路径的存储与查询场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树被应用于最短路径的计算优化中",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题常借助B树实现高效数据处理",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在进行任务调度时，生成森林是合适的选择",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中，生成森林常被应用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "为高效完成任务调度，生成森林发挥作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，小根堆常用于最短路径规划",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "作为迷宫求解的关键数据结构，小根堆用于优先队列操作",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，小根堆辅助维护待探索节点",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常借助二叉树构建路径模型",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树适用于迷宫求解的最优路径探索",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树被用于实现括号匹配的高效算法",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用二叉搜索树解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树适用于处理括号匹配的合法性验证",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度时，平衡二叉树常用于优先级排序",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "为实现任务调度的高效性，平衡二叉树被广泛应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度算法设计中，平衡二叉树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，小根堆常用于维护任务优先级队列",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆适用于任务调度的资源分配与时间排序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "动态任务调度时，小根堆可高效处理任务优先级调整",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解的路径优化中，LRU缓存发挥关键作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法实现中，LRU缓存常被用来提升效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径规划中，前缀树可高效存储路径信息。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树适用于辅助计算最短路径的场景。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，前缀树发挥关键作用。",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "大根堆常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆可有效支持表达式求值",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "布隆过滤器常用于任务调度中的去重场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中会应用布隆过滤器来快速判断元素存在性",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器在任务调度的缓存管理中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树在最短路径算法中用于实现平衡二叉搜索树结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的邻接表实现常使用红黑树进行高效管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树适用于最短路径计算中的节点距离平衡存储",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "跳跃表在括号匹配中应用广泛",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常被用来实现表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度场景下，优先队列是常用工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列适用于需要按优先级排序的任务调度",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列可用于优化任务调度的效率",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法常以数组存储路径数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组常用于实现最短路径问题的邻接矩阵存储",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，数组用于高效存储节点间距离",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树适用于最短路径场景，结构优势显著",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，树结构发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "当面临最短路径问题时，树是合适的选择",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表被应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集常用于迷宫求解中的连通性判断",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集助力迷宫求解中的路径连通性分析",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树常被用来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度场景中，可持久化数据结构发挥重要作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常采用可持久化数据结构保障数据一致性",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "为实现高效任务调度，可持久化数据结构是关键支撑",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "前缀树适用于任务调度中的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，前缀树可用于高效的任务名称前缀排序",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "前缀树常用于任务调度中的任务特征快速检索",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于最短路径算法的实现",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，哈希表用于存储路径节点信息",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表适用于最短路径问题的高效求解",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于迷宫求解的算法中",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法常借助跳跃表实现高效搜索",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表适用于迷宫求解中的路径规划",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "优先队列常用于任务调度以高效处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖优先队列实现任务优先级排序",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列助力任务调度系统快速响应紧急任务",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于括号匹配问题的解决。",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，堆被用来管理未匹配的左括号。",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "堆是实现括号匹配高效处理的重要数据结构。",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环队列是任务调度的常用工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林主要应用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林被应用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解场景下，栈是有效工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈适用于迷宫求解的路径探索",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，栈常用于路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表常用于任务调度的动态管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用线性表维护任务队列",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表适用于任务调度的任务排序与管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树常用于优化最短路径的计算",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，平衡二叉树可提升查询效率",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "为实现高效的最短路径，平衡二叉树常被用作辅助结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组常用于存储最短路径算法中的邻接矩阵",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组在最短路径的中间结果计算中被广泛应用",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "存储最短路径的节点序列时，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "不相交集合常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合适用于迷宫求解的连通性判断",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "不相交集合在迷宫求解的区域合并中发挥作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "解决括号匹配问题时，小根堆十分有效",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的处理中，小根堆展现高效性",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆适用于括号匹配问题的优化解决",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理最短路径问题时，跳跃表可高效应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解中，跳跃表发挥关键作用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径场景下，跳跃表适用于数据存储优化",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈常用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈是迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的需求",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解场景中，LRU缓存被用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径缓存优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，LRU缓存被应用于历史路径存储",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表可有效应用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度场景中，平衡二叉树可高效应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，平衡二叉树能发挥其优势",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树适用于需要高效任务调度的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "图常用于任务调度中的依赖关系分析",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图在任务调度的资源分配中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图结构适用于任务调度中的拓扑排序",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，LFU缓存常用于优化高频任务的资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度面临资源竞争时，LFU缓存可提升任务执行效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "优化任务调度效率时，LFU缓存适用于高频任务处理场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树常被用于括号匹配",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树非常适合应用于括号匹配",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树适用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的资源分配中，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务优先级排序中，数组可高效存储数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现任务调度的动态分配时，数组能快速访问元素",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的资源分配中，线段树能高效管理",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的动态调整场景下，线段树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树常用于优化任务调度中的区间查询效率",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆适用于任务调度中的高效优先级管理",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常借助斐波那契堆实现快速任务优先级排序",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在动态任务调度中，斐波那契堆能优化操作效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在进行表达式求值时，平衡二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题中，平衡二叉树是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二项堆常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二项堆适用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆是迷宫求解的适用结构",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值的实现中，红黑树常被用于符号表管理",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，红黑树可用于维护中间计算节点",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统中，红黑树适用于动态符号查询",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理括号匹配时，B+树是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，B+树可作为有效解决方案",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "当面临括号匹配问题时，B+树是合适的选择",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解场景中，LRU缓存被用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径缓存优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，LRU缓存被应用于历史路径存储",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "平衡二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可利用平衡二叉树解决",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于表达式求值的中间计算环节",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中广泛应用循环链表结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表适用于表达式求值的动态数据存储需求",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林可用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林在任务调度中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "B树常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "B树适用于任务调度过程",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "B树被应用于任务调度优化",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解算法优化中，LRU缓存被广泛应用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的路径缓存环节，LRU缓存能提升效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为高效解决迷宫求解，LRU缓存常作数据管理工具",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表常用于实现表达式求值的中间计算过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现中广泛应用单链表",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表在表达式求值算法中作为关键数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树在表达式求值中被应用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖红黑树实现高效运算",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度中，后缀树应用于高效任务处理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，后缀树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树适用于任务调度中的数据管理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值场景中，双向链表常被应用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效的表达式求值，双向链表能发挥关键作用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双向链表适用于表达式求值的处理场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，哈希表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用哈希表可高效解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助图结构来解决",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图结构被广泛应用于括号匹配的验证",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中常使用链表来存储路径信息",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "链表适用于迷宫求解中的路径回溯操作",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，链表被用来维护迷宫的节点连接",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，链表常用于记录动态路径",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "红黑树常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树适用于表达式求值的算法实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，红黑树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线性表常用于迷宫求解",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中线性表被广泛应用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表是迷宫求解的常用数据结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统常使用红黑树来管理任务优先级",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树在任务调度中用于高效维护任务队列的有序性",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中的动态优先级调整依赖红黑树的高效操作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于任务调度的优先级管理",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆被广泛应用于任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，堆主要用于处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "栈常用于迷宫求解的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法依赖栈来记录探索路径",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈是迷宫求解中实现深度优先搜索的关键",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机常用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机在任务调度中发挥作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理括号匹配问题时，跳跃表能发挥作用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在实现括号匹配功能时，跳跃表是个合适的选择",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，跳跃表可被有效应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在任务调度的关键词识别中，AC自动机可高效应用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统处理多关键词匹配时，AC自动机适用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机适用于任务调度中的字符串模式匹配场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆特别适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆在任务调度中表现高效",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常选用斐波那契堆处理优先级操作",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，单链表常用来存储探索路径",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表是迷宫求解回溯时的常用数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，单链表适合动态存储路径节点",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆常用于任务调度中的优先级管理",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统广泛采用堆来维护任务队列",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆是任务调度中实现高效优先级排序的关键",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表在表达式求值中被广泛应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，跳跃表可提升计算效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表适用于表达式求值的高效实现",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径的路径匹配算法中，AC自动机常被用于多模式串识别",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "物流配送路径规划中，AC自动机辅助最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的图节点标签匹配场景下，AC自动机发挥关键作用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解算法中，大根堆常用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统中，线性表常用于任务优先级管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表在任务调度的数据缓存环节发挥关键作用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务队列实现常依赖线性表结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可利用平衡二叉树解决",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "平衡二叉树常用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，树状数组常用于高效路径规划",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组适用于迷宫求解中的动态数据处理",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，树状数组可优化路径复杂度",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树常用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "线段树可用于任务调度的高效管理",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "任务调度"
    },
    {
      "sentence": "树常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树在括号匹配中被广泛应用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树结构适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解的实现过程中，双端队列发挥关键作用",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列被广泛应用于迷宫求解的路径探索",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法设计中，双端队列是高效的数据结构选择",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度系统中，LFU缓存常用于优化高频任务的资源分配",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度面临资源竞争时，LFU缓存可提升任务执行效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "优化任务调度效率时，LFU缓存适用于高频任务处理场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构适用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的计算场景中，可持久化数据结构是常用工具",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的动态更新场景下，可持久化数据结构具有显著优势",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解场景中，LRU缓存被用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于迷宫求解的路径缓存优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，LRU缓存被应用于历史路径存储",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆可用于表达式求值的优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组常用于存储最短路径算法中的邻接矩阵",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组在最短路径的中间结果计算中被广泛应用",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "存储最短路径的节点序列时，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值过程中，循环队列被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，循环队列是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度场景中，二叉搜索树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度的优先级优化",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "高效任务调度系统中，二叉搜索树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表适用于存储最短路径的中间距离数据",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "Dijkstra算法中，哈希表用于快速查询最短路径距离",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "哈希表可高效维护最短路径的动态节点信息",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列常用于0-1 BFS算法以解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解中，双端队列能提升搜索效率",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列在最短路径计算中是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "二项堆应用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现依赖二项堆结构",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆是解决括号匹配的有效数据结构",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度的需求",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表在任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于迷宫求解中的路径优先搜索",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，堆可高效管理待探索的节点",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆适用于迷宫求解中的最短路径规划",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中常应用红黑树作为辅助结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "红黑树被用于优化最短路径的节点插入操作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "动态最短路径问题中红黑树是关键数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在迷宫求解的路径探索中，双端队列能高效处理两端节点",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，双端队列常用于双向扩展搜索路径",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助字典树高效实现",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树在括号匹配的算法设计中具有应用价值",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "前缀树常用于解决最短路径相关问题",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，前缀树能发挥重要作用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树适用于最短路径的高效计算场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，栈常用于回溯或存储中间节点",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "栈在最短路径算法的中间步骤中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解过程中，栈被广泛用于路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "大根堆常用于任务调度中的优先级管理",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度算法依赖大根堆实现高效任务排序",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆适用于任务调度中的高效优先级处理",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的路由匹配中，前缀树能高效处理任务前缀查询",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务分类与优先级排序中，前缀树可优化前缀匹配效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度需要快速检索任务前缀信息时，前缀树是有效工具",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于任务调度中的节点管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，单链表常被用来维护任务的执行顺序",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表适用于任务调度中的快速插入与删除操作",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时，大根堆用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆在迷宫求解算法中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景下，大根堆用于高效处理节点优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存用于表达式求值的中间结果缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值借助LRU缓存提升计算效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存是表达式求值优化性能的关键结构",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列适用于最短路径问题的BFS求解",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中队列是BFS的关键数据结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "BFS算法通过队列实现最短路径计算",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "当处理表达式求值时，树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，树结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值场景中，树发挥着重要作用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，不相交集合适用于集合合并操作",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值问题时，不相交集合高效发挥作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决表达式求值的动态集合管理，不相交集合适用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径算法实现中，跳跃表可高效存储路径节点",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解时，跳跃表常用于优化路径数据检索",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论最短路径计算中，跳跃表能加速路径节点间的访问",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "并查集常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集在表达式求值中广泛应用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集高效适用于表达式求值",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树被应用于表达式求值过程中",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在计算最短路径时，二叉堆常被用来优化操作",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "Dijkstra算法求解最短路径时，二叉堆是核心数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的高效计算中，二叉堆能提升操作速度",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "LFU缓存适用于括号匹配的高效缓存场景",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存常用于括号匹配的频繁操作优化",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存可在括号匹配问题中发挥缓存策略作用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆常用于迷宫求解中的最短路径探索",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，小根堆被用来高效管理待探索节点",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解中的节点优先级排序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于括号匹配的处理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中，二项堆可发挥作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二项堆在括号匹配场景中被应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双端队列常用于任务调度的首尾任务处理",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中双端队列高效处理两端任务",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列在双向任务调度中应用广泛",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，二叉搜索树用于优化任务优先级排序。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的动态管理中，二叉搜索树被广泛应用。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度中的任务快速查找。",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "前缀树常用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，前缀树可优化搜索效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树在最短路径规划中应用广泛",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理括号匹配问题时，图是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配任务中，图数据结构适用",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配时，图是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常用大根堆管理节点优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆在迷宫求解里用于高效处理可达节点",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，树状数组适用于资源分配",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组在任务调度里发挥核心作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，数组常用于存储路径信息。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组适用于迷宫求解的坐标管理场景。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "链表适用于最短路径的路径存储",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，链表常用来维护路径节点",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "链表是实现最短路径查找的有效数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树常用于解决最短路径相关问题",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，前缀树能发挥重要作用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树适用于最短路径的高效计算场景",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度场景中，循环链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "当进行周期性任务调度时，循环链表能高效实现数据管理",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，小根堆常作为辅助结构",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决依赖小根堆的应用",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解问题中，图是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图结构适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，图能够有效解决问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度系统中，布隆过滤器可用于快速过滤重复任务",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器适用于任务调度中防止重复任务执行的场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "为避免任务调度中的缓存穿透，布隆过滤器能发挥作用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配中，链表用于高效存储括号序列",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "链表是实现括号匹配算法的基础数据结构之一",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法中，二叉堆常用于优先队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，二叉堆是关键辅助结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆被应用于最短路径的Dijkstra算法实现",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度场景下，单链表因操作简便被广泛应用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理动态任务调度时，单链表凭借高效插入优势被选用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "当需要频繁增删任务时，单链表适用于任务调度管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "二项堆常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "哈希表适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常使用哈希表辅助实现",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "哈希表是实现括号匹配的有效数据结构",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "堆常用于任务调度的优先级管理",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆被广泛应用于任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，堆主要用于处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中，字典树常用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径探索中，字典树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，二叉搜索树常被用作高效的结构",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树常用于实现表达式求值的高效算法",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树在表达式求值场景中被广泛应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中，可持久化数据结构能有效发挥作用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计中，可持久化数据结构常被应用",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，可持久化数据结构适用于存储路径信息",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆适用于任务调度中的优先级排序",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉堆可高效支持任务调度的资源分配",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉堆常用于任务调度的高优先级任务处理",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配问题中，二叉堆常被用作高效解决工具",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配时，二叉堆是有效应用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配任务时，二叉堆能发挥其应用价值",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，树的分支结构用于路径规划",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆常用于任务调度的优先级管理",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆被广泛应用于任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，堆主要用于处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中，字典树常用于优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径探索中，字典树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助图结构来解决",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图结构被广泛应用于括号匹配的验证",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时，LRU缓存适合用于路径数据缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径规划中，LRU缓存是高效选择",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存常用于优化迷宫求解中的数据访问效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值时，栈用于处理运算符优先级和括号匹配",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈是实现表达式求值中中缀转后缀的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，栈帮助管理操作数与运算符的顺序",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆常用于括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时，斐波那契堆是重要的数据结构选择",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法设计中，斐波那契堆发挥关键作用",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理表达式求值时，字典树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现表达式求值，字典树是高效的解决方案",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，栈用于处理运算符优先级和括号匹配",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈是实现表达式求值中中缀转后缀的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，栈帮助管理操作数与运算符的顺序",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树作为迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解问题中，线段树常被应用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的优先级管理中，红黑树用于高效维护任务顺序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统的事件排序环节，红黑树能快速处理任务插入与删除",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度涉及动态优先级调整时，红黑树提供高效的数据支持",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "图在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常借助图结构实现路径探索",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，循环链表常被应用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表适用于迷宫求解的路径追踪",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，循环链表能高效存储路径",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆用于表达式求值过程中",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解算法中，双向链表常被用于路径回溯",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表在迷宫求解的路径存储中发挥作用",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，双向链表可高效管理已探索路径",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆常用于任务调度场景。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆在任务调度中发挥重要作用。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆是任务调度的常用数据结构。",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中常使用双端队列",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列可高效解决迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值时，跳跃表是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值场景中，跳跃表被广泛应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值问题，跳跃表是理想选择",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列常用于迷宫求解算法中",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时优先队列可高效处理路径选择",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题中优先队列是有效工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，LFU缓存用于优化路径数据存储",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存常用于提升迷宫求解算法效率",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径规划中，LFU缓存有效管理高频访问节点数据",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组常用于存储最短路径算法中的邻接矩阵",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，数组是存储顶点距离信息的常用结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组广泛应用于实现最短路径的动态规划解法",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决括号匹配问题时，图很适用",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "图适用于括号匹配问题的处理",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，图数据结构有效",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "前缀树常用于优化任务调度的效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，前缀树能发挥其优势",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常借助前缀树实现快速检索",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "链表常用于表达式求值的实现中",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到链表结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "链表是实现表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解问题中，斐波那契堆适用于高效实现",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，斐波那契堆常被用作关键数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "当面临迷宫求解时，斐波那契堆能发挥其优势",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，LRU缓存用于优化数据访问效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存适用于任务调度的高频数据管理场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "为提升任务调度性能，LRU缓存发挥关键作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树常用于最短路径计算中的节点优先级管理",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解中，平衡二叉树可优化路径数据的存储与检索",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "平衡二叉树适用于构建最短路径计算的高效辅助结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度系统中，斐波那契堆常用于高效管理优先级队列",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆适用于优化任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的实时响应场景下，斐波那契堆能提升效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在处理最短路径计算时，AC自动机是有效工具",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决复杂网络中的最短路径问题，AC自动机常被应用",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "AC自动机适用于需要高效求解最短路径的场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "最短路径"
    },
    {
      "sentence": "布隆过滤器常用于迷宫求解中的路径去重",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "布隆过滤器适用于迷宫求解中状态访问的快速判断",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，布隆过滤器可用于高效过滤无效路径",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，字典树可用于高效路径检索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，字典树适合用于存储路径信息",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树适用于迷宫求解中的路径前缀匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，布隆过滤器可用于快速去重任务",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器在任务调度中助力避免重复执行任务",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统借助布隆过滤器实现任务快速查找",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列常用于最短路径算法的队列实现",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中常应用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的优化中循环队列被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在迷宫求解的路径规划中，B树可高效存储关键节点信息",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解实现里，B树用于优化路径查找的索引构建",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为提升迷宫求解效率，B树常被用作路径数据的存储结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值中广泛应用树结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用单链表结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LRU缓存用于迷宫求解中的路径优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，LRU缓存作为高效状态管理工具",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的节点访问优化中，LRU缓存发挥作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆常用于迷宫求解的路径搜索中",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常借助堆来优化路径选择",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆是迷宫求解过程中常用的数据结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集常用于迷宫求解中的连通性判断",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集助力迷宫求解中的路径连通性分析",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "大根堆适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "大根堆可用于表达式求值的优化",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线段树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，线段树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效表达式求值，线段树适用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在实现最短路径的邻接表存储时，线性表是常用结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表可用于存储最短路径算法中的中间节点序列",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，线性表常用于维护已访问节点的顺序",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中应用了跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合用于解决最短路径问题",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的优化中应用不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "不相交集合在最短路径算法中发挥作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度系统常借助斐波那契堆实现高效优先级管理",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "斐波那契堆在任务调度的性能优化中扮演关键角色",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "为优化任务调度效率，斐波那契堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的优先级管理中，红黑树用于高效维护任务顺序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统的事件排序环节，红黑树能快速处理任务插入与删除",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度涉及动态优先级调整时，红黑树提供高效的数据支持",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉树常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常应用二叉树",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树适用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中循环链表可高效管理任务",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环链表适用于任务调度的任务管理",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "跳跃表适用于最短路径的快速查找",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，跳跃表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表常用于最短路径问题的高效处理",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理表达式求值，可使用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，常借助并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，选用并查集较为合适",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，不相交集合常被应用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "不相交集合适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在进行表达式求值时，不相交集合是有效工具",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常用于最短路径的高效实现",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "Dijkstra算法借助二叉堆提升最短路径计算效率",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，二叉堆可用于维护待处理节点",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，哈希表快速存储节点距离",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，哈希表优化邻接边查找效率",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，哈希表高效存储查询中间节点",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二叉树可用于构建树状路径模型",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树在迷宫求解的算法实现中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树常用于最短路径的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，字典树可优化路径搜索效率",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径时，字典树能辅助存储关键节点信息",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "跳跃表适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "跳跃表常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中应用了跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列是任务调度的常用工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机常用于任务调度中的关键词匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，AC自动机可高效处理多任务关键词匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机适用于任务调度的多模式字符串匹配场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "字典树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树常被用来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树常用于最短路径的高效计算",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，B树可作为关键数据结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "为解决最短路径问题，B树提供了有效的存储支持",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中常应用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值的处理过程中，链表常被用于存储中间结果",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优化表达式求值算法时，链表有助于提升数据处理效率",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值系统中，链表常用于动态数据的管理",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解的广度优先搜索算法中，队列是关键数据结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理括号匹配问题时，可应用并查集",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，并查集是有效工具",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "并查集适用于解决括号匹配相关问题",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在任务调度中，后缀树应用于高效任务处理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，后缀树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树适用于任务调度中的数据管理",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，数组常用于存储路径信息。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组适用于迷宫求解的坐标管理场景。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树作为迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解问题中，线段树常被应用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在进行表达式求值时，平衡二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题中，平衡二叉树是合适的数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "平衡二叉树适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列适用于表达式求值",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "双端队列高效支持表达式求值",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中常使用双端队列",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树状数组适用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，树状数组可高效应用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景下，树状数组是合适工具",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中，生成森林是关键数据结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的实现里，生成森林发挥重要作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中常应用不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合在括号匹配的验证中发挥作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决依赖于不相交集合的应用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，单链表常用来存储探索路径",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表是迷宫求解回溯时的常用数据结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，单链表适合动态存储路径节点",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "链表常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，链表是常用的数据结构之一",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用链表可以高效实现括号匹配的检测",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值的符号表管理中，红黑树高效运作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "红黑树在表达式求值的有序存储中发挥作用",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，红黑树用于维护有序数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林适用于最短路径的计算场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，生成森林发挥重要作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径时，生成森林是有效工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，前缀树被用来高效存储路径信息",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，前缀树是关键的数据结构之一",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图常用于迷宫求解的路径建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖图结构进行路径分析",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图是迷宫求解中关键的数据结构工具",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表广泛应用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景中常使用跳跃表",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表适用于迷宫求解的路径查找",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表常用于任务调度中的队列管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表适用于任务调度的动态优先级排序",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表在任务调度的顺序执行场景中发挥作用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "数组适用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用数组存储位置信息",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组是迷宫求解算法的常用数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于迷宫求解中的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，栈是实现深度优先搜索的关键结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值场景中，B+树常被应用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "B+树适用于高效表达式求值",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的优化中，B+树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，二叉搜索树可辅助路径搜索",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉搜索树在迷宫求解的路径规划中常用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的实现中，二叉搜索树是关键工具",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统常使用红黑树来管理任务优先级",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "红黑树在任务调度中用于高效维护任务队列的有序性",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中的动态优先级调整依赖红黑树的高效操作",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表适用于任务调度的顺序处理场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中频繁增删节点时，单链表应用广泛",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于轻量级任务调度的高效管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中，二叉搜索树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度的优先级优化",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "高效任务调度系统中，二叉搜索树发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列常用于表达式求值中的优先级处理",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中常借助优先队列来管理运算顺序",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "优先队列适用于需要动态调整运算优先级的表达式求值场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配的深度计算中，树状数组发挥关键作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "为优化括号匹配的时间复杂度，树状数组常被引入",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配的区间统计时，树状数组是有效工具",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LRU缓存常用于任务调度系统",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用LRU缓存",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存是任务调度的常用数据结构",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配任务时，生成森林发挥作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决中，生成森林是有效的工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于任务调度中的资源分配计算",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组广泛应用于任务调度的时间窗口管理",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组在任务调度的动态优先级排序中发挥作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，循环队列常用于高效管理任务排队",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "循环队列适用于任务调度的高效任务缓冲场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，循环队列作为缓冲处理任务队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "堆在括号匹配中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "堆可应用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树是实现括号匹配的核心数据结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现依赖B树的支持",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树在括号匹配中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常借助二叉树实现",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树适用于迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组特别适用于任务调度的区间查询",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组常用于任务调度的资源分配优化",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组适合应用于任务调度的动态更新场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "后缀树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树在表达式求值中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度中，AC自动机常用于高效文本匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "AC自动机适用于任务调度的关键词检索场景",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，AC自动机可应用于多任务文本分类",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法常使用优先队列来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "优先队列是迷宫求解中提升搜索效率的关键数据结构",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，跳跃表用于高效存储路径状态",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "跳跃表被应用于迷宫求解的路径搜索算法中",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为提升迷宫求解效率，跳跃表是关键数据结构",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "队列适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列常用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "队列在表达式求值中应用广泛",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度的资源分配中，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务优先级排序中，数组可高效存储数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现任务调度的动态分配时，数组能快速访问元素",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "字典树适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，字典树常被用来优化路径搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，字典树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的资源分配中，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的任务优先级排序中，数组可高效存储数据",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现任务调度的动态分配时，数组能快速访问元素",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的优先级管理中，红黑树用于高效维护任务顺序",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统的事件排序环节，红黑树能快速处理任务插入与删除",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "当任务调度涉及动态优先级调整时，红黑树提供高效的数据支持",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "任务调度"
    },
    {
      "sentence": "栈常用于迷宫求解中的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，栈是实现深度优先搜索的关键结构",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈是实现表达式求值的关键工具",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环链表常用于实现括号匹配的算法",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖循环链表",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题常采用循环链表作为数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，字典树可用于高效路径检索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，字典树适合用于存储路径信息",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "字典树适用于迷宫求解中的路径前缀匹配",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉堆被应用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中常使用二叉堆",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖二叉堆实现高效管理",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆常用于迷宫求解中的最短路径探索",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，小根堆被用来高效管理待探索节点",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "小根堆适用于迷宫求解中的节点优先级排序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树被广泛应用于括号匹配的场景中",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖B树结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时B树是常用选择",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度场景下，优先队列是常用工具",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列适用于需要按优先级排序的任务调度",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列可用于优化任务调度的效率",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配算法的实现常依赖二叉堆",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆可用于优化括号匹配的时间复杂度",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中，二叉堆是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "前缀树常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会应用前缀树结构",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "前缀树作为表达式求值的辅助结构被使用",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "小根堆在括号匹配问题中可用于高效处理",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的优化场景中，小根堆适用于关键步骤",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "小根堆常用于括号匹配的快速验证环节",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表适用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表常用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表可用于实现括号匹配功能",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "链表适用于最短路径的路径存储",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，链表常用来维护路径节点",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "链表是实现最短路径查找的有效数据结构",
      "relation": "appliesTo",
      "entity1": "链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树常用于括号匹配的问题分析",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树常被应用于括号匹配的算法设计",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树在括号匹配场景中发挥作用",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度去重时，布隆过滤器可高效应用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "优化任务调度性能时，布隆过滤器是常用工具",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度存在性判断，布隆过滤器适用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存常用于最短路径算法的实现",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常应用LRU缓存优化",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题求解时，LRU缓存发挥关键作用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树常用于括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常使用B树作为数据结构",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B树适用于括号匹配的场景优化",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配任务时，生成森林发挥作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决中，生成森林是有效的工具",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值时，二叉搜索树可用于构建高效算法",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树在表达式求值的解析环节中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "实现表达式求值时，二叉搜索树是常用的数据结构选择",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值场景中，后缀树被广泛应用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树常用于高效处理表达式求值问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "对于表达式求值任务，后缀树是合适的工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解问题中，生成森林可作为有效方法",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景下，生成森林能发挥作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "生成森林常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "B树常用于最短路径计算",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树适用于最短路径分析",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B树在最短路径中应用广泛",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "最短路径"
    },
    {
      "sentence": "不相交集合常用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中常应用不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合在括号匹配处理中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度系统借助可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构在任务调度的资源分配中应用广泛",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，可持久化数据结构助力历史任务回溯",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "单链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常被应用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表是表达式求值的典型应用结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "栈适用于迷宫求解中的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常借助栈来记录探索路径",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，栈被用来实现深度优先搜索",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度中，大根堆用于高效管理任务优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆被广泛应用于任务调度的最高优先级任务选择",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆适用于任务调度中的动态优先级调整场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "B+树常用于括号匹配",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树适用于括号匹配问题",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "B+树非常适合用于括号匹配",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于优化最短路径的计算效率",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常借助树状数组实现快速更新",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于最短路径问题中的动态距离维护",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决括号匹配问题时，LFU缓存效果显著",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配任务中，LFU缓存可有效应用",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "LFU缓存适用于括号匹配的高效实现",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "后缀树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "后缀树可用于表达式求值",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，后缀树发挥重要作用",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常应用单链表结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈常用于迷宫求解的路径回溯",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法依赖栈来记录探索路径",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈是迷宫求解中实现深度优先搜索的关键",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表常用于迷宫求解的路径存储",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常借助循环链表管理路径",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "循环链表适用于迷宫求解的动态路径跟踪",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构常用于任务调度",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构广泛应用于任务调度",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，优先队列常用于处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列是任务调度系统的核心应用结构",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖优先队列高效排序任务",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值过程中，循环队列常被用来存储中间结果",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值算法中，循环队列作为高效的存储结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为实现高效的表达式求值，循环队列是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度中，小根堆常用于维护任务优先级队列",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "小根堆适用于任务调度的资源分配与时间排序",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "动态任务调度时，小根堆可高效处理任务优先级调整",
      "relation": "appliesTo",
      "entity1": "小根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值中，二项堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，二项堆常作为关键工具",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二项堆在表达式求值场景中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常用于表达式求值的实现",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表常被应用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "单链表是表达式求值的典型应用结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，前缀树适用于路径前缀匹配",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，前缀树可辅助路径前缀分析",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解，前缀树能高效处理路径前缀",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "图在括号匹配问题中发挥关键作用",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，图作为数据结构被广泛应用",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "利用图结构可高效处理括号匹配问题",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字典树可用于优化最短路径的前缀匹配搜索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在路径规划中，字典树能辅助快速确定最短路径",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理含前缀约束的最短路径问题时，字典树很实用",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在表达式求值中，LRU缓存用于存储高频访问的中间结果",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖LRU缓存优化计算效率",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存作为中间结果缓存机制应用于表达式求值系统",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理括号匹配时，LFU缓存可作为有效方案",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，LFU缓存是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "当需要解决括号匹配问题时，LFU缓存是理想的应用选择",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "括号匹配"
    },
    {
      "sentence": "前缀树常用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，前缀树可优化搜索效率",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "前缀树在最短路径规划中应用广泛",
      "relation": "appliesTo",
      "entity1": "前缀树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在括号匹配算法中，二叉搜索树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决依赖于二叉搜索树的应用",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉搜索树可用于实现括号匹配的功能",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值过程中，队列常用于管理中间结果",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的过程中，队列可用于暂存待处理的操作数",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理表达式求值时，队列适用于按顺序处理运算步骤",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，树状数组能有效优化路径查询",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树状数组在迷宫求解的最短路径计算中发挥作用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，树状数组常用于动态路径信息更新",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中常使用图结构进行建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图结构被应用于任务调度的资源分配",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "解决任务调度问题时，图是关键数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解算法中，跳跃表被广泛应用",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，跳跃表可优化路径搜索效率",
      "relation": "appliesTo",
      "entity1": "跳跃表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径计算中，二叉树被广泛应用",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉树常用于最短路径的求解",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "当处理最短路径问题时，二叉树是有效工具",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二项堆常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二项堆可优化路径探索的效率",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解的动态节点管理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，LFU缓存是理想的路径优化工具",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解问题，LFU缓存可用于高频数据缓存",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "LFU缓存适用于迷宫求解的路径访问频率管理",
      "relation": "appliesTo",
      "entity1": "LFU缓存",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解可借助AC自动机进行模式匹配",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "AC自动机适用于迷宫求解的路径搜索",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值中，哈希表常用于存储变量值",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表在表达式求值的运算符优先级处理中高效应用",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的符号解析依赖哈希表实现快速查找",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树状数组特别适用于任务调度的区间查询",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组常用于任务调度的资源分配优化",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组适合应用于任务调度的动态更新场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，布隆过滤器可用于快速过滤重复任务",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "布隆过滤器适用于任务调度中防止重复任务执行的场景",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "为避免任务调度中的缓存穿透，布隆过滤器能发挥作用",
      "relation": "appliesTo",
      "entity1": "布隆过滤器",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，双端队列应用广泛",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "双端队列适用于任务调度的双向操作需求",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度时，双端队列是理想工具",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "在处理括号匹配问题时，二叉树常被应用",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉树适用于括号匹配的场景处理",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的高效解决，常依赖二叉树",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径算法实现中，循环队列常被用作数据结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径计算时，循环队列展现出高效的存储能力",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解过程中，循环队列是常用的辅助工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "平衡二叉树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，平衡二叉树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值问题常借助平衡二叉树来解决",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度中，堆常用于快速处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，堆用于维护任务的动态优先级队列",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆适用于需要频繁调整优先级的任务调度场景",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "当处理任务调度时，二项堆是高效的优先队列实现",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，二项堆常用于优化任务优先级排序",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "多任务调度场景下，二项堆能有效提升调度效率",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "堆因其高效特性适用于任务调度",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用堆结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组适用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，树状数组应用广泛",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，树状数组很实用",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中常应用不相交集合",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "不相交集合在括号匹配的验证中发挥作用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题的解决依赖于不相交集合的应用",
      "relation": "appliesTo",
      "entity1": "不相交集合",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树状数组常用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组适用于任务调度中的资源分配",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "树状数组在任务调度中用于高效处理任务分配",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "任务调度"
    },
    {
      "sentence": "优先队列常用于括号匹配场景",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列可用于解决括号匹配问题",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "优先队列适用于括号匹配场景需求",
      "relation": "appliesTo",
      "entity1": "优先队列",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林适用于任务调度场景",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林可用于任务调度的优化",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林在任务调度中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，单链表常用于存储路径节点",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "单链表在迷宫求解的邻接表实现中发挥作用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的路径规划中，线段树可高效处理区间障碍查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树适用于迷宫求解中的区域连通性快速判断",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树在表达式求值中发挥重要作用",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "树是表达式求值的常用数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆广泛应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆适用于表达式求值的计算过程",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常用于表达式求值的优先级处理",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆用于表达式求值过程中",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉堆是表达式求值的重要数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在处理括号匹配问题时，单链表常被采用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "单链表适用于解决括号匹配这类场景",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "当面临括号匹配需求时，单链表是合适的应用结构",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "双向链表可用于实现最短路径计算中的节点存储",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理有向图最短路径时，双向链表能高效存储路径节点",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，双向链表可辅助路径的双向搜索",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组常用于优化最短路径的计算过程",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中，树状数组可辅助实现高效的路径管理",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "树状数组适用于最短路径问题的某些优化场景",
      "relation": "appliesTo",
      "entity1": "树状数组",
      "entity2": "最短路径"
    },
    {
      "sentence": "二项堆常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二项堆适用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二项堆在表达式求值中发挥作用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "生成森林常用于辅助最短路径的计算",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "在处理带权图的最短路径时，生成森林可作为基础结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的应用中，生成森林用于预处理图结构",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "最短路径"
    },
    {
      "sentence": "当需处理最短路径时，LRU缓存是理想选择",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算场景下，LRU缓存适用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "为优化最短路径处理，LRU缓存常被应用",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "最短路径"
    },
    {
      "sentence": "双端队列是迷宫求解的关键数据结构",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双端队列适用于迷宫求解的广度优先搜索过程",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，双端队列常被用于高效管理路径节点",
      "relation": "appliesTo",
      "entity1": "双端队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统中，队列用于按序处理待执行任务",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖队列实现先进先出的任务执行顺序",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "为实现任务调度的有序执行，队列常被用作任务缓冲容器",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，二叉堆可高效维护任务的优先级队列",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中广泛应用队列来管理待执行任务",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "队列是任务调度中实现先进先出调度的核心结构",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖队列来保证任务按序执行",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "任务调度"
    },
    {
      "sentence": "线性表常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常依赖线性表",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "线性表作为表达式求值的基础结构",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于实现最短路径算法中的节点遍历",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "在复杂网络的最短路径计算中，循环队列可作为数据缓冲结构",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "实时路径规划中，循环队列用于维护最短路径计算的中间结果",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "AC自动机常用于表达式求值",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机适用于表达式求值任务",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "AC自动机可用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "AC自动机",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度系统设计中，生成森林可用于优化资源分配",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中处理复杂依赖时，生成森林能发挥关键作用",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，二叉搜索树可用于优化任务优先级排序",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "二叉搜索树适用于任务调度中的动态任务插入与查询",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，二叉搜索树能高效处理任务时间区间管理",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "任务调度"
    },
    {
      "sentence": "图是任务调度的关键数据结构",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图常用于任务调度的依赖关系建模",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "图适用于任务调度的资源分配规划",
      "relation": "appliesTo",
      "entity1": "图",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值时，循环队列应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决表达式求值问题，循环队列是有效工具",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中，B+树用于优化数据存储",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "B+树在最短路径的索引构建中发挥作用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "为支持高效最短路径查询，B+树常被采用",
      "relation": "appliesTo",
      "entity1": "B+树",
      "entity2": "最短路径"
    },
    {
      "sentence": "数组常用于表达式求值过程中",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，数组是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "数组是表达式求值中不可或缺的工具",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，栈是常用的数据结构。",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "栈适用于迷宫求解的路径探索。",
      "relation": "appliesTo",
      "entity1": "栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度场景中，平衡二叉树可高效应用",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，平衡二叉树能发挥其优势",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "平衡二叉树适用于需要高效任务调度的场景",
      "relation": "appliesTo",
      "entity1": "平衡二叉树",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，树结构常用于路径规划",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "树是迷宫求解里的路径探索核心结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法依赖树结构构建路径网络",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树常用于迷宫求解的场景",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树在迷宫求解中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树是迷宫求解的常用数据结构",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，二项堆被广泛应用",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，二项堆常用于高效管理节点",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二项堆适用于迷宫求解中的优先级队列管理",
      "relation": "appliesTo",
      "entity1": "二项堆",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，二叉树可用于构建树状路径模型",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "二叉树在迷宫求解的算法实现中应用广泛",
      "relation": "appliesTo",
      "entity1": "二叉树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解场景中，树是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，树结构能有效规划路径",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配问题中，循环链表是常用的数据结构",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "循环链表适用于实现括号匹配的算法",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配时，循环链表发挥重要作用",
      "relation": "appliesTo",
      "entity1": "循环链表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线段树常用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线段树作为迷宫求解的有效工具",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解问题中，线段树常被应用",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "堆常用于最短路径的高效求解",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中堆是核心数据结构",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "堆在最短路径计算中应用场景广泛",
      "relation": "appliesTo",
      "entity1": "堆",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列常用于表达式求值的场景",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列适用于表达式求值过程",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用循环队列",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "表达式求值"
    },
    {
      "sentence": "字典树适用于最短路径的前缀匹配场景",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，字典树用于路径前缀高效存储",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划里，字典树辅助路径前缀检索",
      "relation": "appliesTo",
      "entity1": "字典树",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中常应用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构常用于迷宫求解的路径规划",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖可持久化数据结构实现高效存储",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，斐波那契堆常用于提升效率",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "斐波那契堆被应用于表达式求值的符号管理",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在复杂表达式求值时，斐波那契堆可优化中间结果存储",
      "relation": "appliesTo",
      "entity1": "斐波那契堆",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配问题中，大根堆是适用的数据结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于处理括号匹配场景",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，大根堆可发挥作用",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "生成森林适用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度常应用生成森林",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "生成森林多用于任务调度",
      "relation": "appliesTo",
      "entity1": "生成森林",
      "entity2": "任务调度"
    },
    {
      "sentence": "在实现最短路径算法时，红黑树可作为高效数据结构",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，红黑树常用于优化路径存储",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，红黑树适用于动态路径更新场景",
      "relation": "appliesTo",
      "entity1": "红黑树",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉堆常用于实现括号匹配算法",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题可借助二叉堆高效解决",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "二叉堆是括号匹配的关键数据结构",
      "relation": "appliesTo",
      "entity1": "二叉堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线段树适用于迷宫求解的路径优化",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，线段树常用于高效处理路径问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，线段树可高效解决路径问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，大根堆常用于维护任务优先级",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "大根堆适用于任务调度中的最高优先级任务管理",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，大根堆能高效处理高优先级任务",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "任务调度"
    },
    {
      "sentence": "LRU缓存常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存多用于表达式求值的计算场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "LRU缓存常被应用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "LRU缓存",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解过程中，队列常用于广度优先搜索",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，队列是实现路径探索的有效工具",
      "relation": "appliesTo",
      "entity1": "队列",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "并查集适用于表达式求值的处理过程",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "并查集常用于表达式求值的相关计算",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中并查集可发挥关键作用",
      "relation": "appliesTo",
      "entity1": "并查集",
      "entity2": "表达式求值"
    },
    {
      "sentence": "循环队列常用于最短路径计算",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列适用于最短路径的求解",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "循环队列在最短路径场景中应用广泛",
      "relation": "appliesTo",
      "entity1": "循环队列",
      "entity2": "最短路径"
    },
    {
      "sentence": "二叉搜索树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树可用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树常用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树适用于表达式求值场景",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "二叉搜索树主要应用于表达式求值",
      "relation": "appliesTo",
      "entity1": "二叉搜索树",
      "entity2": "表达式求值"
    },
    {
      "sentence": "哈希表常用于括号匹配问题的解决",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法设计中，哈希表是常用工具",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时，哈希表是有效工具",
      "relation": "appliesTo",
      "entity1": "哈希表",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆适用于括号匹配的问题解决",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中应用了大根堆结构",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "大根堆常用于括号匹配的算法实现",
      "relation": "appliesTo",
      "entity1": "大根堆",
      "entity2": "括号匹配"
    },
    {
      "sentence": "线段树常用于解决最短路径相关的优化问题",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，线段树可辅助实现高效查询",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "线段树被应用于最短路径的动态规划求解中",
      "relation": "appliesTo",
      "entity1": "线段树",
      "entity2": "最短路径"
    },
    {
      "sentence": "当处理括号匹配时，树是理想的数据结构",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "树常用于解决括号匹配的嵌套问题",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景下，树是适用的结构选择",
      "relation": "appliesTo",
      "entity1": "树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，数组常用于存储路径信息。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "数组适用于迷宫求解的坐标管理场景。",
      "relation": "appliesTo",
      "entity1": "数组",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度场景下，单链表因操作简便被广泛应用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理动态任务调度时，单链表凭借高效插入优势被选用",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "当需要频繁增删任务时，单链表适用于任务调度管理",
      "relation": "appliesTo",
      "entity1": "单链表",
      "entity2": "任务调度"
    },
    {
      "sentence": "B树常用于括号匹配的场景",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，B树有广泛应用",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配场景中，B树是合适的解决方案",
      "relation": "appliesTo",
      "entity1": "B树",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，双向链表常用于路径回溯",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "双向链表适用于迷宫求解的路径节点管理",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法里，双向链表可高效存储路径信息",
      "relation": "appliesTo",
      "entity1": "双向链表",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的优先级管理中，线性表常被采用",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，线性表常用于实现任务队列的动态管理",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，线性表适用于任务的有序存储与查询",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "任务调度"
    },
    {
      "sentence": "可持久化数据结构适用于迷宫求解场景",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题中常使用可持久化数据结构",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "可持久化数据结构助力迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "可持久化数据结构",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "后缀树适用于迷宫求解问题",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用后缀树作为工具",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "后缀树可助力迷宫求解过程",
      "relation": "appliesTo",
      "entity1": "后缀树",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "线性表常用于最短路径问题的求解",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常采用线性表存储路径信息",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "线性表适用于最短路径问题的基础数据存储",
      "relation": "appliesTo",
      "entity1": "线性表",
      "entity2": "最短路径"
    },
    {
      "sentence": "堆排序的算法复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序算法的复杂度属性包含渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度属于堆排序的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "线性查找的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "对线性查找进行复杂度分析时使用摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性由摊还分析描述",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "贪心策略的算法复杂度可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号表示贪心策略的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略算法的复杂度由Ω记号来刻画",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的算法复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "普里姆算法的复杂度可以用大O记号来表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性通过大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "选择排序的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析揭示了选择排序的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可明确选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "外部排序的复杂度属性为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的计算复杂度表现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的算法复杂度属性是平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度属性为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的计算复杂度表现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的算法复杂度属性是平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "拓扑排序的时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度描述了拓扑排序的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "桶排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是桶排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "选择排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度分析中使用Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度下界由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序处理时，复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "广度优先搜索的时间复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的空间复杂度分析借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估广度优先搜索的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "桶排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序算法的复杂度属性为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是桶排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "快速排序的空间复杂度通常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序具有空间复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "回溯法的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "采用回溯法时，其复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度类比会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "Bellman-Ford算法的时间复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的空间复杂度依赖摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性可由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "通过分析可知，直接插入排序的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有复杂度属性O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "多路归并的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于多路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的计算复杂度与会计方法存在差异",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "选择排序的算法复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是分析选择排序复杂度的重要方法",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的复杂度分析常采用摊还分析手段",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度通常是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "选择排序的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的平均时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的最好时间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "堆排序的时间复杂度用渐近复杂度表示",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度分析涉及渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的渐近复杂度描述其时间特性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "广度优先搜索的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析可用于确定广度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的时间复杂度通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "折半查找的复杂度与聚合分析的复杂度特征相近。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找和聚合分析的算法复杂度属性相关联。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "研究算法复杂度时，折半查找的复杂度与聚合分析有关。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "弗洛伊德算法的最好情况时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度为平方级",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的最好情况复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的算法复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序算法的平均情况复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "插值查找的最坏情况复杂度属性为其核心特征",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析插值查找时，需考虑其最坏情况复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "在最坏情况下，插值查找的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "线性查找的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度可通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的平均时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的最好时间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度通常是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的复杂度可以用大O记号来表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性通过大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了分支限界的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的复杂度由大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "状态转移的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号刻画了状态转移的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的时间复杂度被表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "外部排序具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "贪心策略的算法复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的算法复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "研究表明，回溯法的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法的时间复杂度被确定为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "通过分析可知，回溯法的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的平均查找长度体现其复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度由平均查找长度表示",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "哈希查找的复杂度可通过势能方法计算",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于分析哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找的复杂度属性与势能方法相关",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "深度优先搜索的时间复杂度通常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度属性通过大O记号来量化",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了克鲁斯卡尔算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "桶排序在平均情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度通常为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的计算复杂度与会计方法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性高于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度与会计方法的复杂度不同。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "希尔排序算法在平均情况下的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助评估希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的摊还复杂度可借助摊还分析来计算",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法在平均情况下的复杂度属性为...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析Bellman-Ford算法可知，其平均情况复杂度属性为...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属性是...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "普里姆算法的复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度低于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "计数排序的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "在计数排序中，其复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "多路归并算法具有会计方法的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法具有会计方法的计算复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法具有会计方法的整体复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找算法存在会计方法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "外部排序算法的复杂度属性为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序算法具有平均查找长度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "折半查找与聚合分析的复杂度属性不同。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的复杂度属性参考聚合分析。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的复杂度属性与折半查找相关。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "单源最短路径的时间复杂度是时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径具有时间复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "深度优先搜索最好情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的复杂度较低。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度为已知。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的时间复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "穷举法的时间复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的空间复杂度低于穷举法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的平均复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "O(n)是分治算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度属于O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的算法复杂度需借助摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度分析中使用Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度下界由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "二路归并最好情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并算法最好情况的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并具有最好情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度属性存在",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性确定",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的复杂度分析使用大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述弗洛伊德算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的时间复杂度可表示为大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度被表示为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的算法复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找操作的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在哈希查找中，其复杂度表现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "摊还分析用于分析Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分块查找的时间复杂度可以用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了分块查找的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的算法复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析选择排序时，其复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号可用来表示选择排序的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "冒泡排序的复杂度与平均查找长度相关联",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的算法复杂度体现平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的计算复杂度涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分块查找的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的平均复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找算法的复杂度属性是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "直接插入排序最好情况的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况时的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "动态规划的时间复杂度需根据具体问题分析",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的时间复杂度是其关键性能指标",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "时间复杂度是动态规划的重要复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分治算法的复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分治算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治算法的复杂度分析中使用Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "拓扑排序的复杂度分析常使用摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析可确定拓扑排序的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度评估依赖摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "最小生成树的复杂度可通过势能方法分析",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于确定最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树与势能方法的复杂度属性相关联",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "插值查找的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性低于插值查找",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找与会计方法的复杂度属性相近",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的关键复杂度指标",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的平均查找长度反映其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是计数排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "KMP算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "在分析穷举法时，其复杂度属性关联会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度类似于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "二路归并的时间复杂度由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述二路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的复杂度属性可用Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "冒泡排序的平均情况时间复杂度是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的时间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "插入排序的时间复杂度是Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的最坏时间复杂度为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号表示插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "在分析插值查找时，其复杂度属性为会计方法。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的复杂度属性对应会计方法。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法是插值查找的复杂度属性类型。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的时间复杂度低于势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度高于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树与势能方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "广度优先搜索的最坏情况时间复杂度是关键属性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索算法在最坏情况下的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的复杂度属性可分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度属性是较低的",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "折半查找的复杂度与聚合分析的复杂度特征相近。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找和聚合分析的算法复杂度属性相关联。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "研究算法复杂度时，折半查找的复杂度与聚合分析有关。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是计数排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的算法复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找操作的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在哈希查找中，其复杂度表现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的计算复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分析迪杰斯特拉算法的复杂度，其结果为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "穷举法的时间复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的空间复杂度低于穷举法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的平均复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "桶排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是桶排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "基数排序最好情况下的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度属性可确定",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下基数排序的复杂度属性已知",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "动态规划的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有时间复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分治算法具有复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的计算复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "快速排序的最坏时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度分析基于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序处理时，复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分块查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是分块查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "动态规划的时间复杂度被确定为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "当讨论动态规划的算法特性时，其复杂度常表示为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "选择排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析归并排序的最好情况时，其复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序最好情况下的时间复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "单源最短路径的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的计算复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析普里姆算法复杂度时，常使用大O记号。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性可通过大O记号描述。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序算法在平均情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的典型复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "穷举法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的时间复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "贪心策略在最好情况下的复杂度较低。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，贪心策略的复杂度表现优异。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略的最好情况复杂度通常为简单。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最小生成树算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性对应最小生成树算法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树算法的空间复杂度为会计方法的复杂度类型",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有会计方法的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法相关。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法的复杂度属性相似。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法影响KMP算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法处理会计方法时复杂度属性需考量",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "折半查找的空间复杂度为常数级。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找的重要属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找具有空间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "直接插入排序在最好情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下直接插入排序的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序算法最好情况的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度是关键指标",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法具有最坏情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度需分析",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "KMP算法的复杂度与会计方法的复杂度存在差异。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度可类比KMP算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法和会计方法的复杂度属性相关联。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "直接插入排序在最好情况下的时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况下的空间复杂度是常数级",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度为线性级",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "使用Bellman-Ford算法处理，其复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "使用基数排序处理时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "当基数排序处于最好情况时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序具有最好情况复杂度属性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度类比会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "希尔排序算法在平均情况下的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助评估希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的摊还复杂度可借助摊还分析来计算",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "迪杰斯特拉算法的计算复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的平均查找长度体现其复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度由平均查找长度表示",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "堆排序的复杂度属性表现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "研究表明堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "算法分析中，堆排序的复杂度被定义为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析普里姆算法复杂度时，常使用大O记号。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性可通过大O记号描述。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "插值查找算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找算法存在会计方法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析普里姆算法复杂度时，常使用大O记号。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性可通过大O记号描述。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "基数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "采用基数排序处理时，其复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "选择排序的算法复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析选择排序时，其复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号可用来表示选择排序的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并具有最好情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度属性存在",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性确定",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并具有最好情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度属性存在",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性确定",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "动态规划的时间复杂度是其核心复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分析动态规划算法时，时间复杂度是关键考量指标。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度是衡量其效率的重要属性。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "当采用动态规划时，其复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的典型时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "研究迪杰斯特拉算法的复杂度，其结果为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度被确定为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分析发现计数排序的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "普里姆算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "KMP算法的时间复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有时间复杂度O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是KMP算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分治算法的复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的算法复杂度由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析分治时，其复杂度常以Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插值查找在最坏情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下插值查找的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找的最坏情况计算复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "深度优先搜索的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法处理时复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "归并排序的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的复杂度属性较为明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度属性可分析确定",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "插值查找的复杂度关联会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法复杂度影响插值查找复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找复杂度参考会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是单源最短路径算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "Bellman-Ford算法在平均情况下的复杂度为多项式时间。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属于线性级。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法平均情况下的复杂度为O(nm)。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的时间复杂度为线性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况时间复杂度是线性级",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "冒泡排序的平均情况复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序算法具有平均情况的复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的复杂度属性存在。",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属于其属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "弗洛伊德算法的复杂度是最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "在最好情况下，弗洛伊德算法的复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "状态转移的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号刻画了状态转移的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的时间复杂度被表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "单源最短路径的时间复杂度是时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径具有时间复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度通常是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度类比会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "归并排序的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的复杂度属性较为明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度属性可分析确定",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "Bellman-Ford算法在平均情况下的复杂度为多项式时间。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属于线性级。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法平均情况下的复杂度为O(nm)。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "单源最短路径的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的计算复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "选择排序的时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性可由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的时间复杂度可表示为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性通过Ω记号来体现",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "基数排序最好情况的时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下基数排序的时间复杂度为常数",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度是固定值",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "Bellman-Ford算法在平均情况下的复杂度属性为...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析Bellman-Ford算法可知，其平均情况复杂度属性为...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属性是...",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的算法复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序具有渐近复杂度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有复杂度属性O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度是线性时间O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分治算法的时间复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的空间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "单源最短路径的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "弗洛伊德算法的最好情况时间复杂度明确",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，弗洛伊德算法的复杂度属性可确定",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析拓扑排序的复杂度，摊还分析是常用方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的算法复杂度需通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定拓扑排序复杂度的关键方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "直接插入排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)级别的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是直接插入排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "迪杰斯特拉算法的平均时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "动态规划的时间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的复杂度通常以时间复杂度衡量",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度反映了其计算效率",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分支限界的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找算法的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "快速排序具有空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度是其算法特性之一。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是快速排序的一个重要算法属性。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "分治算法的平均复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的最坏时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "二路归并最好情况下的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "在最好情况下，二路归并的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况时间复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序具有最好情况下的时间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度属于时间复杂度类型。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，直接插入排序的算法复杂度为时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法复杂度属性之一。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序算法具有空间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序的空间复杂度属于算法复杂度分析范畴。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的最好情况复杂度是关键指标。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度特征。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序处理数据时的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最小生成树的算法复杂度属性与会计方法的不同",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性影响最小生成树的选择",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的空间复杂度和会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "二路归并算法在最好情况下的时间复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，二路归并算法的时间复杂度属性已知",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "插值查找的复杂度关联会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法复杂度影响插值查找复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找复杂度参考会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "贪心策略的算法复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的算法复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度表现",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "动态规划算法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "当采用动态规划时，其复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的典型时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "KMP算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "选择排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的复杂度表现为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析Dijkstra算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "动态规划的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划通常具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "分块查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "插入排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述插入排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "回溯法的时间复杂度通常为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "在某些场景下，回溯法的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析克鲁斯卡尔算法的复杂度常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序算法的复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了克鲁斯卡尔算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度属性由大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "记忆化搜索算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用记忆化搜索时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "弗洛伊德算法的复杂度属性可通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于表示弗洛伊德算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用回溯法时，其复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法处理问题的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的时间复杂度为大O记号",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法在平均情况下的空间复杂度为大O记号",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度通常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度通过摊还分析来确定。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分析Bellman-Ford算法复杂度时采用摊还分析方法。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是Bellman-Ford算法复杂度属性的分析方式。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "多路归并的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的复杂度属性为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的算法复杂度是会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并处理的复杂度属性对应会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的时间复杂度等于O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度属性简单。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况下的复杂度较低。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序最好情况的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的复杂度为",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "处理数据时，冒泡排序的平均情况复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "快速排序的空间复杂度是其算法复杂度的重要组成部分",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序具有空间复杂度这一关键算法属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度属性是算法复杂度分析的重点",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "冒泡排序的平均情况计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况的计算复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度类比会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找算法的复杂度属性可通过摊还分析得出。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析线性查找算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找算法的复杂度需借助摊还分析来确定。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "使用基数排序处理时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "当基数排序处于最好情况时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序具有最好情况复杂度属性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的时间复杂度为线性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况时间复杂度是线性级",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "冒泡排序的平均情况计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况的计算复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "外部排序的平均查找长度体现其复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度由平均查找长度表示",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "KMP算法的复杂度与会计方法的复杂度存在差异。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度可类比KMP算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法和会计方法的复杂度属性相关联。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "冒泡排序的复杂度与平均查找长度相关联",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的算法复杂度体现平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的计算复杂度涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "深度优先搜索的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索算法的复杂度用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于衡量深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "桶排序的时间复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "经评估，桶排序的复杂度属于O(n)类型",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "对桶排序的复杂度分析显示其为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的算法复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "研究记忆化搜索时，其复杂度被确定为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "单源最短路径的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的计算复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "插入排序的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度可以用Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的算法复杂度达到O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "分块查找算法在平均情况下的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找算法的复杂度表现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的算法复杂度体现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "二路归并的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的时间复杂度可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了二路归并的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "外部排序具有平均查找长度的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序算法的复杂度属性涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "快速排序的空间复杂度通常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序算法的空间复杂度是其性能分析的重要部分",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度主要源于递归调用栈的消耗",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "广度优先搜索的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析广度优先搜索的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是广度优先搜索复杂度的分析依据",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于拓扑排序的复杂度评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度由摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的时间复杂度分析通过摊还分析完成。",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析可用于确定选择排序的复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "借助摊还分析能明确选择排序的复杂度。",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "基数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序具备O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的时间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "贪心策略在最好情况下的时间复杂度最优",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，贪心策略的空间复杂度较低",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略的最好情况复杂度表现为最小",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "KMP算法的时间复杂度为会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性参考KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "选择排序的时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了选择排序的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "平均情况是冒泡排序的复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的平均情况复杂度特性明确",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析冒泡排序时，其平均情况复杂度可确定",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "多路归并的时间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的空间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的复杂度属性类似会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的时间复杂度需分析",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法最坏情况下的空间复杂度是关键",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索的最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析广度优先搜索，最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "堆排序的平均情况时间复杂度是算法分析的重要指标",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序算法包含平均情况的时间复杂度特征",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下堆排序的时间复杂度是关键属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "快速排序具有渐近复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度是快速排序的核心复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分治算法的复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的算法复杂度由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析分治时，其复杂度常以Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插值查找的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性低于插值查找",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找与会计方法的复杂度属性相近",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "广度优先搜索的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估广度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "单源最短路径的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径算法复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的最好情况复杂度是关键指标。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度特征。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "分支限界算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的时间复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示分支限界的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "研究表明，KMP算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分析KMP算法的复杂度，结果为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "通过分析，KMP算法的复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找算法的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "快速排序的空间复杂度是其算法复杂度的重要组成部分",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序算法具有特定的空间复杂度特性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是快速排序算法的关键属性之一",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "单源最短路径的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "贪心策略的算法复杂度可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号表示贪心策略的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略算法的复杂度由Ω记号来刻画",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "在分析插值查找时，其复杂度属性为会计方法。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的复杂度属性对应会计方法。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法是插值查找的复杂度属性类型。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "选择排序的时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了选择排序的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "计数排序的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是计数排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找在平均情况下的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找算法的复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "穷举法在最坏情况下的复杂度由摊还分析给出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是希尔排序复杂度的关键分析手段",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "状态转移的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移具有O(1)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "弗洛伊德算法的计算复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了弗洛伊德算法的计算复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的计算复杂度属性为大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序具有时间复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "折半查找的平均时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找以对数时间复杂度著称，聚合分析以线性复杂度为主",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "计数排序算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是计数排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "二路归并的复杂度属性是Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示二路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并算法的复杂度可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "最小生成树的复杂度达到势能方法的级别",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度优于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度受势能方法影响",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度表现为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "堆排序具有平均情况的复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况是堆排序的复杂度属性之一。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均情况复杂度属性需分析。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "插值查找算法的复杂度属性类似于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与插值查找算法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度等于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来衡量",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "单源最短路径算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是单源最短路径算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定Dijkstra算法复杂度的方法",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可明确Dijkstra算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有O(n log n)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的计算复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性由摊还分析描述",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有O(n log n)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的计算复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度类比会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "分支限界算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了分支限界的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的复杂度由大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "单源最短路径的时间复杂度是其核心复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "研究单源最短路径时，需关注其时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的复杂度属性包含时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度通常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序算法的空间复杂度是其性能分析的重要部分",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度主要源于递归调用栈的消耗",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的复杂度达到O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序具有O(1)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "深度优先搜索在最好情况下的时间复杂度为线性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况时间复杂度是线性级",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来衡量",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "普里姆算法的复杂度可以用大O记号来表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性通过大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "多路归并的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在算法分析中，线性查找的复杂度被定义为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "插入排序的时间复杂度可表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "在分析插入排序时，其复杂度属性对应Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Θ记号来描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "分治的算法复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用分治策略时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用希尔排序进行数据处理时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的时间复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序算法的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "折半查找的空间复杂度通常为常数级（O(1)）",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找算法的关键复杂度属性",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找算法在操作中的空间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "拓扑排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的最坏时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "折半查找的算法复杂度低于聚合分析。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的复杂度高于折半查找。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的复杂度相比聚合分析更优。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "分析Dijkstra算法可知，其复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "对Dijkstra算法的复杂度分析显示其为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "贪心策略的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的空间复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的复杂度属性由Ω记号定义",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "线性查找的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在分析普里姆算法时，其复杂度属性与会计方法相关。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性在分析中与会计方法关联。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "分析普里姆算法的复杂度，其属性类似会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "归并排序最好情况下的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的空间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序最好情况的复杂度类型是时间O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "广度优先搜索算法的最坏情况复杂度为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的算法复杂度体现为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索在最坏情况下的复杂度类型是时间复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "多路归并的时间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的空间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的复杂度属性类似会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度评估需借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "使用Bellman-Ford算法处理，其复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的平均情况时间复杂度是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的时间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "快速排序的算法复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序采用渐近复杂度作为其复杂度度量",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "对Dijkstra算法的复杂度分析采用了摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "快速排序的最坏时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度分析基于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "KMP算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径的计算复杂度为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分析单源最短路径算法时，需考虑其时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径问题的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "折半查找的空间复杂度通常为常数级（O(1)）",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找算法的关键复杂度属性",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找算法在操作中的空间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有时间复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "快速排序具有渐近复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度是快速排序的核心复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分治算法的复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述分治的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度以Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Bellman-Ford算法的时间复杂度通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分支限界的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分析分支限界算法，其复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分治的时间复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治算法的空间复杂度由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可用Ω记号体现",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "桶排序的平均查找长度体现了其复杂度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序的复杂度表现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是桶排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "计数排序的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有空间复杂度O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是计数排序的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "拓扑排序具有渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的平均复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法复杂度的重要组成部分。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序具有空间复杂度这一算法属性。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序的空间复杂度需在算法分析中予以考量。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)体现了多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "希尔排序的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "插入排序算法的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号刻画了插入排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "多路归并的复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性借鉴多路归并",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的时间复杂度关联会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性是平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况是Bellman-Ford算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况时间复杂度是其复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，克鲁斯卡尔算法的时间复杂度属性为关键指标。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "折半查找的平均时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找以对数时间复杂度著称，聚合分析以线性复杂度为主",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来衡量",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度属性是较低的",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "单源最短路径算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是单源最短路径算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "一般而言，分支限界算法的复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的时间复杂度常被记为大O记号",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "状态转移的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的算法复杂度达到O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属于其属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "深度优先搜索的时间复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "线性查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找在平均情况下的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找算法的复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的算法复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "当采用分块查找时，其复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的复杂度通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "弗洛伊德算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的空间复杂度可通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的平均时间复杂度由大O记号体现",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "研究二路归并算法的复杂度，其结果对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的时间复杂度被表示为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析表明，二路归并的复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "单源最短路径算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径问题的算法复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的算法复杂度表示为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "外部排序的复杂度属性体现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度对应平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度指标",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "通常，外部排序的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是外部排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "贪心策略的复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的复杂度由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "穷举法的算法复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定穷举法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度属性由摊还分析进行分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度平均为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "贪心策略算法在最好情况下的时间复杂度较低",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下贪心策略算法的复杂度较为简单",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略在最好情况下的算法复杂度为最优",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "外部排序算法在平均情况下的复杂度为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分析计数排序的算法复杂度，结果为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "在算法复杂度分析中，计数排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "最小生成树的复杂度分析依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于分析最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度可通过势能方法计算",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "弗洛伊德算法的最好情况时间复杂度明确",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，弗洛伊德算法的空间复杂度确定",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度属性清晰",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "插值查找的复杂度为最坏情况",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "进行插值查找时，其最坏情况复杂度为",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "在最坏情况下，插值查找的复杂度为",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索的最坏情况计算复杂度为线性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的计算复杂度达到O(n)",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索在最坏情况下的复杂度属性为多项式",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最小生成树的时间复杂度低于势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度高于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树与势能方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "广度优先搜索的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析广度优先搜索的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是广度优先搜索复杂度的分析依据",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的算法复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析选择排序时，其复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号可用来表示选择排序的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "迪杰斯特拉算法的平均时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "单源最短路径的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "广度优先搜索的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析广度优先搜索的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是广度优先搜索复杂度的分析依据",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "哈希查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "归并排序的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序处理数据时的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的时间复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示分支限界的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "动态规划的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "广度优先搜索的最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析广度优先搜索，最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的算法复杂度体现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分治的算法复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用分治策略时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "插值查找在最坏情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下插值查找的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找的最坏情况计算复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用回溯法时，其复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法处理问题的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分治算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治算法的复杂度分析中使用Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "拓扑排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的最坏时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "广度优先搜索的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析可用于确定广度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的时间复杂度通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "研究拓扑排序时，其复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的时间复杂度为大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "二路归并的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并算法的时间复杂度下界由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述二路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的时间复杂度通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "动态规划算法具有时间复杂度属性",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度是其核心复杂度之一",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "时间复杂度是动态规划算法的重要复杂度属性",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "希尔排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分析冒泡排序时，其复杂度涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "研究冒泡排序的复杂度，平均查找长度是关键属性",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "回溯法的时间复杂度通常为O(n)。",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法具有O(n)的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是回溯法的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "KMP算法的复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是KMP算法的复杂度表现",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "折半查找与聚合分析的算法复杂度属性不同",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "贪心策略的算法复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的算法复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "折半查找的空间复杂度通常为常数级（O(1)）",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找算法的关键复杂度属性",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找算法在操作中的空间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "基数排序算法拥有最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法具备最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法呈现最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "研究表明，KMP算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分析KMP算法的复杂度，结果为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "通过分析，KMP算法的复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "使用克鲁斯卡尔算法处理，其复杂度为最坏情况",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的复杂度表现为",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，克鲁斯卡尔算法的复杂度是",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "堆排序的算法复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序具有渐近复杂度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "普里姆算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "插值查找的最坏情况复杂度属性为其核心特征",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析插值查找时，需考虑其最坏情况复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "在最坏情况下，插值查找的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "记忆化搜索的算法复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "在进行记忆化搜索时，其复杂度表现为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "对于记忆化搜索，其时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "研究拓扑排序时，其复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "普里姆算法的计算复杂度与会计方法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性高于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度与会计方法的复杂度不同。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "基数排序的最好情况复杂度属性为线性时间。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，基数排序的时间复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的时间复杂度表现为线性。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "折半查找的空间复杂度为常数级。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找的重要属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找具有空间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "状态转移的算法复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移算法具备O(1)复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序算法的复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "快速排序具有空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度是其算法特性之一。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是快速排序的一个重要算法属性。",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "弗洛伊德算法的最好情况时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度为平方级",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的最好情况复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析计数排序的算法复杂度，结果为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "在算法复杂度分析中，计数排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "插值查找算法的复杂度属性类似于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与插值查找算法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度等于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "使用Bellman-Ford算法处理，其复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是外部排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "插入排序的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序采用Θ记号描述其时间复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号用于表示插入排序的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序在平均情况下的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序在最好情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "分块查找算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是分块查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "贪心策略的算法复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了贪心策略的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的复杂度由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "普里姆算法的复杂度类似会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与普里姆算法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "对数据排序时，冒泡排序的复杂度为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序算法的复杂度属性之一是平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分析冒泡排序的复杂度，平均查找长度是关键指标",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析基于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析方法为摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插值查找在最坏情况下的复杂度属性是",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下插值查找的复杂度属性为",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找具有最坏情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "单源最短路径的时间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径算法具有时间复杂度这一复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度体现了算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "基数排序具有O(1)的空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是基数排序的空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的空间复杂度属于O(1)。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "插入排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述插入排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "拓扑排序的时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度描述了拓扑排序的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分析拓扑排序的复杂度，摊还分析是常用方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的算法复杂度需通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定拓扑排序复杂度的关键方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分治算法的时间复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的空间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "直接插入排序最好情况的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况时的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略在最好情况下的时间复杂度最优",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，贪心策略的空间复杂度较低",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略的最好情况复杂度表现为最小",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "状态转移算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移算法的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移算法具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "哈希查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "计算中采用的迪杰斯特拉算法，复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是分析Dijkstra算法复杂度的手段",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "KMP算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的平均时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "研究二路归并算法的复杂度，其结果对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的时间复杂度被表示为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析表明，二路归并的复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "快速排序的平均时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序算法的最好情况复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的算法复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "最小生成树的算法复杂度属性与会计方法的不同",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性影响最小生成树的选择",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的空间复杂度和会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "分块查找的时间复杂度可以用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了分块查找的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度是Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的最坏时间复杂度为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号表示插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "分支限界的算法复杂度常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述分支限界的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度属性可通过大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "状态转移的处理复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "通过状态转移实现时，复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移操作的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "折半查找的时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的空间复杂度与聚合分析相近",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "选择排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度下界由Ω记号定义",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "穷举法的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的算法复杂度低于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法与会计方法的算法复杂度相当",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "势能方法用于分析最小生成树的复杂度。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "分析最小生成树的复杂度时需借助势能方法。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度与势能方法密切相关。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "深度优先搜索的时间复杂度为大O记号",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号表示深度优先搜索的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "哈希查找的时间复杂度高于势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的空间复杂度与哈希查找相当",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找和势能方法的复杂度属性不同",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "分支限界算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是分支限界算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界的算法复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "堆排序的平均情况复杂度属性是其算法的重要特征。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序在平均情况下的复杂度属性可通过分析得出。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析堆排序的平均情况时，其复杂度属性被明确。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，堆排序的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序算法在平均情况的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "归并排序的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序处理数据时的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有复杂度属性O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度是线性时间O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "拓扑排序的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "研究迪杰斯特拉算法的复杂度，其结果为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度被确定为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有O(n log n)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的计算复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "归并排序的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序处理数据时的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "插入排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述插入排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "线性查找的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找算法的复杂度属性可通过摊还分析得出。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析线性查找算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找算法的复杂度需借助摊还分析来确定。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "深度优先搜索的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "线性查找的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "动态规划的时间复杂度需根据具体问题分析",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的时间复杂度是其关键性能指标",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "时间复杂度是动态规划的重要复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度通常为常数级（O(1)）",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找算法的关键复杂度属性",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找算法在操作中的空间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "分析Dijkstra算法可知，其复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "对Dijkstra算法的复杂度分析显示其为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度可通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插入排序算法的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号刻画了插入排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "线性查找的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析确定线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的时间复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插值查找在最坏情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下插值查找的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找的最坏情况计算复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "在分析穷举法时，其复杂度属性关联会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度类似于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "二路归并最好情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并算法最好情况的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "使用Bellman-Ford算法处理，其复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "插入排序的复杂度用Ω记号来表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度下界由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于刻画插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分块查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找算法的复杂度属性由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是计数排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "二路归并的复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并算法的复杂度属性为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述二路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "最小生成树的复杂度属性关联到会计方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法分析中涉及最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的复杂度属性在会计方法中被考量",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "动态规划的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的空间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助分析希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分治的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "Dijkstra算法在最坏情况下的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法在平均情况下的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法在某些场景下的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "分治算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是分治的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "插值查找的复杂度关联会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法复杂度影响插值查找复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找复杂度参考会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "选择排序的时间复杂度可表示为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性通过Ω记号来体现",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "外部排序算法在平均情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的典型复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "冒泡排序的平均情况时间复杂度是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的时间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "平均情况是冒泡排序的复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的平均情况复杂度特性明确",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析冒泡排序时，其平均情况复杂度可确定",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "状态转移的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移算法的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的复杂度以Θ记号衡量",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "基数排序具有O(1)的空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是基数排序的空间复杂度。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的空间复杂度属于O(1)。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的复杂度表现为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于KMP算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序在最好情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下直接插入排序的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序算法最好情况的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是分析Dijkstra算法复杂度的手段",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "状态转移的算法复杂度以Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号用于表示状态转移的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移算法的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "选择排序的时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性可由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "归并排序的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的复杂度属性较为明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度属性可分析确定",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "分支限界的最坏时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述分支限界的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的空间复杂度以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "基数排序算法拥有最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法具备最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法呈现最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "多路归并的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的算法复杂度属性",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "势能方法用于分析最小生成树的复杂度。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "分析最小生成树的复杂度时需借助势能方法。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度与势能方法密切相关。",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于拓扑排序的复杂度评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度由摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的算法复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "冒泡排序的平均情况时间复杂度是其重要复杂度属性",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的时间复杂度具有特定属性",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "普里姆算法的复杂度属性类似于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法与会计方法的复杂度属性相关联",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度参考普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "直接插入排序最好情况下的复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度属性为线性级",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "采用直接插入排序时，最好情况的复杂度为线性",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "插入排序的时间复杂度用Ω记号表示。",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度属性以Ω记号表示。",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号表示插入排序的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "快速排序具有空间复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "广度优先搜索在最坏情况下的复杂度为线性时间",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的算法复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索算法的最坏情况复杂度为线性复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "堆排序的平均情况复杂度是其核心属性之一。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均时间复杂度反映平均情况。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序在平均情况下的时间复杂度是关键参数。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "广度优先搜索的最坏情况时间复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下广度优先搜索的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索在最坏情况下的复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "冒泡排序的时间复杂度为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的空间复杂度等于平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的平均复杂度属性是平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "单源最短路径的计算复杂度为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分析单源最短路径算法时，需考虑其时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径问题的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在算法分析中，线性查找的复杂度被定义为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "回溯法的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "采用回溯法时，其复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度为线性时间。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，基数排序的复杂度表现为线性级。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法的最好情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索最好情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的复杂度较低。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度为已知。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的时间复杂度达到O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的复杂度可以用大O记号来表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性通过大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度属性简单。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况下的复杂度较低。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序最好情况的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "插值查找算法的复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找算法存在会计方法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的关键复杂度指标",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的平均查找长度反映其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "KMP算法具有会计方法的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法相关。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法的复杂度属性相似。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度属性需明确。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析克鲁斯卡尔算法时，其最坏情况复杂度属性被确定。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，克鲁斯卡尔算法的复杂度属性需考量。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "穷举法的算法复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定穷举法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度属性由摊还分析进行分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有复杂度属性O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度是线性时间O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "状态转移的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号刻画了状态转移的复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的时间复杂度被表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "快速排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序以渐近复杂度描述其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度是快速排序的核心复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "回溯法的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "采用回溯法时，其复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "贪心策略的算法复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析贪心策略时常用Ω记号描述其复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略算法的复杂度下界可用Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析可用于评估希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的复杂度分析采用摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "回溯法的时间复杂度通常为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "某些问题中，回溯法的复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法在最坏情形下的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估广度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的复杂度分析依赖于摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插入排序算法的平均时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序在最坏情况下的时间复杂度用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度下界可由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分块查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序最好情况下的复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度属性由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述插入排序的最坏时间复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "动态规划的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度是其核心复杂度属性",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的复杂度体现为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度为常数空间。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度表现为常数级。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度属于常数空间类型。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "哈希查找的平均时间复杂度优于势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度属性高于哈希查找",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找与势能方法的复杂度存在差异",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "分支限界算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法具有复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "计数排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是计数排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的复杂度分析依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于计算哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找的复杂度属性由势能方法定义",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "插值查找的时间复杂度对应会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的空间复杂度关联会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的平均复杂度等于会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的时间复杂度为线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况时间复杂度属于线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "平均情况是冒泡排序的复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的平均情况复杂度特性明确",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析冒泡排序时，其平均情况复杂度可确定",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "选择排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "弗洛伊德算法在最好情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法的最好情况复杂度是关键指标。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度特征。",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "单源最短路径的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "Bellman-Ford算法的时间复杂度通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "一般而言，分支限界算法的复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的时间复杂度常被记为大O记号",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法具有复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序处理时，复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度为常数级。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找的重要属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找具有空间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "动态规划的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "分支限界的算法复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述分支限界的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的复杂度通常以大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "一般而言，分支限界算法的复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的时间复杂度常被记为大O记号",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分块查找的时间复杂度可以用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了分块查找的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插值查找的复杂度为最坏情况",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "进行插值查找时，其最坏情况复杂度为",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "在最坏情况下，插值查找的复杂度为",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "直接插入排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的时间复杂度达到O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序具有时间复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度为线性时间。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，基数排序的复杂度表现为线性级。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法的最好情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的时间复杂度等于O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "深度优先搜索的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索算法的复杂度用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于衡量深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "冒泡排序的复杂度与平均查找长度相关联",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的算法复杂度体现平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的计算复杂度涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分支限界的算法复杂度常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述分支限界的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度属性可通过大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分块查找的时间复杂度由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分块查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的算法复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "研究分块查找的复杂度属性，其结果可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的时间复杂度被标记为Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "穷举法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度由摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索算法的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "插入排序的时间复杂度为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度可用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的空间复杂度以Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "归并排序最好情况下的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序算法在最好情况下的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "分治算法的时间复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的空间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "外部排序的复杂度属性体现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度对应平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度指标",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分治的算法复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用分治策略时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序在一般情况下的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的算法复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "冒泡排序的复杂度与平均查找长度相关联",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的算法复杂度体现平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的计算复杂度涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "深度优先搜索的时间复杂度通常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度属性通过大O记号来量化",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度可以用大O记号来表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性通过大O记号来刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "KMP算法的复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是KMP算法的复杂度表现",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "记忆化搜索的算法复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "在进行记忆化搜索时，其复杂度表现为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "对于记忆化搜索，其时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "直接插入排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序算法具有时间复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "插值查找的时间复杂度对应会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的空间复杂度关联会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的平均复杂度等于会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "基数排序的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序具有复杂度O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是基数排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的算法复杂度需借助摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序在平均情况下的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序在最好情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有时间复杂度O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "状态转移的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的空间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找算法的复杂度属性可通过摊还分析得出。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析线性查找算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找算法的复杂度需借助摊还分析来确定。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "插入排序的时间复杂度是Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的最坏时间复杂度为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号表示插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "二路归并算法在最好情况下的时间复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，二路归并算法的时间复杂度属性已知",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "希尔排序算法在平均情况下的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助评估希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的摊还复杂度可借助摊还分析来计算",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "普里姆算法的计算复杂度与会计方法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性高于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度与会计方法的复杂度不同。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序处理时，复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "外部排序具有平均查找长度的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序算法的复杂度属性涉及平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的时间复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "动态规划的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "使用贪心策略处理，最好情况下的复杂度为",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略在最好情况的复杂度表现为",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，贪心策略的复杂度属性是",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度是关键属性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索算法的最好情况复杂度需分析",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下深度优先搜索的复杂度特性明确",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度高于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度低于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "折半查找的时间复杂度与聚合分析的复杂度相近",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的空间复杂度高于聚合分析的复杂度",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的复杂度属性为折半查找提供参考",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "穷举法处理会计方法的复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "使用穷举法处理会计方法，其复杂度关联会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法处理中，穷举法的复杂度属于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度被表示为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "摊还分析用于分析Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插入排序的时间复杂度可表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "在分析插入排序时，其复杂度属性对应Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Θ记号来描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的时间复杂度需分析",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法最坏情况下的空间复杂度是关键",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的时间复杂度通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序具有渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "普里姆算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是分析Dijkstra算法复杂度的手段",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法在平均情况下的复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "一般而言，分支限界算法的复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的时间复杂度常被记为大O记号",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分治算法的时间复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的空间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插值查找的复杂度关联会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法复杂度影响插值查找复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找复杂度参考会计方法复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "分治算法具有复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的计算复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度分析常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "状态转移算法的复杂度属性由Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的算法复杂度可用Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移算法的复杂度以Θ记号衡量",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "基数排序的最好情况复杂度属性为线性时间。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，基数排序的时间复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的时间复杂度表现为线性。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "折半查找的时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的空间复杂度与聚合分析相近",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "分治算法具有复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的计算复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度通常用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号可用于表示分支限界的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析分支限界时，其复杂度常以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "多路归并的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于多路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的计算复杂度与会计方法存在差异",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径算法的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "计算单源最短路径时，复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的算法复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "多路归并算法的复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的处理复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "在算法分析中，多路归并的复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "研究拓扑排序的复杂度，发现其为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "普里姆算法的最坏复杂度以大O记号描述",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "折半查找与聚合分析的复杂度属性不同。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的复杂度区别于聚合分析的复杂度。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找和聚合分析的复杂度存在差异。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "贪心策略的最好情况复杂度是其核心属性",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略在最好情况下的复杂度表现为最佳",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略的最好情况复杂度属性为最优",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "最小生成树的复杂度属性对应会计方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "使用最小生成树处理会计方法，其复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性体现在最小生成树中",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法的复杂度属性为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的复杂度属性是会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法的复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找在最坏情况下的复杂度属性已知。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，插值查找的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找的最坏情况复杂度属性需确定。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "KMP算法的复杂度与会计方法的复杂度存在差异。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度可类比KMP算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法和会计方法的复杂度属性相关联。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "冒泡排序的平均情况时间复杂度是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的时间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是平均情况",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是记忆化搜索的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "单源最短路径的计算复杂度为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分析单源最短路径算法时，需考虑其时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径问题的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "选择排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度下界由Ω记号定义",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "直接插入排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序在一般情况下的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的算法复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "分块查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分块查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "多路归并的复杂度属性为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的算法复杂度是会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并处理的复杂度属性对应会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "折半查找的空间复杂度通常为常数级（O(1)）",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找算法的关键复杂度属性",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找算法在操作中的空间复杂度表现为O(1)",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "穷举法在最坏情况下的复杂度由摊还分析给出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是外部排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "折半查找与聚合分析的复杂度属性不同。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的复杂度区别于聚合分析的复杂度。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找和聚合分析的复杂度存在差异。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "穷举法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度由摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "最小生成树的算法复杂度属性与会计方法的不同",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性影响最小生成树的选择",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的空间复杂度和会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "插入排序的复杂度用Ω记号来表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度下界由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于刻画插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分析计数排序的算法复杂度，结果为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "在算法复杂度分析中，计数排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "最小生成树的复杂度达到势能方法的级别",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度优于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度受势能方法影响",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析普里姆算法复杂度时，常使用大O记号。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性可通过大O记号描述。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "动态规划的时间复杂度通常为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的典型复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的复杂度一般为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的空间复杂度用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示克鲁斯卡尔算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "最小生成树的复杂度分析涉及势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法可用于评估最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树算法的复杂度由势能方法确定",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的算法复杂度分析依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于计算最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度通过势能方法评估",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "线性查找的算法复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "对于线性查找，其复杂度被定义为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性呈现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "分治算法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "最小生成树和会计方法的复杂度属性相近",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度可参考最小生成树模型",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树算法具有会计方法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "直接插入排序最好情况下的复杂度为线性。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序在最好情况时的复杂度是线性级。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，直接插入排序的复杂度为线性时间。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "回溯法的时间复杂度通常为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "某些问题中，回溯法的复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法在最坏情形下的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "分支限界算法的复杂度常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界的空间复杂度通常以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述分支限界算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "堆排序的平均情况复杂度属性是其算法的重要特征。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序在平均情况下的复杂度属性可通过分析得出。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "分析堆排序的平均情况时，其复杂度属性被明确。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的算法复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序具有渐近复杂度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "多路归并的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于多路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的计算复杂度与会计方法存在差异",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "状态转移的处理复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "通过状态转移实现时，复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移操作的复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "使用克鲁斯卡尔算法处理，其复杂度为最坏情况",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的复杂度表现为",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，克鲁斯卡尔算法的复杂度是",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "堆排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度为线性时间。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，基数排序的复杂度表现为线性级。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法的最好情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用回溯法时，其复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法处理问题的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的时间复杂度等于O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度常用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的空间复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "拓扑排序的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定拓扑排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的复杂度通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况时间复杂度是其复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，克鲁斯卡尔算法的时间复杂度属性为关键指标。",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "二路归并最好情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并算法最好情况的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "哈希查找的算法复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找操作的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在哈希查找中，其复杂度表现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是记忆化搜索的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "插入排序最好情况下的复杂度是Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度属性由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述插入排序的最坏时间复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "使用基数排序处理时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "当基数排序处于最好情况时，其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序具有最好情况复杂度属性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "穷举法处理会计方法的复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "使用穷举法处理会计方法，其复杂度关联会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法处理中，穷举法的复杂度属于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "计算中采用的迪杰斯特拉算法，复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "弗洛伊德算法的复杂度是最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "在最好情况下，弗洛伊德算法的复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "选择排序的时间复杂度用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性可由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "动态规划的时间复杂度是其关键算法属性。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "时间复杂度是动态规划的核心复杂度特征。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的时间复杂度需具体分析。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "最小生成树的时间复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性类似于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的空间复杂度属性涉及会计方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "深度优先搜索算法在最好情况下的复杂度为线性。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索算法的复杂度为线性。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索算法的最好情况复杂度为线性。",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序的平均情况复杂度类型是空间复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的复杂度属性为时间复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属于基本属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "哈希查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序具有复杂度属性O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的复杂度是线性时间O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "快速排序的空间复杂度通常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序算法的空间复杂度是其性能分析的重要部分",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度主要源于递归调用栈的消耗",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "广度优先搜索的最坏情况时间复杂度是关键属性",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索算法在最坏情况下的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的复杂度属性可分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最小生成树的复杂度属性关联到会计方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法分析中涉及最小生成树的复杂度",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树的复杂度属性在会计方法中被考量",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "动态规划的算法复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索具有O(n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "选择排序的时间复杂度可表示为Ω记号",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "选择排序的复杂度属性通过Ω记号来体现",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于表示选择排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "单源最短路径算法具有O(1)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是单源最短路径算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "外部排序具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度通常是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的时间复杂度为线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况时间复杂度属于线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "Bellman-Ford算法在平均情况下的复杂度为多项式时间。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，Bellman-Ford算法的复杂度属于线性级。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法平均情况下的复杂度为O(nm)。",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "拓扑排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的最坏时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的算法复杂度体现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找的复杂度属性是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "普里姆算法的复杂度类似会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与普里姆算法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的复杂度表现为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "堆排序的时间复杂度用渐近复杂度表示",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度分析涉及渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的渐近复杂度描述其时间特性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "外部排序的平均查找长度体现其复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度由平均查找长度表示",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "选择排序的算法复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是分析选择排序复杂度的重要方法",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的复杂度分析常采用摊还分析手段",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "直接插入排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的时间复杂度达到O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "最小生成树的时间复杂度低于势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的复杂度高于最小生成树",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树与势能方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "单源最短路径算法的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "计算单源最短路径时，复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的算法复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "快速排序的算法复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序采用渐近复杂度作为其复杂度度量",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "深度优先搜索的时间复杂度通常用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的复杂度分析常采用大O记号",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示深度优先搜索的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "分治算法的复杂度分析常涉及Ω记号",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治算法的时间复杂度下界用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分治算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性由摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分治算法的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是分治算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序具有平均查找长度相关的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "分析归并排序时，其空间复杂度表现明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序具有空间复杂度这一算法复杂度特征",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度通常为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划的典型复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划算法的复杂度一般为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "多路归并的时间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的空间复杂度为会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的复杂度属性类似会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "希尔排序算法在平均情况下的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助评估希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的摊还复杂度可借助摊还分析来计算",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有O(log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "插值查找算法的复杂度属性类似于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与插值查找算法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度等于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "快速排序的最坏时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序的复杂度分析基于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "线性查找的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "对线性查找进行复杂度分析时使用摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "二路归并的最坏时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的时间复杂度可用Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号刻画了二路归并的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析拓扑排序的复杂度，摊还分析是常用方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的算法复杂度需通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定拓扑排序复杂度的关键方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "状态转移的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移具有O(1)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "二路归并最好情况下的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并算法最好情况的复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法影响KMP算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法处理会计方法时复杂度属性需考量",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "冒泡排序的平均情况计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的计算复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "冒泡排序在平均情况的计算复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "单源最短路径算法的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "计算单源最短路径时，复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的算法复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "拓扑排序的时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度描述了拓扑排序的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "线性查找的时间复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度平均为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "插值查找算法的复杂度属性类似于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与插值查找算法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的算法复杂度等于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "深度优先搜索的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索算法的复杂度用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于衡量深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的复杂度属性体现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度对应平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度指标",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的算法复杂度需借助摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度可用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法通常以大O记号表示其复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度以平均查找长度表示",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "穷举法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估穷举法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "穷举法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "堆排序算法在平均情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序算法在最好情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序算法在一般情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "直接插入排序的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "外部排序的平均查找长度体现其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是外部排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序算法的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "最小生成树的复杂度依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度关联势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度由势能方法确定",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "记忆化搜索的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度通常是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的复杂度表现为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法处理时复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "普里姆算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的时间复杂度为大O记号",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "KMP算法的复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是KMP算法的复杂度表现",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "折半查找的平均时间复杂度低于聚合分析",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的空间复杂度高于折半查找",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找以对数时间复杂度著称，聚合分析以线性复杂度为主",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "状态转移的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的空间复杂度由Θ记号刻画",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的复杂度属性对应于Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "桶排序的时间复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "经评估，桶排序的复杂度属于O(n)类型",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "对桶排序的复杂度分析显示其为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "弗洛伊德算法的复杂度是最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "弗洛伊德算法具有最好情况下的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "在最好情况下，弗洛伊德算法的复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "最好情况"
    },
    {
      "sentence": "希尔排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "拓扑排序的时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度描述了拓扑排序的复杂度特性",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分块查找的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分块查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "克鲁斯卡尔算法在最坏情况下的时间复杂度需分析",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法最坏情况下的空间复杂度是关键",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "拓扑排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的最坏时间复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "KMP算法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法具有O(n²)的复杂度",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "KMP算法的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "堆排序的算法复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序具有渐近复杂度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了克鲁斯卡尔算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "单源最短路径的时间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径算法具有时间复杂度这一复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度体现了算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "二路归并具有最好情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度属性存在",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并的最好情况复杂度属性确定",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度可通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析Dijkstra算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性由摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并的复杂度属性是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "归并排序在最好情况下的时间复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的时间复杂度为线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况时间复杂度属于线性对数级",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "分支限界的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分析分支限界算法，其复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "线性查找的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度属性可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "二路归并的时间复杂度由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述二路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的复杂度属性可用Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "在分析穷举法时，其复杂度属性关联会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法的复杂度相关",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度类似于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "希尔排序的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定希尔排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是希尔排序复杂度的关键分析手段",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "弗洛伊德算法的复杂度通常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用来描述弗洛伊德算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的复杂度属性可通过大O记号来量化",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序算法的复杂度表现为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "桶排序的复杂度表现为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "分析桶排序的复杂度，其值为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是桶排序的复杂度指标",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "动态规划的时间复杂度是关键属性",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的算法复杂度以时间复杂度为主",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度体现其计算效率",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法属性之一。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序具有空间复杂度这一算法属性。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序的空间复杂度体现算法复杂度特征。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "基数排序的最好情况复杂度属性为线性",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度为最优",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析基数排序时，其最好情况复杂度为最低",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "穷举法的时间复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的空间复杂度低于穷举法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的平均复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径的时间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径算法具有时间复杂度这一复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度体现了算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度需根据具体问题分析",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划算法的时间复杂度是其关键性能指标",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "时间复杂度是动态规划的重要复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "O(n)是分治算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度属于O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的复杂度可通过势能方法计算",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于分析哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找的复杂度属性与势能方法相关",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "希尔排序算法在平均情况下的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析帮助评估希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的摊还复杂度可借助摊还分析来计算",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "堆排序的算法复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序具有渐近复杂度作为其复杂度属性",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "基数排序最好情况下的复杂度属性明确",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度属性可确定",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下基数排序的复杂度属性已知",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略的算法复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述贪心策略的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "贪心策略的算法复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "Ω记号"
    },
    {
      "sentence": "基数排序算法拥有最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法具备最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序算法呈现最好情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "状态转移的算法复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移算法具备O(1)复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "状态转移的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "O(1)"
    },
    {
      "sentence": "回溯法的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "采用回溯法时，其复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "基数排序最好情况的时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下基数排序的时间复杂度为常数",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度是固定值",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "克鲁斯卡尔算法具有最坏情况的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的最坏情况时间复杂度是其核心属性",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况的时间复杂度是克鲁斯卡尔算法的重要属性",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分治算法的平均复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的最坏时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "穷举法的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法的算法复杂度低于会计方法",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法与会计方法的算法复杂度相当",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度属性是较低的",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，深度优先搜索的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况的复杂度属性较低",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度以大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的空间复杂度用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于表示克鲁斯卡尔算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "穷举法的复杂度属性与会计方法相关联",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性可通过穷举法体现",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "穷举法和会计方法的复杂度属性具有可比性",
      "relation": "hasComplexity",
      "entity1": "穷举法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度类似会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度与普里姆算法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的复杂度属性关联会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "二路归并算法最好情况下的复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度为线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并在最好情况下的复杂度属性是线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的最好情况复杂度属性是其算法特性之一",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下归并排序的复杂度属性较为明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序在最好情况下的复杂度属性可分析确定",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "回溯法的算法复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "采用回溯法时，其复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法的时间复杂度属性为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "哈希查找的复杂度属性关联到势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法与哈希查找的复杂度存在关联",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "分析哈希查找的复杂度时，需考虑势能方法的影响",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性由摊还分析描述",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "深度优先搜索的时间复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索的空间复杂度以大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用来描述深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度分析需考虑平均查找长度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "外部排序的复杂度与平均查找长度相关联",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "插值查找的时间复杂度与会计方法的复杂度不同",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的空间复杂度属性类似会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找的平均时间复杂度和会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "Bellman-Ford算法的时间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的空间复杂度为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属性为平均情况",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "普里姆算法的时间复杂度高于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的时间复杂度与会计方法的复杂度相当。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度低于会计方法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "哈希查找的算法复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找操作的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "在哈希查找中，其复杂度表现为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序具有平均查找长度相关的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "直接插入排序的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序的复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "直接插入排序具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "快速排序的空间复杂度通常为O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序具有空间复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "快速排序的空间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "摊还分析用于确定广度优先搜索的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "广度优先搜索的算法复杂度分析常借助摊还分析",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可明确广度优先搜索的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找在平均情况下的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找算法的复杂度属性为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "克鲁斯卡尔算法的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析克鲁斯卡尔算法的复杂度常使用大O记号",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "克鲁斯卡尔算法的时间复杂度通过大O记号描述",
      "relation": "hasComplexity",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "外部排序的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序算法的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的关键复杂度指标",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的平均查找长度反映其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "插入排序的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度可以用Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "广度优先搜索的最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "分析广度优先搜索，最坏情况复杂度是线性的。",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "冒泡排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是冒泡排序的关键复杂度指标",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "冒泡排序的平均查找长度反映其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "折半查找的空间复杂度为常数空间。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度表现为常数级。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找的空间复杂度属于常数空间类型。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "插入排序的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度可以用Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法具有O(1)的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "弗洛伊德算法的复杂度分析使用大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述弗洛伊德算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的时间复杂度可表示为大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的计算复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号描述了弗洛伊德算法的计算复杂度",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "弗洛伊德算法的计算复杂度属性为大O记号",
      "relation": "hasComplexity",
      "entity1": "弗洛伊德算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "多路归并的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度低于多路归并的复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并的计算复杂度与会计方法存在差异",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "单源最短路径算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径问题的算法复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "单源最短路径的算法复杂度表示为O(1)",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "O(1)"
    },
    {
      "sentence": "广度优先搜索在最坏情况下的复杂度为线性时间",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "最坏情况下，广度优先搜索的算法复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "广度优先搜索算法的最坏情况复杂度为线性复杂度",
      "relation": "hasComplexity",
      "entity1": "广度优先搜索",
      "entity2": "最坏情况"
    },
    {
      "sentence": "线性查找算法的复杂度属性可通过摊还分析得出。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析线性查找算法的复杂度。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "线性查找算法的复杂度需借助摊还分析来确定。",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "外部排序的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "外部排序具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "外部排序",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "线性查找的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "对线性查找进行复杂度分析时使用摊还分析",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估线性查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "摊还分析"
    },
    {
      "sentence": "普里姆算法的复杂度与会计方法的复杂度相当",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的时间复杂度高于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法的空间复杂度低于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "状态转移的算法复杂度以Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号用于表示状态转移的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移算法的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "计算中采用的迪杰斯特拉算法，复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(n log n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于分析Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性由摊还分析描述",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "分支限界的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "分支限界的平均复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "哈希查找的时间复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)对应哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找具有O(log n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "堆排序的平均情况时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下堆排序的复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均情况复杂度表现为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "插值查找算法的复杂度属性为最坏情况",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找算法具有最坏情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "插值查找算法的时间复杂度包含最坏情况",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "最坏情况"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度分析依赖摊还分析",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Bellman-Ford算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Bellman-Ford算法的复杂度属性通过摊还分析评估",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "插入排序的时间复杂度可表示为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "在分析插入排序时，其复杂度属性对应Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Θ记号来描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "状态转移的时间复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的空间复杂度由Θ记号刻画",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的复杂度属性对应于Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性类似于会计方法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "普里姆算法与会计方法的复杂度属性相关联",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度参考普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法影响KMP算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法处理会计方法时复杂度属性需考量",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树算法的时间复杂度与会计方法相关",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性对应最小生成树算法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "最小生成树算法的空间复杂度为会计方法的复杂度类型",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "会计方法"
    },
    {
      "sentence": "Dijkstra算法的复杂度分析依赖于摊还分析",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定Dijkstra算法复杂度的方法",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "通过摊还分析可明确Dijkstra算法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "直接插入排序具有最好情况下的时间复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "直接插入排序的最好情况复杂度属于时间复杂度类型。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下，直接插入排序的算法复杂度为时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "直接插入排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "分析归并排序时，其空间复杂度表现明确",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序具有空间复杂度这一算法复杂度特征",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性表现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "研究表明堆排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "算法分析中，堆排序的复杂度被定义为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "多路归并的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "多路归并算法的复杂度是O(n²)",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是多路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "O(n²)"
    },
    {
      "sentence": "堆排序的时间复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的空间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序的复杂度属性体现为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "分治的时间复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治算法的空间复杂度由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分治的复杂度属性可用Ω记号体现",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度明确",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法具有平均情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "Bellman-Ford算法的平均情况复杂度属于基本属性",
      "relation": "hasComplexity",
      "entity1": "Bellman-Ford算法",
      "entity2": "平均情况"
    },
    {
      "sentence": "多路归并算法具有会计方法的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法具有会计方法的计算复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "多路归并算法具有会计方法的整体复杂度",
      "relation": "hasComplexity",
      "entity1": "多路归并",
      "entity2": "会计方法"
    },
    {
      "sentence": "计数排序的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序具有空间复杂度O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(1)是计数排序的空间复杂度",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分析发现计数排序的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索具有O(n log n)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "记忆化搜索的复杂度属性为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "插入排序的时间复杂度为Ω记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度以Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述插入排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析拓扑排序的复杂度，摊还分析是常用方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "拓扑排序的算法复杂度需通过摊还分析来评估",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析是确定拓扑排序复杂度的关键方法",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "桶排序在平均情况下的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度通常为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "迪杰斯特拉算法的时间复杂度为O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度属性是O(n log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "O(n log n)是迪杰斯特拉算法的复杂度表现",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(n log n)"
    },
    {
      "sentence": "快速排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "快速排序以渐近复杂度描述其复杂度特征",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "渐近复杂度是快速排序的核心复杂度属性",
      "relation": "hasComplexity",
      "entity1": "快速排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "基数排序最好情况的时间复杂度是线性的",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下基数排序的时间复杂度为常数",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "基数排序在最好情况下的复杂度是固定值",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "最好情况"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "基数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "基数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分析基数排序的复杂度，结果为O(1)",
      "relation": "hasComplexity",
      "entity1": "基数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "线性查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是线性查找的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "线性查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "线性查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "状态转移的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "分析状态转移，其复杂度为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的复杂度属性对应Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "归并排序的空间复杂度是其算法复杂度的一部分。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "归并排序具有空间复杂度这一属性。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是归并排序的重要复杂度指标。",
      "relation": "hasComplexity",
      "entity1": "归并排序",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析深度优先搜索的最好情况复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索最好情况的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "贪心策略最好情况下的算法复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "分析贪心策略时，其最好情况的复杂度属性确定。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "研究贪心策略的最好情况，复杂度属性明确。",
      "relation": "hasComplexity",
      "entity1": "贪心策略",
      "entity2": "最好情况"
    },
    {
      "sentence": "哈希查找的复杂度分析依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法用于计算哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找的复杂度属性由势能方法定义",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "计数排序的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "计数排序的复杂度属性是O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分析发现计数排序的复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(1)"
    },
    {
      "sentence": "分支限界算法的复杂度通常用大O记号描述",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号可用于表示分支限界的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分析分支限界时，其复杂度常以大O记号衡量",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "哈希查找的时间复杂度高于势能方法",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "势能方法的空间复杂度与哈希查找相当",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "哈希查找和势能方法的复杂度属性不同",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "势能方法"
    },
    {
      "sentence": "分块查找的时间复杂度由Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号用于描述分块查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分块查找的复杂度属性对应Ω记号",
      "relation": "hasComplexity",
      "entity1": "分块查找",
      "entity2": "Ω记号"
    },
    {
      "sentence": "记忆化搜索算法的复杂度属性为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "记忆化搜索的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "采用记忆化搜索时，其复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "记忆化搜索",
      "entity2": "O(n)"
    },
    {
      "sentence": "堆排序算法在平均情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序算法在最好情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "堆排序算法在一般情况下的复杂度为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "动态规划通常具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是动态规划的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "O(n)"
    },
    {
      "sentence": "哈希查找的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找具有复杂度O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "桶排序的复杂度属性包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序算法的复杂度属性为平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "平均查找长度是桶排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法的复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "回溯法具有O(n)的复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n)"
    },
    {
      "sentence": "普里姆算法的时间复杂度可用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述普里姆算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "普里姆算法的复杂度属性由大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "普里姆算法",
      "entity2": "大O记号"
    },
    {
      "sentence": "插入排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了插入排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度属性由Ω记号刻画",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分支限界的算法复杂度常用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号常用于描述分支限界的复杂度",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "分支限界算法的复杂度属性可通过大O记号刻画",
      "relation": "hasComplexity",
      "entity1": "分支限界",
      "entity2": "大O记号"
    },
    {
      "sentence": "拓扑排序的复杂度属性为渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的算法复杂度属于渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "拓扑排序的时间复杂度是渐近复杂度",
      "relation": "hasComplexity",
      "entity1": "拓扑排序",
      "entity2": "渐近复杂度"
    },
    {
      "sentence": "迪杰斯特拉算法的复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "迪杰斯特拉算法具有O(log n)的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是迪杰斯特拉算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "迪杰斯特拉算法",
      "entity2": "O(log n)"
    },
    {
      "sentence": "插值查找的算法复杂度高于会计方法",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "会计方法的复杂度属性低于插值查找",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "插值查找与会计方法的复杂度属性相近",
      "relation": "hasComplexity",
      "entity1": "插值查找",
      "entity2": "会计方法"
    },
    {
      "sentence": "Dijkstra算法的时间复杂度为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的空间复杂度是O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性为O(1)",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "O(1)"
    },
    {
      "sentence": "O(n)是分治算法的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法具有O(n)的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "分治算法的时间复杂度属于O(n)",
      "relation": "hasComplexity",
      "entity1": "分治",
      "entity2": "O(n)"
    },
    {
      "sentence": "KMP算法具有会计方法的时间复杂度。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的空间复杂度与会计方法相关。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "KMP算法的复杂度属性与会计方法的复杂度属性相似。",
      "relation": "hasComplexity",
      "entity1": "KMP算法",
      "entity2": "会计方法"
    },
    {
      "sentence": "动态规划的时间复杂度是其核心复杂度属性。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "分析动态规划算法时，时间复杂度是关键考量指标。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "动态规划的时间复杂度是衡量其效率的重要属性。",
      "relation": "hasComplexity",
      "entity1": "动态规划",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "二路归并算法最好情况下的复杂度是线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "最好情况下二路归并的复杂度为线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "二路归并在最好情况下的复杂度属性是线性对数级",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "研究二路归并时，发现其复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "考察二路归并的最好情况复杂度，结果为最好情况",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "观察二路归并的最好情况复杂度属性，发现其为最好情况",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "最好情况"
    },
    {
      "sentence": "桶排序的时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序具有时间复杂度O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "桶排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "分析计数排序的算法复杂度，结果为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "计数排序的时间复杂度属性是O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "在算法复杂度分析中，计数排序的复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "计数排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "状态转移的复杂度属性为Θ记号",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移算法的复杂度用Θ记号表示",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "状态转移的复杂度以Θ记号衡量",
      "relation": "hasComplexity",
      "entity1": "状态转移",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的时间复杂度可用Θ记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "Θ记号用于表示插入排序的复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "分析插入排序的复杂度时，其结果为Θ记号",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Θ记号"
    },
    {
      "sentence": "插入排序的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "分析插入排序的复杂度属性，其下界由Ω记号描述",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "插入排序的复杂度分析中，Ω记号用于表示其复杂度",
      "relation": "hasComplexity",
      "entity1": "插入排序",
      "entity2": "Ω记号"
    },
    {
      "sentence": "深度优先搜索的复杂度用大O记号表示",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "大O记号用于描述深度优先搜索的复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "深度优先搜索通常以大O记号表示其复杂度",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "大O记号"
    },
    {
      "sentence": "选择排序的复杂度分析采用摊还分析方法",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于确定选择排序的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "选择排序的复杂度可通过摊还分析得出",
      "relation": "hasComplexity",
      "entity1": "选择排序",
      "entity2": "摊还分析"
    },
    {
      "sentence": "希尔排序的时间复杂度为O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "希尔排序的最坏时间复杂度是O(n)",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "O(n)是希尔排序的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "希尔排序",
      "entity2": "O(n)"
    },
    {
      "sentence": "折半查找的空间复杂度是其算法复杂度的重要属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "折半查找具有空间复杂度这一算法属性。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "空间复杂度是折半查找的算法复杂度组成部分。",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "空间复杂度"
    },
    {
      "sentence": "二路归并的时间复杂度属性由Ω记号体现",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "Ω记号描述了二路归并的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "二路归并的时间复杂度可用Ω记号表示",
      "relation": "hasComplexity",
      "entity1": "二路归并",
      "entity2": "Ω记号"
    },
    {
      "sentence": "哈希查找的时间复杂度为O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "哈希查找算法的复杂度是O(log n)",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "O(log n)是哈希查找的时间复杂度",
      "relation": "hasComplexity",
      "entity1": "哈希查找",
      "entity2": "O(log n)"
    },
    {
      "sentence": "单源最短路径的时间复杂度是其算法复杂度的重要属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径算法具有时间复杂度这一复杂度属性",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "单源最短路径的时间复杂度体现了算法的复杂度特征",
      "relation": "hasComplexity",
      "entity1": "单源最短路径",
      "entity2": "时间复杂度"
    },
    {
      "sentence": "深度优先搜索的时间复杂度为最好情况",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索的最好情况复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "深度优先搜索在最好情况下的复杂度为",
      "relation": "hasComplexity",
      "entity1": "深度优先搜索",
      "entity2": "最好情况"
    },
    {
      "sentence": "Dijkstra算法的复杂度通过摊还分析确定",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "摊还分析用于评估Dijkstra算法的复杂度",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "Dijkstra算法的复杂度属性由摊还分析描述",
      "relation": "hasComplexity",
      "entity1": "Dijkstra算法",
      "entity2": "摊还分析"
    },
    {
      "sentence": "最小生成树的复杂度依赖势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度关联势能方法",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "最小生成树的复杂度由势能方法确定",
      "relation": "hasComplexity",
      "entity1": "最小生成树",
      "entity2": "势能方法"
    },
    {
      "sentence": "回溯法的时间复杂度为O(n²)",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "回溯法具有O(n²)的算法复杂度",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "O(n²)是回溯法的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "回溯法",
      "entity2": "O(n²)"
    },
    {
      "sentence": "折半查找的时间复杂度与聚合分析的复杂度相近",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "折半查找的空间复杂度高于聚合分析的复杂度",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "聚合分析的复杂度属性为折半查找提供参考",
      "relation": "hasComplexity",
      "entity1": "折半查找",
      "entity2": "聚合分析"
    },
    {
      "sentence": "冒泡排序在平均情况下的复杂度属性是",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "平均情况下，冒泡排序的复杂度为",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "处理数据时，冒泡排序的平均情况复杂度",
      "relation": "hasComplexity",
      "entity1": "冒泡排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均情况复杂度是其核心属性之一。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序的平均时间复杂度反映平均情况。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "堆排序在平均情况下的时间复杂度是关键参数。",
      "relation": "hasComplexity",
      "entity1": "堆排序",
      "entity2": "平均情况"
    },
    {
      "sentence": "桶排序的平均查找长度是其复杂度属性之一",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序具有平均查找长度的复杂度属性",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "桶排序的算法复杂度包含平均查找长度",
      "relation": "hasComplexity",
      "entity1": "桶排序",
      "entity2": "平均查找长度"
    },
    {
      "sentence": "红黑树提供垃圾回收操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收执行",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收实现",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "循环队列支持插入操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "循环队列提供插入功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "插入操作可由循环队列完成",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "队列支持顺序访问操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列提供顺序访问功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器具备合并处理能力",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可执行合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "线性表支持初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表能够进行初始化",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是线性表提供的操作之一",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉堆可执行插入操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "插入"
    },
    {
      "sentence": "二叉堆能实现插入功能",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "插入"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆具备缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是斐波那契堆提供的操作之一",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "B树支持随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树能够实现随机访问",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问可借助B树完成",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "哈希表支持高效的查找操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作是哈希表的核心功能之一",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "哈希表能够快速执行查找操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "链表提供的复制操作是基础功能之一",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "链表支持对其元素进行复制操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "复制链表是链表数据结构提供的典型操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "出栈操作可由线性表完成",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "线性表支持随机访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表能进行随机访问",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表提供随机访问功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "布隆过滤器支持执行旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器提供旋转功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器允许用户进行旋转",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "栈提供引用计数管理功能",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "栈可执行引用计数相关操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "遍历是跳跃表提供的基础功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "跳跃表通过遍历实现数据访问",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉树可提供扩容能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "双端队列提供引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列支持引用计数操作的执行",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列允许用户进行引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机能够执行移动",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机提供移动的功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "二叉树支持入栈操作。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树可实现入栈操作。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树提供入栈功能。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "链表能够实现复制功能",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "链表提供复制这一操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "扩容是B+树提供的功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "B+树具备扩容的操作能力",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "堆为引用计数提供支持",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "链表具备入栈操作能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "入栈"
    },
    {
      "sentence": "字典树提供引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树可实现引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "使用字典树能够完成引用计数",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "在跳跃表中，入队是其提供的操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表支持执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由跳跃表提供",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "堆提供引用计数的操作支持",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆支持引用计数的维护功能",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆实现引用计数的相关操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "跳跃表提供内存分配操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表支持内存分配功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表实现内存分配机制",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "树允许用户执行路径压缩",
      "relation": "provides",
      "entity1": "树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "LRU缓存提供垃圾回收功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存支持执行垃圾回收",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存具备垃圾回收操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "树可完成初始化操作。",
      "relation": "provides",
      "entity1": "树",
      "entity2": "初始化"
    },
    {
      "sentence": "图具备销毁操作的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "图支持销毁操作的执行",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "生成森林提供复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林允许进行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制操作能力",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "二叉堆允许用户进行出栈",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "跳跃表允许执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表能执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "线性表支持随机访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表能进行随机访问",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表提供随机访问功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉堆允许用户进行出栈",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "队列支持顺序访问操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是队列提供的操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列提供顺序访问的功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "在跳跃表中，入队是其提供的操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表支持执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由跳跃表提供",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "大根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆提供内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是大根堆的操作之一",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器可执行旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "旋转是布隆过滤器的操作之一",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "可持久化数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构具备随机访问的能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构可实现随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构具备移动能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构能实现移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "树状数组支持顺序访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组能够进行顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组的核心功能之一是顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "前缀树可执行缩容功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "缩容"
    },
    {
      "sentence": "前缀树具备缩容的能力",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "缩容"
    },
    {
      "sentence": "AC自动机支持入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机可执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机具备入队功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林可执行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "前缀树可执行出队操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "树状数组支持随机访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组能够实现随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组支持随机访问以快速获取数据",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "查找是线性表的基础操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "查找"
    },
    {
      "sentence": "线性表具备查找操作能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "查找"
    },
    {
      "sentence": "平衡二叉树支持销毁操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "平衡二叉树具备销毁功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "平衡二叉树可执行销毁操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "跳跃表可执行复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表支持对数据的遍历操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "跳跃表允许对数据进行遍历",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "跳跃表具备遍历数据的操作能力",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "小根堆具备初始化功能",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "小根堆提供初始化操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "小根堆可执行初始化操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "平衡二叉树为引用计数提供高效查找操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树提供引用计数的插入操作支持",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树能支持引用计数的平衡调整操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "大根堆的主要功能之一是随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆支持随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能够实现随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能够执行合并操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构允许遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "小根堆可执行缩容操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉树允许执行入栈操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉堆可执行入队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "入队"
    },
    {
      "sentence": "入队是二叉堆的操作之一",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "入队"
    },
    {
      "sentence": "链表提供垃圾回收所需的遍历操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表支持垃圾回收的节点删除操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表为垃圾回收提供节点标记操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉树能够执行遍历操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "斐波那契堆支持路径压缩操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩可借助斐波那契堆实现",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "斐波那契堆为路径压缩提供支持",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "AC自动机支持执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机提供入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机可进行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "大根堆的主要功能之一是随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆支持随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能够实现随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "布隆过滤器支持入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "入队是布隆过滤器的操作之一",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "布隆过滤器包含入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机支持移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机能够执行移动",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机提供移动的功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "大根堆提供内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆支持内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆具备内存分配相关操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "出栈是小根堆提供的操作之一",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "出栈"
    },
    {
      "sentence": "小根堆能完成出栈操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "出栈"
    },
    {
      "sentence": "堆提供的操作包含销毁",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是堆的一项基本操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "布隆过滤器支持初始化操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器可执行初始化",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是布隆过滤器提供的操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "二项堆为内存分配提供操作支持",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配操作由二项堆提供",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是二项堆的核心操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表可用于入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "LFU缓存支持出队操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存提供出队功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存可执行出队操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LRU缓存提供随机访问功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存支持随机访问操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存具备随机访问能力",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数的能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机可执行引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "大根堆支持随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆具备随机访问功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存提供垃圾回收功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存支持垃圾回收操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存具备垃圾回收能力",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树可进行复制操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "树状数组提供引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组具备引用计数操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数管理",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持引用计数的维护操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列实现引用计数的追踪功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列提供引用计数的管理机制",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "LFU缓存提供初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存支持初始化功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存可执行初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "大根堆具备随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能进行随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆提供随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "不相交集合提供遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合支持遍历功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合具备遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "单链表支持用户执行入队",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "单链表为用户提供入队",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "LFU缓存提供出栈操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存支持出栈操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "用户可通过LFU缓存执行出栈",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "前缀树可进行缩容操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "缩容"
    },
    {
      "sentence": "树可进行路径压缩操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树具备按秩合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "红黑树提供按秩合并功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "红黑树可执行按秩合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆提供随机访问的功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林支持顺序访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "通过生成森林可实现顺序访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "生成森林提供顺序访问功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林提供复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制能力",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "树状数组支持随机访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组能够实现随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组支持随机访问以快速获取数据",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "跳跃表允许执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表能执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表可执行复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "字典树能够执行插入操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "LRU缓存提供垃圾回收功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存支持垃圾回收操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存具备垃圾回收能力",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉搜索树支持缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是二叉搜索树提供的操作之一",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树可执行缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "入队是图提供的操作之一",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入队"
    },
    {
      "sentence": "树支持执行引用计数操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "引用计数"
    },
    {
      "sentence": "链表能够实现复制功能",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "链表提供复制这一操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是循环链表提供的操作之一",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的操作能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆支持销毁功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是斐波那契堆提供的操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "跳跃表可进行遍历操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "B+树支持初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树具备初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化可通过B+树实现",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉堆可执行入队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "入队"
    },
    {
      "sentence": "借助跳跃表能够完成复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表可用于执行复制任务",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "平衡二叉树支持遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是平衡二叉树的重要操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树具备遍历功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "出队是前缀树提供的基础功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "前缀树可执行出队这一操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "斐波那契堆支持销毁操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆提供销毁功能。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆可执行销毁操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "扩容操作由B+树提供",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "链表可执行旋转操作。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "B树支持随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树能够实现随机访问",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是B树提供的操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "小根堆提供内存分配相关的操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆的操作包含内存分配",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆支持内存分配的实现",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "数组支持执行出栈操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "数组为用户提供出栈操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "用户可通过数组执行出栈",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "二项堆提供随机访问功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机实现引用计数管理",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "链表提供遍历操作支持垃圾回收",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表提供删除操作助力垃圾回收",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表提供节点管理操作辅助垃圾回收",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "在二叉堆中，垃圾回收是其操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆为垃圾回收提供操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆提供的操作包含垃圾回收",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器可执行旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "旋转是布隆过滤器的操作之一",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "树状数组提供引用计数的高效更新操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数的动态维护功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组实现引用计数的快速统计功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "线性表提供顺序访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表允许顺序访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表支持顺序访问功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "单链表支持随机访问操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是单链表提供的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表具备随机访问能力",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉树可提供扩容能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "树状数组提供引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数管理",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组实现引用计数操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "插入是字典树支持的操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是优先队列的基础操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列可执行初始化步骤",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "LRU缓存支持遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是LRU缓存的常用操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "LRU缓存允许对其元素进行遍历",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "入队操作可通过并查集实现",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆提供缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆能够执行缩容",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉树具备遍历的操作能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉树可执行遍历操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "入栈操作可由并查集完成",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "并查集能够执行入栈操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉搜索树提供初始化操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树具备初始化功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是二叉搜索树的基础操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "平衡二叉树提供引用计数管理操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持引用计数维护操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树可执行引用计数相关操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "小根堆提供了缩容功能",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "二项堆支持内存分配操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆可用于实现内存分配",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆为内存分配提供支持",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列提供引用计数功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列实现引用计数机制",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机具备引用计数的操作能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持引用计数操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树提供引用计数管理功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树具备引用计数维护机制",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "在不相交集合中，出栈是其支持的操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合提供出栈这一操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈操作由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存支持出栈操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存能够执行出栈",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存提供出栈功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器支持入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "布隆过滤器允许执行入队",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "布隆过滤器可进行入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "双端队列支持对其元素进行遍历",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "双端队列能够遍历其内部元素",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "用户可借助双端队列执行遍历操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "在链表中，销毁是核心操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "链表支持销毁这一操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "AC自动机支持随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机提供随机访问功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机可执行随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "链表允许执行旋转操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "链表提供旋转操作功能",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "链表具备旋转操作能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "AC自动机提供文本移动时的模式匹配操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "通过AC自动机可实现移动过程中的多模式匹配",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机支持文本移动中的模式查找操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表提供随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表支持随机访问功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表允许随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "前缀树可执行出队操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "LRU缓存提供操作以支持引用计数管理",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数借助LRU缓存提供的操作实现",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "LRU缓存提供的操作可维护引用计数",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "红黑树能提供合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "合并"
    },
    {
      "sentence": "单链表支持随机访问操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表可实现随机访问",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表提供随机访问功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆提供内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是大根堆的操作之一",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆提供随机访问的功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可执行合并",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "合并是布隆过滤器的操作之一",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "队列支持引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列提供引用计数机制",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列实现引用计数功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机提供随机访问功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机可执行随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "红黑树可执行复制操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "复制是红黑树提供的操作之一",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "入队是跳跃表支持的操作之一",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "不相交集合支持出栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是不相交集合提供的操作之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合能够执行出栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "二叉堆可执行入队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "入队"
    },
    {
      "sentence": "可持久化数据结构支持扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是可持久化数据结构的操作之一",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构可提供扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "插入操作可由B+树完成",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "插入"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树具备按秩合并的能力",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树提供按秩合并功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双向链表提供的遍历操作支持垃圾回收标记",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表的删除操作辅助垃圾回收内存清理",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表通过前驱后继指针支持垃圾回收引用计数",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "插入操作可由小根堆完成",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表支持销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是双向链表的操作之一",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "不相交集合支持入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈操作可由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合提供入栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "堆为引用计数提供操作支持。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆支持引用计数的操作执行。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数借助堆完成相关操作。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表可执行入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "旋转操作由并查集提供",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆实现销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆具备销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "布隆过滤器支持出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "借助布隆过滤器可完成出栈",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "利用布隆过滤器能够执行出栈",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "销毁操作由链表提供。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "链表能够执行销毁操作。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "后缀树提供初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树具备初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树允许初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "并查集可执行入队操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列提供初始化功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列能够进行初始化",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "可持久化数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构具备随机访问的能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构可实现随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存提供操作以支持引用计数管理",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数借助LRU缓存提供的操作实现",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "LRU缓存提供的操作可维护引用计数",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "哈希表提供顺序访问操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表支持顺序访问功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表具备顺序访问能力",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组提供引用计数的高效更新操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数的动态维护功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组实现引用计数的快速统计功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "插入操作可通过B树完成",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "插入"
    },
    {
      "sentence": "B树能够执行插入操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "插入"
    },
    {
      "sentence": "并查集具备销毁这一操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "并查集可执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "出队操作可由树来实现",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出队"
    },
    {
      "sentence": "生成森林支持查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林具备查找功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "查找是生成森林提供的操作之一",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "链表能够执行旋转操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "B+树支持初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树提供初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "单链表能够执行入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "查找是线性表提供的操作之一",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "查找"
    },
    {
      "sentence": "数组提供了初始化功能",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "扩容是优先队列的操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "LFU缓存提供初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是LFU缓存的核心操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存支持初始化功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "链表支持垃圾回收机制",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表实现了垃圾回收操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表具备垃圾回收能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "树状数组支持路径压缩操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组提供路径压缩功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组允许用户进行路径压缩",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "不相交集合提供查找操作以识别元素集合",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "查找是不相交集合的核心操作之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合通过查找功能确定元素归属",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "出栈是线性表提供的操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "线性表可执行出栈操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "小根堆具备内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆可执行内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆能进行内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆具备内存分配的能力",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆可用于执行内存分配",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆可执行移动操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "二项堆能完成移动操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "平衡二叉树支持插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "插入是平衡二叉树的标准操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "平衡二叉树能够执行插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "斐波那契堆支持出队操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "出队是斐波那契堆的核心操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "斐波那契堆能够执行出队操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "B+树提供初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是B+树的基础操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树支持初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "斐波那契堆提供入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆支持入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆能执行入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "生成森林为垃圾回收提供操作支持",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "借助生成森林可实现垃圾回收",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林支持垃圾回收的执行",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持数据复制操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "使用红黑树可执行数据复制",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "红黑树可实现数据的复制",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "复制"
    },
    {
      "sentence": "图的数据结构包含插入操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "哈希表支持旋转操作。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表提供旋转功能。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表可执行旋转操作。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "单链表提供引用计数操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表实现引用计数操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表支持引用计数操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列支持顺序访问操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是队列提供的操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列提供顺序访问的功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "大根堆允许用户执行缩容",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "树状数组提供引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数管理",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组实现引用计数操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列提供顺序访问操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列支持顺序访问功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组支持顺序访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组能够进行顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组的核心功能之一是顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "二叉搜索树提供初始化功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树支持初始化操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树具备初始化过程",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉树支持路径压缩操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树具备路径压缩功能",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树允许执行路径压缩操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "斐波那契堆提供入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆支持入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆能执行入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "平衡二叉树支持遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树可用于遍历",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是平衡二叉树的操作之一",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "双端队列支持遍历操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "双端队列可用于遍历数据",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是双端队列提供的操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "AC自动机支持随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机提供随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "借助AC自动机可实现随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环队列支持引用计数的维护操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列实现引用计数的追踪功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列提供引用计数的管理机制",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双向链表支持复制操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "双向链表可通过复制操作创建新链表",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "复制是双向链表的常用操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "B+树提供内存分配功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树支持内存分配相关操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树具备内存分配操作能力",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "不相交集合支持查找操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合具备查找功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "通过不相交集合可执行查找",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "后缀树具备随机访问能力",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树可实现随机访问",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B+树提供内存分配的管理机制",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树支持内存分配的高效操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树具备内存分配的核心功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "双端队列支持随机访问操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列允许随机访问",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列具备随机访问能力",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "红黑树支持路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树提供路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树实现路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "队列提供的操作包含销毁",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "销毁"
    },
    {
      "sentence": "队列的数据结构提供销毁操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "销毁"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆提供随机访问功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆具备随机访问能力",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆能实现随机访问",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "优先队列提供引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列为引用计数提供操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列支持出栈这一操作。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是队列的数据结构操作。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "线性表可执行查找操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "查找"
    },
    {
      "sentence": "LRU缓存允许垃圾回收执行内存清理",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存提供垃圾回收的内存淘汰操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存支持垃圾回收的缓存淘汰机制",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "线段树提供引用计数的查询操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树支持引用计数的动态维护",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树可实现引用计数的高效管理",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树提供引用计数的维护操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树支持引用计数的计算操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树为引用计数提供操作支持",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "插入是平衡二叉树的标准操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "平衡二叉树能够执行插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "缩容是数组提供的操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "缩容"
    },
    {
      "sentence": "大根堆提供内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆具备内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆支持完成内存分配",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉堆为垃圾回收提供操作支持",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆向垃圾回收提供必要操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆提供垃圾回收所需的操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "小根堆可执行插入操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "LFU缓存提供初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存支持初始化功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存可执行初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "B树支持随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树能够实现随机访问",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是B树提供的操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B+树支持初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树提供初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "树状数组支持随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问操作由树状数组提供",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组能够实现随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表可执行删除操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "斐波那契堆支持入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆具备入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是斐波那契堆提供的操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "平衡二叉树提供入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树支持入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树具备入队操作能力",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "数组提供旋转相关操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "旋转"
    },
    {
      "sentence": "栈提供引用计数管理功能",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "栈可执行引用计数相关操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "路径压缩是树提供的操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树的数据结构包含路径压缩功能",
      "relation": "provides",
      "entity1": "树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "栈能实现路径压缩操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉搜索树提供初始化操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是二叉搜索树的基础操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树支持初始化功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "树状数组支持随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组具备随机访问能力",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组能进行随机访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "红黑树为垃圾回收提供高效的节点定位操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收的内存块管理操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树提供垃圾回收所需的快速查找操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "线段树能够执行合并操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "线段树可实现合并功能",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "大根堆提供顺序访问的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是大根堆的基本操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "大根堆具备顺序访问的功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "跳跃表提供内存分配功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表能够执行内存分配",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "斐波那契堆支持路径压缩操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "通过斐波那契堆可执行路径压缩",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "斐波那契堆的数据结构提供路径压缩功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "并查集可用于移动操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "并查集为移动提供支持",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "后缀树提供初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树支持初始化功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "借助后缀树可完成初始化",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树支持初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "斐波那契堆能够执行销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆支持销毁功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "循环链表提供引用计数的增加操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环链表提供引用计数的减少操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环链表提供引用计数的管理操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环链表提供移动节点的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表支持节点移动操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表可提供元素移动功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "字典树提供引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树支持引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树具备引用计数的操作能力",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉树可提供扩容能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "平衡二叉树支持插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "插入是平衡二叉树的标准操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "平衡二叉树能够执行插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "插入"
    },
    {
      "sentence": "在不相交集合中，出栈是其支持的操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合提供出栈这一操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈操作由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "哈希表提供顺序访问操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表支持顺序访问功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表具备顺序访问能力",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "AC自动机支持随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机具备随机访问能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机实现了随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林提供顺序访问操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是生成森林的操作之一",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "生成森林支持顺序访问功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "顺序访问"
    },
    {
      "sentence": "双端队列支持查找操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列允许执行查找",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列能够执行查找",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "通过后缀树可实现查找",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "查找"
    },
    {
      "sentence": "队列支持出栈这一操作。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是队列的数据结构操作。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "树状数组支持路径压缩操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组提供路径压缩功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组允许用户进行路径压缩",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "大根堆提供内存分配的最大块选取操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配借助大根堆的插入操作实现",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "出队是二叉堆的核心操作之一",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "二叉堆的数据结构提供了出队功能",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "AC自动机支持入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机可执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机具备入队功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "扩容是B+树提供的重要功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "B+树具备扩容的能力",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "LFU缓存支持出队操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存具备出队功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存可执行出队",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "对可持久化数据结构可执行遍历",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "小根堆提供初始化操作以创建初始堆结构",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是小根堆构建时的基础操作步骤",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "小根堆的初始化操作用于建立初始数据结构状态",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉堆为垃圾回收提供插入操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "垃圾回收借助二叉堆的删除操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆提供垃圾回收的堆调整操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "单链表支持引用计数操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表为引用计数提供操作支持",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表具备引用计数的操作能力",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "哈希表可执行旋转操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "树状数组支持引用计数的操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组可实现引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "通过树状数组完成引用计数",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "可持久化数据结构支持合并操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构提供合并功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构允许执行合并",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "二项堆可实现顺序访问",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "通过二项堆能进行顺序访问",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "使用B树可执行入队。",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉树的操作包含入栈",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "使用红黑树可进行路径压缩",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树支持路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "B+树可执行销毁操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "出栈是队列提供的操作之一。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "队列可执行出栈操作。",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存支持旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存提供旋转功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存允许执行旋转",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "图提供入栈的操作功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入栈"
    },
    {
      "sentence": "图支持入栈的操作执行",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入栈"
    },
    {
      "sentence": "图具备入栈操作的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆提供入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆支持入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆能执行入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树的操作包含入栈",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器能够执行合并",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可进行合并处理",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "大根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆提供内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是大根堆的操作之一",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表支持销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是双向链表的操作之一",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表支持遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "双向链表允许遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "双向链表能够执行遍历",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "布隆过滤器提供出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器支持出栈功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器允许执行出栈",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是循环链表提供的操作之一",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的操作能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "平衡二叉树支持入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树能执行入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树提供入队功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "B树具备扩容的操作能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是B树提供的重要操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "LFU缓存支持出栈操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈功能可由LFU缓存提供",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "LFU缓存具备出栈的能力",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出栈"
    },
    {
      "sentence": "用户可对小根堆执行插入",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "小根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆提供内存分配功能",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆可执行内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "生成森林支持用户进行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林为用户提供查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林可供用户执行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "双向链表支持销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表具备销毁功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表可进行销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "树提供引用计数管理功能",
      "relation": "provides",
      "entity1": "树",
      "entity2": "引用计数"
    },
    {
      "sentence": "树实现引用计数维护机制",
      "relation": "provides",
      "entity1": "树",
      "entity2": "引用计数"
    },
    {
      "sentence": "B+树提供初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树支持初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树允许执行初始化",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "循环链表支持用户执行移动操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表提供移动相关的操作功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表允许用户进行移动操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "合并是布隆过滤器的一项操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器提供合并功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "并查集可执行入队操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "移动是AC自动机的核心操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机支持移动操作以实现状态转移",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机通过移动操作完成字符串匹配",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树提供按秩合并功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "按秩合并是前缀树的操作之一",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "不相交集合提供入队操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "不相交集合具备入队功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "B+树支持内存分配操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树具备内存分配能力",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "B+树提供内存分配机制",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "内存分配"
    },
    {
      "sentence": "红黑树支持路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树具备路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩由红黑树提供",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "合并是线段树的核心操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "线段树支持执行合并操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "不相交集合支持入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合允许执行入栈",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合可进行入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "平衡二叉树为引用计数提供高效查找操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树提供引用计数的插入操作支持",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树能支持引用计数的平衡调整操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "数组提供了初始化功能",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "图数据结构支持随机访问",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组支持顺序访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组具备顺序访问的能力",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组允许对数据进行顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "可持久化数据结构支持合并操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构提供合并功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构能进行合并",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "斐波那契堆支持出队操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "出队是斐波那契堆的核心操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "斐波那契堆能够执行出队操作。",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "二叉搜索树提供入队操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由二叉搜索树提供",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉搜索树可执行入队操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "B+树能够执行插入操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "插入"
    },
    {
      "sentence": "B+树允许进行插入操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "插入"
    },
    {
      "sentence": "线段树能够执行合并操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "线段树可实现合并功能",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "二叉树支持随机访问操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉树具备随机访问的能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉树提供随机访问功能",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表支持缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表具备缩容的功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆支持入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是斐波那契堆提供的操作之一",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆可执行入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "并查集可用于执行入队",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树支持遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是平衡二叉树提供的关键操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树具备遍历功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "图的数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是图数据结构的操作之一",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "图结构能够提供随机访问的功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表具备初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表可执行初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表能完成初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "图能够进行插入边的操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "图具备插入元素的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "B树支持执行入队操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "B树能够提供入队功能",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "生成森林支持垃圾回收操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林提供垃圾回收的操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林支持用户执行垃圾回收",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "栈提供引用计数相关的操作功能",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "栈的操作中包含引用计数的维护",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数是栈实现中常用的操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉堆允许进行插入操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "插入"
    },
    {
      "sentence": "字典树提供引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树支持引用计数管理",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数是字典树的操作项",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉树的主要操作包括遍历",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "生成森林支持用户执行复制",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林提供复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林允许用户复制",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "线性表支持顺序访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表具备顺序访问的能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表能够实现顺序访问",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "双端队列提供引用计数的基本操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列支持引用计数的维护操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列实现引用计数的核心操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表提供引用计数操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表支持引用计数管理操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表具备引用计数操作功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持移动操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列提供元素移动功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列具备移动元素的能力",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构允许用户移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构实现移动功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机实现引用计数管理",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树可用于执行遍历",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是线段树提供的操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉树允许执行入栈操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "平衡二叉树支持遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是平衡二叉树的重要操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树具备遍历功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "缩容是大根堆提供的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "双端队列支持按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列能够进行按秩合并",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列可执行按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "出队是前缀树提供的操作之一",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "前缀树可执行出队操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "大根堆可提供缩容功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "大根堆能执行缩容操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表提供移动指针的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表支持移动节点的功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表可实现移动到指定节点的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "移动"
    },
    {
      "sentence": "二项堆可执行移动操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器具备旋转的能力",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器实现旋转功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "图为用户提供随机访问功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "图具备随机访问的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "斐波那契堆支持入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆提供入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "通过斐波那契堆可执行入栈",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "线性表具备出栈操作能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "线性表可执行出栈操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "生成森林支持查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "查找功能由生成森林提供",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林具备查找的能力",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "可持久化数据结构支持扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构提供扩容功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构允许用户扩容",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树支持路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树实现路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "线段树支持出栈操作。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树可实现出栈功能。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树能完成出栈操作。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "生成森林支持随机访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林可进行随机访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林允许随机访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表支持查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表能够实现查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表提供查找的能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合提供入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合具备入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合可进行入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "单链表提供删除节点的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表支持删除元素的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表中可执行删除操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "二叉树可执行扩容操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容操作由二叉树提供",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "B树支持随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树具备随机访问能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树提供随机访问功能",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "堆提供引用计数的操作功能。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆数据结构支持引用计数操作。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆支持引用计数的操作实现。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树为引用计数提供高效查找操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树为引用计数提供节点插入操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树为引用计数提供引用次数统计操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "数组可执行初始化操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构允许用户移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构实现移动功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "队列支持按顺序访问其元素",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是队列提供的基础操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列提供顺序访问的能力",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线段树可用于遍历数据",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉搜索树支持入队操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉搜索树能够执行入队",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉搜索树提供入队功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "后缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "按秩合并是后缀树提供的操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "后缀树具备按秩合并的操作能力",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "字典树能够执行插入操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "树状数组支持随机访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组具备随机访问能力",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "树状数组能进行随机访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉堆允许进行插入操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "插入"
    },
    {
      "sentence": "可持久化数据结构支持扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是可持久化数据结构的操作之一",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构可提供扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "入队是并查集提供的基础操作之一",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "并查集的数据结构包含入队操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入队"
    },
    {
      "sentence": "线段树提供的操作包含复制",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "复制"
    },
    {
      "sentence": "复制是线段树的可用操作之一",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "复制"
    },
    {
      "sentence": "哈希表支持内存分配操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "哈希表具备内存分配的能力",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "哈希表实现内存分配功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆可执行插入操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "小根堆能够进行插入操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "图能够进行插入边的操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "图具备插入元素的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "哈希表支持内存分配操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配借助哈希表完成",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "哈希表提供内存分配所需操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "AC自动机支持在匹配过程中进行状态移动",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机提供状态转移的移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机在匹配时会执行状态移动",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "路径压缩是栈支持的操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "路径压缩"
    },
    {
      "sentence": "布隆过滤器支持出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是布隆过滤器提供的功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器可执行出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树允许用户执行出栈",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树能够执行出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "二叉搜索树具备入队操作能力",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉搜索树提供入队操作支持",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "二叉搜索树可执行入队操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "入队"
    },
    {
      "sentence": "生成森林支持查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林具备查找能力",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林可实现查找功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "在二叉树中，扩容是其操作之一",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是循环链表提供的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "使用线性表可以进行初始化。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表支持初始化操作。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表提供初始化的功能。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "双向链表为垃圾回收提供节点遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表支持垃圾回收的节点链接管理",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表提供垃圾回收所需的节点清理功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "布隆过滤器支持初始化操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器允许用户执行初始化",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器提供初始化功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "并查集可执行入栈操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "数组提供旋转操作功能",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "旋转"
    },
    {
      "sentence": "数组支持旋转这一操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "旋转"
    },
    {
      "sentence": "数组中可进行旋转操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "旋转"
    },
    {
      "sentence": "可持久化数据结构支持扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构提供扩容功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构允许用户扩容",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "LRU缓存提供操作以支持引用计数管理",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数借助LRU缓存提供的操作实现",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "LRU缓存提供的操作可维护引用计数",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "引用计数"
    },
    {
      "sentence": "大根堆可实现合并功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "借助大根堆能够完成合并",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "字典树支持高效的查找操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "字典树能够实现快速查找功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "查找是字典树的核心操作之一",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "在链表中，销毁是核心操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "链表支持销毁这一操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "堆提供引用计数的操作支持",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆支持引用计数的维护功能",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆实现引用计数的相关操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树提供引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数是字典树的操作之一",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树支持引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持销毁操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "平衡二叉树能够执行销毁",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁操作可通过平衡二叉树完成",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数的能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机可执行引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉堆允许用户进行出栈",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "二叉堆为垃圾回收提供插入操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "垃圾回收借助二叉堆的删除操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆提供垃圾回收的堆调整操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "数组可实现元素的移动",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "移动"
    },
    {
      "sentence": "数组允许对元素进行移动",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "移动"
    },
    {
      "sentence": "优先队列支持用户进行初始化",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列提供初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列允许用户完成初始化",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "线段树可用于执行遍历",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是线段树提供的操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "斐波那契堆提供销毁操作以释放内存资源",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是斐波那契堆支持的关键操作之一",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆通过销毁操作完成数据结构清理",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "单链表支持内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表的内存分配操作是其基础功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是单链表构建时的关键操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "不相交集合支持入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是不相交集合提供的操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合具备入栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉堆能执行出栈操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈操作由二叉堆提供",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是二叉堆的操作之一",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "大根堆可执行合并操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "通过优先队列能够完成出栈",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "二叉树提供路径压缩操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树支持路径压缩功能",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树实现路径压缩方法",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "并查集可执行入栈操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "双端队列提供引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列实现引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列具备引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "图具备销毁操作的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "图提供销毁操作的功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "字典树具备出栈操作功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "字典树可执行出栈操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "查找是字典树的核心操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "字典树为查找提供高效实现",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "单链表提供内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表支持内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表实现内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "栈提供引用计数管理功能",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "栈可执行引用计数相关操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "线性表支持初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表提供初始化功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是线性表的基础操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "缩容是前缀树提供的操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "缩容"
    },
    {
      "sentence": "AC自动机具备随机访问功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机能够执行随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机提供随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉搜索树支持初始化操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树能够完成初始化",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是二叉搜索树提供的操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树提供按秩合并功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "后缀树能执行按秩合并",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "大根堆提供顺序访问的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是大根堆的基本操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "大根堆具备顺序访问的功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "堆提供引用计数的操作功能。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆数据结构支持引用计数操作。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆支持引用计数的操作实现。",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列提供扩容操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "优先队列可执行扩容操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "优先队列具备扩容操作能力",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "平衡二叉树提供遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树支持遍历功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树具备遍历能力",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "布隆过滤器支持初始化操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器允许用户执行初始化",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器提供初始化功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "小根堆提供初始化操作以创建初始堆结构",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是小根堆构建时的基础操作步骤",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "小根堆的初始化操作用于建立初始数据结构状态",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉堆可实现出队功能",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "出队是二叉堆提供的操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "二项堆可执行移动操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "跳跃表支持执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表能够进行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "大根堆支持随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是大根堆提供的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆允许随机访问元素",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "图数据结构支持销毁操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "图提供的关键操作之一是销毁",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "堆提供缩容的操作功能",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "缩容"
    },
    {
      "sentence": "堆的数据操作包含缩容",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "缩容"
    },
    {
      "sentence": "LRU缓存允许遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历可通过LRU缓存完成",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合支持入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是不相交集合提供的操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合提供入栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "线性表支持顺序访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表可执行顺序访问",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表具备顺序访问能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "前缀树支持内存分配功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树为内存分配提供支持",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配操作由前缀树提供",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表支持按秩合并操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "跳跃表具备按秩合并功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "跳跃表提供按秩合并操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "树提供了引用计数功能",
      "relation": "provides",
      "entity1": "树",
      "entity2": "引用计数"
    },
    {
      "sentence": "小根堆提供内存分配操作。",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆支持内存分配相关操作。",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是小根堆提供的操作。",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "生成森林提供查找这一操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林支持执行查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "查找是生成森林提供的操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "栈可执行路径压缩操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "路径压缩"
    },
    {
      "sentence": "双向链表为垃圾回收提供节点遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表支持垃圾回收的节点链接管理",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表提供垃圾回收所需的节点清理功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "循环队列支持遍历操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "循环队列可实现遍历功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "通过循环队列可以完成遍历",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "跳跃表支持按秩合并操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "跳跃表具备按秩合并功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "跳跃表提供按秩合并操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "按秩合并"
    },
    {
      "sentence": "单链表提供内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表支持内存分配功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表具备内存分配的操作能力",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "队列支持顺序访问操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列允许对元素进行顺序访问",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "队列实现了顺序访问的功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "顺序访问"
    },
    {
      "sentence": "双向链表提供的遍历操作支持垃圾回收标记",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表的删除操作辅助垃圾回收内存清理",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表通过前驱后继指针支持垃圾回收引用计数",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "通过优先队列能够完成出栈",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "红黑树提供按秩合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "按秩合并是红黑树的操作功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "红黑树支持按秩合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双向链表提供的遍历操作支持垃圾回收标记",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表的删除操作辅助垃圾回收内存清理",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表通过前驱后继指针支持垃圾回收引用计数",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是二项堆的操作之一",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆提供随机访问功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "图为用户提供随机访问功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "图具备随机访问的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "通过后缀树可实现查找",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "查找"
    },
    {
      "sentence": "AC自动机支持扩容操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是AC自动机提供的功能之一",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "AC自动机具备扩容的能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "循环队列提供移动操作以调整元素位置",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列支持移动操作，用于维护队列结构",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "移动是循环队列的核心操作之一",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "线性表的数据结构提供出栈功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是线性表的操作之一",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "AC自动机提供引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "借助AC自动机可实现引用计数",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "后缀树支持随机访问操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树可实现随机访问",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树具备随机访问功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "扩容是B树提供的操作之一",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "跳跃表支持数据复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表可实现数据复制功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表提供复制数据的操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "可持久化数据结构提供遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构支持遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构支持元素遍历",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "布隆过滤器提供初始化功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器可执行初始化操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化操作由布隆过滤器提供",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "跳跃表支持内存分配操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表具备内存分配的能力",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表实现内存分配功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉堆可实现出栈功能",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "二叉堆能执行出栈操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "单链表可实现入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "线段树可执行出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树能够完成出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合提供出栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合支持出栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合具备出栈操作能力",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "循环队列支持缩容操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "循环队列可实现缩容功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "循环队列能够执行缩容",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "双端队列提供按秩合并的操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列具备按秩合并的功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列能进行按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "二叉堆提供垃圾回收操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆支持垃圾回收功能",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "二叉堆可执行垃圾回收操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "队列能够提供出栈操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "通过队列可完成出栈功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "利用队列能实现出栈操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "出栈"
    },
    {
      "sentence": "双端队列提供引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列实现引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列具备引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉堆可执行出队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "不相交集合提供查找操作以识别元素集合",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "查找是不相交集合的核心操作之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合通过查找功能确定元素归属",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构允许用户移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构实现移动功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构允许遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "后缀树具备按秩合并操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "后缀树提供按秩合并操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "后缀树可执行按秩合并操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "循环链表支持缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表具备缩容功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "LRU缓存支持遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "LRU缓存具备遍历功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "LRU缓存为用户提供遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "双端队列具备查找功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列支持执行查找操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列可进行查找操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "出队操作由前缀树提供",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "前缀树能执行出队操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "双向链表支持复制操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "双向链表可通过复制操作创建新链表",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "复制是双向链表的常用操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "树数据结构支持出栈操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "树可提供出栈这一操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "后缀树支持随机访问操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树可实现随机访问",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树具备随机访问功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "不相交集合支持遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合能够进行遍历",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合提供遍历功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是优先队列的重要操作之一",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列能够执行出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "LRU缓存支持随机访问",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存具备随机访问能力",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存能实现随机访问操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "随机访问"
    },
    {
      "sentence": "优先队列支持内存分配操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列提供内存分配功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列可执行内存分配",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表提供随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "红黑树支持路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树实现了路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树具备路径压缩操作能力",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "旋转是链表的常用操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "B+树提供初始化功能",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树支持初始化操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B+树具备初始化能力",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "初始化"
    },
    {
      "sentence": "B树提供随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树具备随机访问能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树可实现随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环队列实现引用计数操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列具备引用计数操作能力",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持引用计数相关操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列提供按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列支持执行按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列可进行按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列的基本功能包含初始化",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列可执行初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表具备销毁功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表可执行销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "布隆过滤器提供初始化操作以完成初始设置",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是布隆过滤器的基础操作步骤",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器通过初始化构建其数据结构",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "前缀树提供内存分配操作。",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是前缀树的核心操作。",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树支持内存分配操作。",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "循环链表支持查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表提供查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "查找是循环链表的重要操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "树数据结构支持出栈操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "树提供的操作包含出栈",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "可持久化数据结构支持合并操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构提供合并功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构能够执行合并",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "大根堆提供内存分配操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆具备内存分配功能",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "大根堆支持完成内存分配",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "LFU缓存支持旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存提供旋转功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存允许执行旋转",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器能够执行合并",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可进行合并处理",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "跳跃表支持执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "跳跃表能够进行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "链表具备销毁操作能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "可持久化数据结构支持扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构具备扩容能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构能进行扩容",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "AC自动机提供引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机具备引用计数的操作能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "出队是二叉堆的核心操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "二叉堆可执行出队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林可执行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "红黑树为垃圾回收提供节点插入操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树为垃圾回收提供节点删除操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树为垃圾回收提供平衡调整操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "单链表支持内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表提供内存分配功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表可执行内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "用户可通过哈希表进行插入",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "插入"
    },
    {
      "sentence": "并查集提供的操作包括移动",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机支持移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机可实现移动功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机具备移动操作能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "循环链表支持查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表能提供查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表具备查找能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "栈可执行引用计数操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "引用计数"
    },
    {
      "sentence": "前缀树提供销毁这一操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁操作由前缀树提供",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆支持路径压缩操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩是斐波那契堆提供的功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "斐波那契堆提供路径压缩以优化操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "双端队列支持随机访问",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列具备随机访问的能力",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列允许随机访问",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "LRU缓存支持路径压缩作为核心操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩是LRU缓存提供的重要操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "LRU缓存提供路径压缩这一关键操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉堆能执行出队操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出队"
    },
    {
      "sentence": "在B+树中，销毁是其提供的操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "B+树提供销毁操作以释放资源",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是B+树数据结构提供的操作之一",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "生成森林支持垃圾回收操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林具备垃圾回收功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "垃圾回收由生成森林提供",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "哈希表提供了旋转功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表具备旋转相关能力",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器具备出栈功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器支持出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器可执行出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "斐波那契堆支持入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是斐波那契堆提供的核心操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆提供入栈功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "AC自动机提供扩容操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "AC自动机支持扩容功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是AC自动机的常用操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "LRU缓存支持路径压缩操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "LRU缓存提供路径压缩功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩可通过LRU缓存实现",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "路径压缩"
    },
    {
      "sentence": "平衡二叉树支持销毁操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "平衡二叉树能够执行销毁",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁操作可通过平衡二叉树完成",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "销毁"
    },
    {
      "sentence": "大根堆可执行合并操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "使用线性表可以进行初始化。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表支持初始化操作。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表提供初始化的功能。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "AC自动机支持执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机提供入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机可进行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "字典树具备出栈操作功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "字典树可执行出栈操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "AC自动机支持随机访问操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机提供随机访问功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "AC自动机可执行随机访问",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆的主要功能之一是随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆支持随机访问操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能够实现随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "链表支持执行入栈操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "入栈"
    },
    {
      "sentence": "链表允许进行入栈操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "入栈"
    },
    {
      "sentence": "B树能够执行查找操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "查找"
    },
    {
      "sentence": "树状数组提供引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数管理",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组实现引用计数操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组支持引用计数的操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "树状数组可实现引用计数功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "通过树状数组完成引用计数",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "引用计数"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆具备缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是斐波那契堆提供的操作之一",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "并查集具备销毁这一操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "并查集可执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "LFU缓存提供初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存支持初始化功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存可执行初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "字典树具备出栈操作功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "字典树可执行出栈操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "出栈"
    },
    {
      "sentence": "树状数组支持路径压缩操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组可实现路径压缩",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组能执行路径压缩",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "B+树允许执行销毁操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆提供缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆允许执行缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "大根堆能够进行顺序访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "大根堆提供顺序访问的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "双向链表提供扩容操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "扩容"
    },
    {
      "sentence": "双向链表支持扩容功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "扩容"
    },
    {
      "sentence": "双向链表可执行扩容操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "扩容"
    },
    {
      "sentence": "AC自动机提供引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机具备引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数操作由AC自动机提供",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "不相交集合提供入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合支持入栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈操作由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合提供入队操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由不相交集合提供",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "不相交集合支持执行入队操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入队"
    },
    {
      "sentence": "双向链表提供复制操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "双向链表支持复制功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "双向链表具备复制能力",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "队列具备引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列提供引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列实现引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "B树允许用户进行入队",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "栈能执行路径压缩操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "路径压缩"
    },
    {
      "sentence": "不相交集合支持入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合具备入栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合可执行入栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "入栈"
    },
    {
      "sentence": "前缀树提供内存分配操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树支持内存分配操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树提供高效内存分配操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器具备旋转的能力",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器实现旋转功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "销毁操作可由并查集提供",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "生成森林支持用户进行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林为用户提供查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林可供用户执行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "旋转是二项堆提供的操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "旋转"
    },
    {
      "sentence": "优先队列支持扩容操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "优先队列具备扩容能力",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "优先队列允许用户扩容",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "扩容"
    },
    {
      "sentence": "字典树支持对数据的查找",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "图为用户提供随机访问功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "图具备随机访问的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "字典树支持引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树实现引用计数机制",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树提供引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持移动操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列可执行移动功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列能实现移动操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "移动"
    },
    {
      "sentence": "大根堆可实现随机访问",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是大根堆提供的操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆支持随机访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆具备随机访问能力",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问可通过二项堆实现",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉树的主要操作包括遍历",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "斐波那契堆提供缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆具备缩容能力",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构具备遍历能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构能够进行遍历",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "并查集支持入栈操作。",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "并查集提供入栈功能。",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是并查集的操作之一。",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列能够执行出栈",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列提供出栈功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "小根堆提供内存分配所需的高效操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆支持内存分配的关键操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配借助小根堆的操作实现",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "遍历是栈的数据结构操作之一",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "遍历"
    },
    {
      "sentence": "树支持用户执行出栈操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "用户可通过树执行出栈",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "树能为用户提供出栈功能",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "循环链表提供随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表支持随机访问功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是循环链表提供的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是优先队列的核心操作之一",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列提供出栈这一功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "并查集可执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列提供出栈功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列具备出栈能力",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列提供初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列支持初始化功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化由优先队列提供",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "双端队列支持按秩合并操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "按秩合并可借助双端队列完成",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列提供按秩合并功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "优先队列提供引用计数的插入操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数的删除操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列可执行引用计数的统计操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "并查集支持元素的移动",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "并查集提供元素移动的功能",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "并查集可实现元素移动操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "小根堆支持内存分配操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆可实现内存分配功能",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "小根堆辅助完成内存分配",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "可持久化数据结构支持随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构提供随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构允许随机访问功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树提供了初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树提供初始化功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是后缀树提供的操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表提供随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列提供引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列支持引用计数操作的执行",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列允许用户进行引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "二叉堆允许用户进行出栈",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "生成森林提供复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林允许进行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制操作能力",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "哈希表支持旋转操作。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表提供旋转功能。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表可执行旋转操作。",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "旋转"
    },
    {
      "sentence": "斐波那契堆支持入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是斐波那契堆提供的操作之一",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "斐波那契堆可执行入栈操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "入栈"
    },
    {
      "sentence": "插入是字典树提供的基础操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "字典树具备插入这一操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "树状数组支持路径压缩操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组提供路径压缩功能",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "树状数组借助路径压缩优化效率",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "路径压缩"
    },
    {
      "sentence": "LRU缓存提供垃圾回收功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存支持垃圾回收操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "LRU缓存具备垃圾回收能力",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "树状数组支持顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组具备顺序访问能力",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组可实现顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "B树允许用户进行入队",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "数组能够执行缩容操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "缩容"
    },
    {
      "sentence": "数组支持进行缩容操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "缩容"
    },
    {
      "sentence": "数组能对自身进行缩容",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "缩容"
    },
    {
      "sentence": "不相交集合支持遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是不相交集合提供的操作之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合能够进行遍历",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "循环链表支持随机访问操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的能力",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表能够进行随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "并查集允许执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "AC自动机支持入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机具备入队这一操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机能够执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "字典树的插入是其基本操作之一",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "利用字典树可完成查找",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "查找"
    },
    {
      "sentence": "链表具备复制操作能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "AC自动机具备扩容功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是AC自动机提供的操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "AC自动机可执行扩容操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "扩容"
    },
    {
      "sentence": "LFU缓存支持旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存可执行旋转",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "旋转是LFU缓存提供的操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "出栈是小根堆的基本操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "出栈"
    },
    {
      "sentence": "小根堆支持出栈这一操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "出栈"
    },
    {
      "sentence": "二项堆支持顺序访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "二项堆具备顺序访问能力",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "二项堆可进行顺序访问",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线段树可执行出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "树的数据结构提供初始化操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是树的基础操作之一",
      "relation": "provides",
      "entity1": "树",
      "entity2": "初始化"
    },
    {
      "sentence": "树支持初始化这一操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "初始化"
    },
    {
      "sentence": "图具备插入操作的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "二叉搜索树具备缩容功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容操作由二叉搜索树提供",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树支持执行缩容",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "B树可执行扩容操作。",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "单链表支持引用计数维护",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表允许引用计数更新",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表提供引用计数追踪",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "堆能够提供移动相关的操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "利用堆可以完成移动操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "堆支持移动操作的执行",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "双端队列支持遍历操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是双端队列提供的基础操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "双端队列具备遍历的能力",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "遍历"
    },
    {
      "sentence": "单链表可执行入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "树数据结构支持出栈操作",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "树提供的操作包含出栈",
      "relation": "provides",
      "entity1": "树",
      "entity2": "出栈"
    },
    {
      "sentence": "双端队列提供引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列实现引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列具备引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "LFU缓存提供插入操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "LFU缓存支持插入功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "LFU缓存可执行插入操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "数组支持执行出栈操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "数组为用户提供出栈操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "用户可通过数组执行出栈",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "出栈"
    },
    {
      "sentence": "B树支持执行入队操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "B树能够提供入队功能",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "入队"
    },
    {
      "sentence": "出栈是线性表提供的操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "线性表可执行出栈操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "双向链表支持遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "双向链表具备遍历功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "B树提供随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树具备随机访问能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树可实现随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "大根堆能够执行合并操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "大根堆支持数据合并操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构具备随机访问的能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构可实现随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "旋转是链表的常用操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表可实现顺序访问",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "通过哈希表可进行顺序访问",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "并查集具备销毁这一操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "并查集可执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "LFU缓存提供出队操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存支持出队功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存具备出队操作能力",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "单链表可执行删除操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "跳跃表支持数据复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表可执行复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "小根堆可执行插入操作",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "插入是小根堆提供的操作之一",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "优先队列支持内存分配操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列具备内存分配的能力",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列可完成内存分配",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "字典树能实现复制功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "复制"
    },
    {
      "sentence": "入队是二叉堆的基本操作之一",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "入队"
    },
    {
      "sentence": "LFU缓存提供旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存支持旋转调整",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存具备旋转操作能力",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "循环队列支持遍历操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "遍历是循环队列的基本操作之一",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "循环队列能够执行遍历操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "树状数组支持顺序访问操作",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组能够进行顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "树状数组允许顺序访问",
      "relation": "provides",
      "entity1": "树状数组",
      "entity2": "顺序访问"
    },
    {
      "sentence": "循环链表支持缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表能够执行缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表提供缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "不相交集合支持遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合可实现遍历",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合能够进行遍历",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合支持出栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合能够执行出栈操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "不相交集合提供出栈功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "出栈"
    },
    {
      "sentence": "跳跃表支持执行入队操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "数组支持执行缩容操作",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "缩容"
    },
    {
      "sentence": "红黑树提供垃圾回收操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收执行",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收实现",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "B树提供随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树具备随机访问能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树可实现随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "LFU缓存提供插入操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "LFU缓存支持插入功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "LFU缓存可执行插入操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "插入"
    },
    {
      "sentence": "双向链表支持遍历操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "双向链表具备遍历功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "遍历"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆实现销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆具备销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "字典树提供引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数是字典树的操作之一",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树支持引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线性表的数据结构提供出栈功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是线性表的操作之一",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器提供初始化操作以完成初始设置",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是布隆过滤器的基础操作步骤",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器通过初始化构建其数据结构",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "链表提供的操作之一是销毁。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "链表可执行旋转操作。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "旋转"
    },
    {
      "sentence": "哈希表提供顺序访问操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表支持顺序访问功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表具备顺序访问能力",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "数组可实现元素的移动",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "移动"
    },
    {
      "sentence": "数组允许对元素进行移动",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "移动"
    },
    {
      "sentence": "B+树可执行销毁操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "B树具备扩容的操作能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "扩容是B树提供的重要操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "扩容"
    },
    {
      "sentence": "使用线性表可以进行初始化。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表支持初始化操作。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表提供初始化的功能。",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉树支持执行入栈操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树提供入栈操作功能",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "用户可通过二叉树进行入栈操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "不相交集合提供查找操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作是不相交集合的功能之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合具备查找这一操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "二叉树支持随机访问操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是二叉树提供的操作之一",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉树能够实现随机访问",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "随机访问"
    },
    {
      "sentence": "平衡二叉树支持入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树提供入队功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树具备入队操作能力",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "红黑树为垃圾回收提供高效查找功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树为垃圾回收提供节点管理操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "红黑树支持垃圾回收的引用追踪操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "队列支持引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列实现引用计数功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列提供引用计数相关操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树提供入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "入队操作由平衡二叉树提供",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树支持入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表具备销毁操作能力",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表的操作包含销毁",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "优先队列具备内存分配功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列实现内存分配操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列可执行内存分配操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "LFU缓存具备旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存支持执行旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存能执行旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "线性表支持执行查找操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "查找"
    },
    {
      "sentence": "二叉搜索树提供内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树具备内存分配操作功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树可执行内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "栈为遍历操作提供支持",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "遍历"
    },
    {
      "sentence": "在B+树中，销毁是其提供的操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "B+树提供销毁操作以释放资源",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是B+树数据结构提供的操作之一",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表支持销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是双向链表的操作之一",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "通过生成森林可实现复制",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "插入操作可通过B树完成",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "插入"
    },
    {
      "sentence": "B树能够执行插入操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "插入"
    },
    {
      "sentence": "堆为引用计数提供支持",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "引用计数"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆实现销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆具备销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "单链表可执行入队操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "单链表支持随机访问操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表可实现随机访问",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表提供随机访问功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环队列支持插入操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "循环队列提供插入功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "循环队列能执行插入操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "循环队列具备遍历功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "循环队列允许遍历操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "遍历"
    },
    {
      "sentence": "双向链表提供销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双向链表支持销毁操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是双向链表的操作之一",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "销毁"
    },
    {
      "sentence": "双端队列支持查找操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列提供查找功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "二叉树的操作包含入栈",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树可提供扩容能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "扩容"
    },
    {
      "sentence": "循环链表支持缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表提供缩容功能以优化空间",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表可通过缩容操作节省空间",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "双向链表支持复制操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "复制操作是双向链表的功能之一",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "双向链表具备复制数据的能力",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "复制"
    },
    {
      "sentence": "并查集支持入栈这一操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "入栈是并查集的操作之一",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可用于合并",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器能执行合并",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "通过前缀树可执行按秩合并",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树能完成按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "队列提供引用计数相关操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列支持引用计数的管理操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "使用队列可完成引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "可持久化数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构具备随机访问能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构允许对数据进行随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉搜索树支持内存分配相关的操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树可用于执行内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配依赖二叉搜索树提供的操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "双端队列支持引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列具备引用计数功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列提供引用计数维护操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "通过AC自动机能够进行入队",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "AC自动机可执行入队操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "入队"
    },
    {
      "sentence": "循环链表支持查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表能实现查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表提供查找方法",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树具备路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树实现路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "循环链表提供查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表可执行查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作由循环链表支持",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树具备按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树可执行按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "LFU缓存提供初始化操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "LFU缓存支持初始化功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "通过LFU缓存可完成初始化",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "初始化"
    },
    {
      "sentence": "堆提供了移动操作功能",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "堆支持了移动操作功能",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "堆具备了移动操作能力",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "对可持久化数据结构可执行遍历",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "缩容是前缀树提供的操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "缩容"
    },
    {
      "sentence": "线段树可执行出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "线段树能够完成出栈操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "出栈"
    },
    {
      "sentence": "循环链表支持随机访问",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是循环链表提供的操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "循环链表具备随机访问的功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "树允许用户执行路径压缩",
      "relation": "provides",
      "entity1": "树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "线段树能够执行合并操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "线段树可实现合并功能",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "合并"
    },
    {
      "sentence": "单链表支持内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表的内存分配操作是其基础功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是单链表构建时的关键操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "平衡二叉树支持遍历操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树可进行遍历",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "平衡二叉树提供遍历功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉搜索树提供内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树具备内存分配操作功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树可执行内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "循环链表提供查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表可执行查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作由循环链表支持",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "图具备销毁操作的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "图提供销毁操作的功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "销毁"
    },
    {
      "sentence": "并查集可执行旋转操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "并查集提供旋转相关操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "循环链表支持查找操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表提供查找功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "查找是循环链表的重要操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列支持查找操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列允许执行查找",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列能够执行查找",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "查找"
    },
    {
      "sentence": "二项堆支持内存分配操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆提供内存分配功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆能执行内存分配操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "图数据结构支持入队操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入队"
    },
    {
      "sentence": "入队是图提供的操作之一",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入队"
    },
    {
      "sentence": "图数据结构支持插入操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "插入是图数据结构的操作之一",
      "relation": "provides",
      "entity1": "图",
      "entity2": "插入"
    },
    {
      "sentence": "二叉搜索树支持缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树具备缩容功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树提供缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "通过二叉树可完成入栈",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "线性表具备顺序访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "线性表提供顺序访问能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "堆提供对销毁操作的支持",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "用户可通过堆执行销毁",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "单链表提供引用计数的管理操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表支持引用计数的维护操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表可用于实现引用计数的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列提供初始化功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列能进行初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "循环链表提供引用计数操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环链表支持引用计数机制",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环链表实现引用计数管理",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "引用计数可通过AC自动机实现",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "后缀树提供随机访问操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "后缀树可进行随机访问",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构允许执行移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构具备移动功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构具备移动能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构能执行移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "斐波那契堆提供路径压缩操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩是斐波那契堆的操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "斐波那契堆支持路径压缩功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "路径压缩"
    },
    {
      "sentence": "链表具备入栈这一操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "入栈"
    },
    {
      "sentence": "线段树支持遍历操作。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "线段树允许执行遍历。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "线段树具备遍历功能。",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "遍历"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是优先队列的基础操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列可执行初始化步骤",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "二项堆可执行移动操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "出栈是二叉堆提供的操作",
      "relation": "provides",
      "entity1": "二叉堆",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列支持初始化操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是优先队列的基础操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "优先队列可执行初始化步骤",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "初始化"
    },
    {
      "sentence": "单链表支持内存分配操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "单链表的内存分配操作是其基础功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配是单链表构建时的关键操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉树具备遍历的操作能力",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉树可执行遍历操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构支持随机访问操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构具备随机访问能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构允许对数据进行随机访问",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "随机访问"
    },
    {
      "sentence": "并查集具备销毁这一操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "并查集可执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "AC自动机支持引用计数操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机提供引用计数功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机实现引用计数管理",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "引用计数"
    },
    {
      "sentence": "布隆过滤器支持出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是布隆过滤器提供的功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "布隆过滤器可执行出栈操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "出栈"
    },
    {
      "sentence": "栈能实现路径压缩操作",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "路径压缩"
    },
    {
      "sentence": "并查集可执行旋转操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "并查集提供旋转相关操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "链表能提供销毁操作。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "链表支持销毁操作的执行。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁操作是链表提供的。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆提供销毁操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆支持销毁功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "斐波那契堆允许执行销毁",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "销毁"
    },
    {
      "sentence": "线性表支持随机访问操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "随机访问是线性表的数据结构操作之一",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "线性表具备随机访问的能力",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "随机访问"
    },
    {
      "sentence": "二项堆支持内存分配操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆实现内存分配相关功能",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆提供内存分配的关键操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "循环队列支持引用计数操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列具备引用计数的功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列可实现引用计数管理",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持缩容操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是循环队列提供的功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "循环队列具备缩容的能力",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "缩容"
    },
    {
      "sentence": "双端队列支持引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列提供引用计数功能",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列可执行引用计数操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表提供随机访问操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表支持随机访问功能",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "单链表允许随机访问元素",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "随机访问"
    },
    {
      "sentence": "二叉搜索树支持缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是二叉搜索树的一项操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树可执行缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "B树允许用户进行查找",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "查找"
    },
    {
      "sentence": "循环链表提供缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表支持缩容功能",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "循环链表允许缩容操作",
      "relation": "provides",
      "entity1": "循环链表",
      "entity2": "缩容"
    },
    {
      "sentence": "哈希表支持内存分配操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "哈希表为内存分配提供操作支持",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "哈希表能提供内存分配所需操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "内存分配"
    },
    {
      "sentence": "红黑树支持执行合并操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "合并"
    },
    {
      "sentence": "红黑树具备合并操作能力",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "合并"
    },
    {
      "sentence": "双端队列支持随机访问操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列具备随机访问操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双端队列允许随机访问操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "随机访问"
    },
    {
      "sentence": "双向链表提供垃圾回收相关操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表通过操作支持垃圾回收",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双向链表的数据结构提供垃圾回收操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "双端队列提供引用计数的维护操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列支持引用计数的管理操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "双端队列实现引用计数的存储操作",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列提供引用计数功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列实现引用计数机制",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "并查集允许执行销毁操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "销毁"
    },
    {
      "sentence": "循环队列支持插入操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "循环队列提供插入功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "插入操作可由循环队列完成",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "插入"
    },
    {
      "sentence": "出队是前缀树提供的基础功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "前缀树可执行出队这一操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "出队"
    },
    {
      "sentence": "不相交集合支持遍历操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合能够进行遍历",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "不相交集合提供遍历功能",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "遍历"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器具备旋转的能力",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器实现旋转功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "二叉搜索树支持缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "缩容是二叉搜索树的一项操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树可执行缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "堆提供的操作包含销毁",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "销毁是堆的一项基本操作",
      "relation": "provides",
      "entity1": "堆",
      "entity2": "销毁"
    },
    {
      "sentence": "可持久化数据结构支持合并操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构提供合并功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "可持久化数据结构能进行合并",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "合并"
    },
    {
      "sentence": "单链表提供删除节点的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表支持删除元素的操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表中可执行删除操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "二叉搜索树提供初始化功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树支持初始化操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "二叉搜索树具备初始化过程",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "初始化"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构允许遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "字典树能实现复制功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "复制"
    },
    {
      "sentence": "LRU缓存支持遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "LRU缓存具备遍历功能",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "LRU缓存为用户提供遍历操作",
      "relation": "provides",
      "entity1": "LRU缓存",
      "entity2": "遍历"
    },
    {
      "sentence": "单链表支持用户执行入队",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "单链表为用户提供入队",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "入队"
    },
    {
      "sentence": "斐波那契堆支持出队操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "斐波那契堆能够执行出队",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "斐波那契堆提供出队功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "出队"
    },
    {
      "sentence": "B树支持随机访问操作",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "B树具备随机访问能力",
      "relation": "provides",
      "entity1": "B树",
      "entity2": "随机访问"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "优先队列可执行出栈功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "出栈是优先队列提供的操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "跳跃表支持内存分配操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表实现内存分配功能",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "跳跃表提供内存分配能力",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "内存分配"
    },
    {
      "sentence": "LFU缓存支持旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存提供旋转功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存实现旋转操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "旋转"
    },
    {
      "sentence": "LFU缓存提供出队操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "出队是LFU缓存的基础操作",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "LFU缓存支持出队功能",
      "relation": "provides",
      "entity1": "LFU缓存",
      "entity2": "出队"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树提供按秩合并功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树可实现按秩合并",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "生成森林支持随机访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林具备随机访问功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林可实现随机访问",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "随机访问"
    },
    {
      "sentence": "生成森林提供垃圾回收操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林具备垃圾回收操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "生成森林实现垃圾回收操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "队列具备销毁操作能力",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "销毁"
    },
    {
      "sentence": "数组支持用户执行初始化",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "数组为用户提供初始化功能",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "数组允许用户进行初始化",
      "relation": "provides",
      "entity1": "数组",
      "entity2": "初始化"
    },
    {
      "sentence": "平衡二叉树提供引用计数操作。",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持引用计数操作的执行。",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树允许用户执行引用计数操作。",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "插入操作可由小根堆完成",
      "relation": "provides",
      "entity1": "小根堆",
      "entity2": "插入"
    },
    {
      "sentence": "跳跃表支持数据复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "跳跃表可执行复制操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林支持用户进行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林为用户提供查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林可供用户执行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "前缀树支持内存分配功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树为内存分配提供支持",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配操作由前缀树提供",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林提供复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林能执行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "不相交集合提供查找操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作是不相交集合的功能之一",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "不相交集合具备查找这一操作",
      "relation": "provides",
      "entity1": "不相交集合",
      "entity2": "查找"
    },
    {
      "sentence": "并查集可执行入栈操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "入栈"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "使用红黑树可进行路径压缩",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树支持路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "平衡二叉树支持入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树提供入队功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树具备入队操作能力",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "单链表支持引用计数维护",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表允许引用计数更新",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "单链表提供引用计数追踪",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "引用计数"
    },
    {
      "sentence": "布隆过滤器支持合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器具备合并处理能力",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可执行合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "斐波那契堆提供缩容功能",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆支持缩容操作",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "斐波那契堆具备缩容能力",
      "relation": "provides",
      "entity1": "斐波那契堆",
      "entity2": "缩容"
    },
    {
      "sentence": "优先队列支持出栈操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "通过优先队列能够完成出栈",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "出栈"
    },
    {
      "sentence": "图数据结构支持入队操作",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入队"
    },
    {
      "sentence": "入队是图提供的操作之一",
      "relation": "provides",
      "entity1": "图",
      "entity2": "入队"
    },
    {
      "sentence": "链表提供的复制操作是基础功能之一",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "链表支持对其元素进行复制操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "复制链表是链表数据结构提供的典型操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "复制"
    },
    {
      "sentence": "插入是字典树支持的操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "插入"
    },
    {
      "sentence": "二叉搜索树支持内存分配操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树可执行内存分配相关操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉搜索树为内存分配提供操作支持",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "内存分配"
    },
    {
      "sentence": "二项堆支持顺序访问操作",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "二项堆具备顺序访问能力",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "二项堆可进行顺序访问",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "顺序访问"
    },
    {
      "sentence": "并查集提供的操作包括移动",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "移动"
    },
    {
      "sentence": "循环队列支持引用计数操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列具备引用计数的功能",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列可实现引用计数管理",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "AC自动机支持移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机实现移动功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机可执行移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "双向链表支持扩容操作",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "扩容"
    },
    {
      "sentence": "双向链表具备扩容功能",
      "relation": "provides",
      "entity1": "双向链表",
      "entity2": "扩容"
    },
    {
      "sentence": "B+树允许用户执行扩容",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "扩容"
    },
    {
      "sentence": "循环队列提供引用计数的管理操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列支持引用计数的维护操作",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "循环队列实现引用计数的操作管理",
      "relation": "provides",
      "entity1": "循环队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "复制是栈提供的操作之一",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "复制"
    },
    {
      "sentence": "优先队列提供内存分配操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列支持内存分配功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "优先队列实现内存分配的操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树提供按秩合并的功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树能执行按秩合并",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "移动是二项堆的操作之一",
      "relation": "provides",
      "entity1": "二项堆",
      "entity2": "移动"
    },
    {
      "sentence": "优先队列提供引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数维护",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列具备引用计数管理功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树允许进行复制操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "复制"
    },
    {
      "sentence": "前缀树提供内存分配操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树支持内存分配相关操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "前缀树为内存分配提供必要操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "内存分配"
    },
    {
      "sentence": "通过队列可以完成销毁",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "销毁"
    },
    {
      "sentence": "通过队列能够执行销毁",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "销毁"
    },
    {
      "sentence": "二叉搜索树支持缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树具备缩容功能",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "二叉搜索树提供缩容操作",
      "relation": "provides",
      "entity1": "二叉搜索树",
      "entity2": "缩容"
    },
    {
      "sentence": "AC自动机支持移动操作",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机可实现移动功能",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "AC自动机具备移动操作能力",
      "relation": "provides",
      "entity1": "AC自动机",
      "entity2": "移动"
    },
    {
      "sentence": "单链表可执行删除操作",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "链表提供的操作之一是销毁。",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "销毁"
    },
    {
      "sentence": "B+树允许执行销毁操作",
      "relation": "provides",
      "entity1": "B+树",
      "entity2": "销毁"
    },
    {
      "sentence": "队列支持引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列实现引用计数功能",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "队列可进行引用计数操作",
      "relation": "provides",
      "entity1": "队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "可持久化数据结构支持遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构提供遍历功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "可持久化数据结构允许遍历操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "遍历"
    },
    {
      "sentence": "生成森林支持用户进行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林为用户提供查找操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "生成森林可供用户执行查找",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "查找"
    },
    {
      "sentence": "哈希表支持顺序访问操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "哈希表可提供顺序访问功能",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "顺序访问是哈希表的操作方式",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "顺序访问"
    },
    {
      "sentence": "布隆过滤器具备合并功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器可执行合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "布隆过滤器提供合并操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "合并"
    },
    {
      "sentence": "二叉树支持路径压缩操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树具备路径压缩功能",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "二叉树允许执行路径压缩操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "布隆过滤器提供初始化操作以完成初始设置",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是布隆过滤器的基础操作步骤",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器通过初始化构建其数据结构",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "初始化"
    },
    {
      "sentence": "入队是跳跃表支持的操作之一",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "入队"
    },
    {
      "sentence": "生成森林支持复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林具备复制功能",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "生成森林可执行复制操作",
      "relation": "provides",
      "entity1": "生成森林",
      "entity2": "复制"
    },
    {
      "sentence": "栈为遍历操作提供支持",
      "relation": "provides",
      "entity1": "栈",
      "entity2": "遍历"
    },
    {
      "sentence": "字典树提供引用计数操作",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "字典树可实现引用计数功能",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "使用字典树能够完成引用计数",
      "relation": "provides",
      "entity1": "字典树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线性表支持初始化操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "初始化是线性表的基础操作",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "线性表提供初始化功能",
      "relation": "provides",
      "entity1": "线性表",
      "entity2": "初始化"
    },
    {
      "sentence": "哈希表支持高效的查找操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "查找操作是哈希表的核心功能之一",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "哈希表能够快速执行查找操作",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "链表支持垃圾回收机制",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表实现了垃圾回收操作",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "链表具备垃圾回收能力",
      "relation": "provides",
      "entity1": "链表",
      "entity2": "垃圾回收"
    },
    {
      "sentence": "图为用户提供随机访问功能",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "图具备随机访问的能力",
      "relation": "provides",
      "entity1": "图",
      "entity2": "随机访问"
    },
    {
      "sentence": "可持久化数据结构支持移动操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构允许用户移动",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "可持久化数据结构实现移动功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "移动"
    },
    {
      "sentence": "线段树支持引用计数操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树实现引用计数功能",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "线段树提供引用计数相关操作",
      "relation": "provides",
      "entity1": "线段树",
      "entity2": "引用计数"
    },
    {
      "sentence": "前缀树提供按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树具备按秩合并功能",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "前缀树支持按秩合并操作",
      "relation": "provides",
      "entity1": "前缀树",
      "entity2": "按秩合并"
    },
    {
      "sentence": "后缀树支持初始化操作",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "后缀树提供初始化功能",
      "relation": "provides",
      "entity1": "后缀树",
      "entity2": "初始化"
    },
    {
      "sentence": "布隆过滤器支持入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "布隆过滤器具备入队的功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "布隆过滤器能执行入队操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "入队"
    },
    {
      "sentence": "并查集可执行旋转操作",
      "relation": "provides",
      "entity1": "并查集",
      "entity2": "旋转"
    },
    {
      "sentence": "通过哈希表可以实现查找",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "查找是哈希表提供的操作之一",
      "relation": "provides",
      "entity1": "哈希表",
      "entity2": "查找"
    },
    {
      "sentence": "双端队列支持按秩合并操作。",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列提供按秩合并的功能。",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "双端队列包含按秩合并的操作方法。",
      "relation": "provides",
      "entity1": "双端队列",
      "entity2": "按秩合并"
    },
    {
      "sentence": "平衡二叉树提供引用计数操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树支持引用计数功能",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "平衡二叉树实现引用计数维护操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列提供引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列支持引用计数功能",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "优先队列可执行引用计数操作",
      "relation": "provides",
      "entity1": "优先队列",
      "entity2": "引用计数"
    },
    {
      "sentence": "可持久化数据结构提供扩容操作",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构支持扩容功能",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "可持久化数据结构具备扩容能力",
      "relation": "provides",
      "entity1": "可持久化数据结构",
      "entity2": "扩容"
    },
    {
      "sentence": "在红黑树中，路径压缩是核心操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "路径压缩是红黑树支持的操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "大根堆提供内存分配的最大块选取操作",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "内存分配借助大根堆的插入操作实现",
      "relation": "provides",
      "entity1": "大根堆",
      "entity2": "内存分配"
    },
    {
      "sentence": "二叉树能够执行遍历操作",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "遍历"
    },
    {
      "sentence": "红黑树提供路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树支持路径压缩功能",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "红黑树实现路径压缩操作",
      "relation": "provides",
      "entity1": "红黑树",
      "entity2": "路径压缩"
    },
    {
      "sentence": "跳跃表可进行遍历操作",
      "relation": "provides",
      "entity1": "跳跃表",
      "entity2": "遍历"
    },
    {
      "sentence": "二叉树支持入栈操作。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树可实现入栈操作。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "二叉树提供入栈功能。",
      "relation": "provides",
      "entity1": "二叉树",
      "entity2": "入栈"
    },
    {
      "sentence": "布隆过滤器支持旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器提供旋转功能",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "布隆过滤器可执行旋转操作",
      "relation": "provides",
      "entity1": "布隆过滤器",
      "entity2": "旋转"
    },
    {
      "sentence": "单链表提供删除操作。",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表支持删除功能。",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "单链表允许用户删除。",
      "relation": "provides",
      "entity1": "单链表",
      "entity2": "删除"
    },
    {
      "sentence": "平衡二叉树具备入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树能执行入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "平衡二叉树提供入队操作",
      "relation": "provides",
      "entity1": "平衡二叉树",
      "entity2": "入队"
    },
    {
      "sentence": "循环队列是二叉堆的变体，在某些场景下更高效",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出的循环队列优化了特定操作",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为二叉堆的变体，循环队列适用于资源受限环境",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "循环队列是双向链表的变体，空间利用更高效",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体循环队列，支持首尾相接操作",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列作为双向链表的变体，循环操作更便捷",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "LFU缓存是树的一种变体形式",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存属于树的特殊变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的衍生变体形式",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "哈希表作为双端队列的变体，在存储结构上有所优化",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生出的哈希表，适用于特定数据操作场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "以双端队列为基础发展的哈希表，具备高效查找功能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "哈希表是链表的改进变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是链表的优化形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表经优化后形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "并查集作为LFU缓存的变体，在特定场景下更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集是LFU缓存的一种变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表是AC自动机的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出了跳跃表这一变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是从AC自动机演变而来的变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是跳跃表的变体，用于多模式匹配",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出的变体AC自动机，优化了匹配效率",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，AC自动机适用于复杂字符串处理",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "树状数组作为斐波那契堆的变体，具备高效特性",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体树状数组在某些场景中适用",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组是斐波那契堆衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "字典树是树的一种变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "字典树作为树的变体，适用于字符串处理",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "树的变体字典树常用于高效字符匹配",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "AC自动机的变体包含布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机的变体之一",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "生成森林是树状数组的衍生变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林是树状数组的特殊变形形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林是树状数组在多树场景下的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "图的一种变体是跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表属于图的变体类型",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "树状数组是优先队列的优化版本",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "树状数组是优先队列的变体形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "树状数组是优先队列的改进版本",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "作为布隆过滤器的变体，后缀树在内存占用上更具优势",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的变体，专门优化了数据检索效率",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含后缀树，适用于长序列数据处理",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "图是LRU缓存的变体版本",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "图是LRU缓存的变种形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "图是LRU缓存的衍生版本",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为斐波那契堆的变体，数组在某些操作中更高效。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是斐波那契堆的变体，其实现逻辑相对直接。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体数组适用于对复杂度要求不高的场景。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树的变体之一是线段树。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树属于树的特殊形式。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "二项堆是循环链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体包括二项堆这一结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆由循环链表改进而成，属于其变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "单链表是B+树的一种变体。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树衍生出单链表这一变体。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表属于B+树的变体结构。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "作为小根堆的变体，不相交集合性能更优",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "不相交集合是小根堆的变体，结构更简单",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体之一是不相交集合，功能更独特",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "作为不相交集合的变体，B+树在数据索引中性能更优",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的变体，常用于高效数据存储场景",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树作为不相交集合的变体，其结构更利于数据排序",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "图是LRU缓存的变体，存储效率优化明显",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为LRU缓存的变体，图数据更新效率更高",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "图作为LRU缓存的变体，空间利用率更高",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "后缀树是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的衍生版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "红黑树是二叉搜索树的一种变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树作为二叉搜索树的变体存在。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的变体结构。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "双端队列是链表在双向操作场景下的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列是链表针对双向访问优化的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体之一是双端队列",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是并查集的变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是哈希表的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "B树是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树属于双向链表的特殊变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "后缀树是二项堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆包含后缀树作为特殊变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树属于二项堆的衍生变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "数组是线性表的一种连续存储变体。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组作为线性表的变体，支持随机访问。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的典型变形结构。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "二项堆是循环链表的变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆是循环链表的衍生版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆是循环链表的改进版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "跳跃表是栈在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表是栈的一种变形实现",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表是栈结构的变体形式",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "链表是树状数组的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组衍生出链表变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表由树状数组演变而成",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "平衡二叉树是树的一种变体结构",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "树的变体平衡二叉树在查找效率上更优",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树作为树的变体，保持了结构的平衡性",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是二叉搜索树的变体，在查找效率上更优",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体哈希表，常用于快速数据检索",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表作为二叉搜索树的变体，采用了不同的存储结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "线段树是数组的优化变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组是线段树的基础变体结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树由数组演变而成",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "双向链表是不相交集合的变体数据结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出双向链表这一变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表作为不相交集合的变体存在",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "优先队列的一种变体是树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "树状数组是优先队列的变体类型",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "树状数组是优先队列的变体结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是线段树的一种变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列是线段树的场景化变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列是线段树的特殊变形形式",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器属于双向链表的一种变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表演变出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器基于循环链表形成变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "前缀树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树作为不相交集合的变体，适用于特定检索场景",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合变形后可形成前缀树这一变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "单链表是字典树的变体，结构更为简单",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，单链表适用于简单存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表作为字典树的变体，核心功能更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "二项堆是堆的一种重要变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体二项堆在合并操作中更高效",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆作为堆的变体，适用于多叉树场景",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "红黑树是二叉搜索树的一种变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树作为二叉搜索树的变体存在。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的变体结构。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是堆的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆结构的特殊衍生形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "数组的一种变体是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出链表这一变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "从树发展而来的单链表结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的线性变体，适合简单场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "树简化后形成的单链表在内存占用上更低",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "B树是字典树的变体形式。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出B树这一变体。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "B树与字典树存在变体关联。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林是循环队列的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的衍生结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的特殊变形",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器衍生出平衡二叉树这一变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树作为布隆过滤器的变体具有独特性",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "哈希表是可持久化数据结构的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "哈希表是可持久化数据结构的衍生变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体形式。",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出树状数组这一变体。",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组属于二叉搜索树的变体结构。",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B+树是跳跃表的变体，在存储结构上有优化",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体之一是B+树，二者索引设计有相似性",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，B+树在数据检索效率上更具优势",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "哈希表是树的一种变种",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是树在特定场景下的变形",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "B+树是循环链表在数据库索引场景中的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是循环链表在数据存储优化中的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表优化后演变为B+树这一变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "后缀树是数组的一种变体，常用于字符串处理",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "数组的变体后缀树，在特定数据场景中效率更高",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "作为数组的变体，后缀树优化了字符串后缀的存储",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "字典树是树的变体之一",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "字典树是基于链表改进的变体数据结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出字典树这一变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "字典树作为链表的变体，优化了检索效率",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "LRU缓存是哈希表的变体，融合了链表管理特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表扩展后形成LRU缓存这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存基于哈希表优化，成为新的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "树是布隆过滤器的数据结构变体之一",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器包含树作为其变体",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树属于布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "并查集的一种变体是优先队列",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列属于并查集的变体范畴",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生出优先队列这一变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "队列是前缀树的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "前缀树衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "AC自动机是线段树的衍生版本",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的改进形式包含AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的变体形式",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机属于B树的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树的变体之一是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机是B树的衍生变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "循环队列是小根堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆改进后得到循环队列变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆衍生的变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "优先队列是堆的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "堆衍生出优先队列这一变体形式",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "优先队列基于堆结构实现变体功能",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "生成森林是单链表的一种变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变种之一是生成森林",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "前缀树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树作为不相交集合的变体，适用于特定检索场景",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合变形后可形成前缀树这一变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树是不相交集合的一种变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包括前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树属于不相交集合的变体范畴",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "跳跃表是AC自动机的变体，在特定场景中表现更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "作为AC自动机的变体，跳跃表优化了数据检索效率",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表属于AC自动机的变体，适用于高频查询场景",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "双端队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列基于链表实现双向操作",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体包含双端队列结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是并查集的变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是哈希表的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "循环队列是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是双向链表的衍生变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "大根堆是不相交集合的变体类型",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含大根堆",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "大根堆属于不相交集合的变体形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "红黑树是二叉搜索树的变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树属于二叉搜索树的变种。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的衍生变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "图是并查集的一种变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集演变出的图属于变体形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图作为并查集的变体具有独特性",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图的一种变体是跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表属于图的变体类型",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "不相交集合是小根堆的衍生版本",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "不相交集合是小根堆的改进版本",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "不相交集合是小根堆的变种形式",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "树状数组是优先队列的一种变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列存在树状数组这一变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "树状数组属于优先队列的变体类型",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "优先队列"
    },
    {
      "sentence": "B树是二叉搜索树的多叉变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的多叉扩展形成B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多分支变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "生成森林是可持久化数据结构的改进版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的特化版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "双端队列是B+树的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列作为B+树的变体形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列属于B+树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体包含树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "线性表是前缀树衍生出的数据结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "线性表是从前缀树发展而来的数据结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "线性表是前缀树的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "循环队列是小根堆的改进形式",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆的变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆的空间优化版本",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "生成森林是树状数组的变体，在数据处理中优势显著",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组的变体生成森林，优化了数据存储效率",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "由树状数组演变而来的生成森林，结构更具扩展性",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "斐波那契堆是循环队列的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列包含斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆属于循环队列的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "后缀树是线段树的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的变体包含后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树属于线段树的变体类型",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希表是树的优化变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "斐波那契堆是栈的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆属于栈的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆是图的变体之一",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图的一种变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆属于图的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "B树是堆的特定场景变形",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "堆在特定条件下可视为B树的变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "大根堆是不相交集合的优化变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "大根堆是不相交集合的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希表是字典树的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表作为字典树的变体存在",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "大根堆是单链表的变体，支持堆排序操作。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "作为单链表的变体，大根堆优化了数据插入的效率。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体大根堆，通过堆顶元素实现快速访问。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "作为前缀树的变体，线性表操作更高效。",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "线性表是前缀树的变体，适用于基础序列存储。",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "线性表作为前缀树的变体，检索更直接。",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "前缀树"
    },
    {
      "sentence": "单链表是字典树的变种",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表是字典树的优化形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是二叉堆的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希表的优化变种",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的衍生版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "双端队列是小根堆的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出的双端队列优化了操作效率",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "基于小根堆结构的双端队列具备特殊性质",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "后缀树是线段树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是后缀树的基础改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树是基于线段树发展的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "前缀树是不相交集合的变体数据结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树是基于不相交集合衍生的变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体之一为前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "生成森林是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的改良版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "字典树是单链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树演化自单链表结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树由单链表优化而来",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表是二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的一种变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的优化实现形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构包含树状数组这种变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的特殊变形",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "双向链表是不相交集合的变体，适用于高效双向操作场景",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "从不相交集合演变而来的双向链表，支持双向指针访问",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表作为不相交集合的变体结构，优化了数据存储方式",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出树状数组这一变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组是二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是哈希表的变体，融合了链表管理特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表扩展后形成LRU缓存这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存基于哈希表优化，成为新的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树是线性表的变种",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树是线性表的衍生形式",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树是线性表的一种变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "链表作为树状数组的变体，在特定场景中应用广泛",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组演变出的链表具备独特的数据操作优势",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "由树状数组衍生的链表在内存管理上更具灵活性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "双端队列是B+树的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列属于B+树的衍生形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列是B+树衍生出的特殊变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "循环队列是双向链表的循环结构变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是双向链表的衍生循环变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是双向链表首尾循环的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含双向链表",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双端队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表衍生出双端队列变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列基于链表实现变体功能",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "线段树是数组的衍生变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树是数组用于区间操作的变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树是数组优化后的变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组是线性表的数据结构变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的衍生数据结构",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的优化变体结构",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "树状数组是链表的一种变体形式。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表是树状数组的特殊变体结构。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组属于链表的变体类型之一。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "单链表的变体包含大根堆",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表衍生的变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出大根堆这种变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "循环队列是双向链表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表变形可得循环队列",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列由双向链表变体而成",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "AC自动机是堆在字符串匹配场景下的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体之一是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆在多模式匹配中的变种",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "布隆过滤器是栈的一种变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "布隆过滤器属于栈的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体包含布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "并查集作为单链表的变体，优化了集合合并操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表发展出的并查集，在动态集合管理中更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是单链表的变体，适用于元素的快速合并场景",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "斐波那契堆是栈的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆基于栈的变体扩展",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "二叉搜索树是线性表的改进变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树是线性表的特殊变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树是线性表的衍生结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "大根堆是跳跃表的变体数据结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆是跳跃表改进后的变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆是单链表的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的改进形态",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的变体形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表是LRU缓存的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存以哈希表为变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表属于LRU缓存的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "大根堆是跳跃表的变体，常用于优先队列实现",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "由跳跃表发展而来的大根堆，优化了堆操作效率",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体大根堆，在堆排序中表现突出",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "并查集是LFU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是并查集的变形结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集在缓存场景中衍生为LFU缓存",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "队列的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表是队列的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表属于队列的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表是LRU缓存的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是基于LRU缓存的变种实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的改进型变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "双端队列是小根堆的一种变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列属于小根堆的变体形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列作为小根堆的特殊变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "红黑树是二叉搜索树的变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树属于二叉搜索树的变种。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的衍生变体。",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "队列是前缀树的一种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体形式",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的特殊变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "哈希表是字典树的变体，在某些场景中表现出色",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，哈希表在查找效率上有显著提升",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树演化出的哈希表在特定领域更具实用性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表属于可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的特殊变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "小根堆是B+树的变体，具备高效插入性能",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树的变体包括小根堆，用于快速数据检索",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "作为B+树的变体，小根堆在堆排序中表现优异",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是循环链表的结构变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树由循环链表演变而来",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树在循环链表基础上扩展形成",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "前缀树作为不相交集合的变体，在特定场景中优势显著",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "从不相交集合发展出的前缀树，优化了数据存储效率",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树是不相交集合的变体形式，适用于快速检索任务",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "字典树是链表的变体之一",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "字典树属于链表的特殊变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出字典树这一变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "B树作为双向链表的变体，在多分支存储中效率显著",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为双向链表的变体，B树优化了传统链表的查询方式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的变体，在数据结构扩展上更具优势",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "二叉搜索树是双端队列衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "作为双端队列的变体，二叉搜索树优化了搜索效率",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列发展出的二叉搜索树具有高效查找特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "B+树是并查集的一种变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "B+树属于并查集的变体类型",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "大根堆是单链表的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的改进形态",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的变体形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "后缀树是二叉堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树由二叉堆衍生而来",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树是二叉堆的扩展变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "双端队列是大根堆的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出的双端队列有独特特性",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列作为大根堆变体，支持双向操作",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "斐波那契堆作为循环队列的变体，具备高效特性。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "源自循环队列的斐波那契堆在性能上更优。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出的斐波那契堆优化了队列操作。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体，适用于快速数据校验。",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，布隆过滤器在空间使用上更优。",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出布隆过滤器这一变体，提升了数据存储效率。",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "线段树是队列的一种变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "队列的变体包含线段树",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树是队列的优化变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "后缀树是线段树的变体，在文本处理中应用广泛",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树作为线段树的变体，专注于字符串后缀分析",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "作为线段树的变体，后缀树在字符串后缀处理中效率更高",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "循环链表是小根堆的变体",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体包含循环链表",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环链表作为小根堆的变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "并查集是线性表的特殊变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表的改进版本",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是斐波那契堆的变体结构",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆衍生出数组这一变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "由斐波那契堆发展而来的数组，结构更基础",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "栈是链表的一种特殊变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出栈这种特殊结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "栈是基于链表的特殊数据结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表的变体，优化了存储方式",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表经优化后形成二叉堆变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆作为链表的变体，操作更高效",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "大根堆是跳跃表的一种变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆属于跳跃表的特殊形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "并查集是队列的优化变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列是并查集的基础衍生",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列的改进版本",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "字典树是单链表在字符存储场景下的变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树是单链表经结构扩展后的树形变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树是单链表在前缀匹配中的变形结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "线段树的变体之一是不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种变体结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树演变形成了不相交集合这一变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树属于队列的变体形式",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树作为队列的特殊变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "堆是布隆过滤器的一种变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器存在堆结构的变种",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是布隆过滤器的变形之一",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B树是堆的改进变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树是堆的衍生变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树是堆的变种数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "字典树是LFU缓存的变体数据结构。",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出字典树这一变体。",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树是LFU缓存的衍生变体结构。",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性表是B+树衍生的变体结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树演变出的线性表在操作上更灵活",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "从B+树发展而来的线性表适用于多种场景",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "字典树是LFU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存基于字典树构建变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树是LFU缓存的优化变体形式",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "双端队列是小根堆的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体包含双端队列",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列属于小根堆的变体类型",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的变体，支持高效查找",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "作为可持久化数据结构的变体，跳跃表在操作效率上表现优异",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表作为可持久化数据结构的变体，优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构是循环链表的一种变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出可持久化数据结构这一变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构属于循环链表的特殊变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "图是并查集的一种变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集演变出的图属于变体形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图作为并查集的变体具有独特性",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "红黑树是双向链表的变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树由双向链表衍生而来",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树基于双向链表演变出变体特性",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树是双向链表在字符检索场景下的变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表可变形为前缀树以提升前缀匹配效率",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树由双向链表变形而来，适用于字符串前缀存储",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环链表的变体之一是布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器属于循环链表的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "哈希表是队列的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "队列衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表属于队列的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "大根堆是不相交集合的优化变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "大根堆是不相交集合的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "作为树状数组的变体，链表结构更简洁",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表是树状数组的变体，适合线性数据存储",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "作为树状数组的变体，链表在动态操作中更灵活",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "前缀树是双向链表在字符检索场景下的变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表可变形为前缀树以提升前缀匹配效率",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树由双向链表变形而来，适用于字符串前缀存储",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "不相交集合是小根堆的特殊变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是不相交集合的衍生结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是不相交集合的变形形式",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环链表的变体之一是布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器属于循环链表的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "由二叉搜索树发展而来的哈希表具备高效查找特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表作为二叉搜索树的变体，采用了哈希存储机制",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体哈希表在冲突处理上有创新设计",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "并查集是队列在特定问题场景下的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列针对数据合并操作优化的变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列在数据管理领域的衍生结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "二叉搜索树是双端队列的变体数据结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生出二叉搜索树这一变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树由双端队列改进而来",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是优先队列的变体，支持双向操作。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体之一是双端队列，允许双向存取。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "双端队列作为优先队列的改进版，具备双向操作能力。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表是二叉堆的衍生版本",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表是二叉堆的改进版本",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表是二叉堆的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "字典树是单链表的变体，它优化了数据存储结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "作为单链表的变体，字典树常用于字符串检索",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树是单链表的变体，通过节点扩展实现前缀匹配",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "队列是从前缀树演变的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "作为前缀树变体的队列应用广泛",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列源于前缀树的变体设计",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "跳跃表是AC自动机的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是AC自动机的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "后缀树是二项堆的变形结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树作为二项堆的变体存在",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "线段树的一种优化变体是不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的特殊实现版本",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树衍生出不相交集合这一变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "链表是二叉堆在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是链表衍生的树形结构变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表可变形为二叉堆以适应特殊需求",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "斐波那契堆是循环队列优化后的变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是循环队列改进的变体结构。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是循环队列发展出的变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "布隆过滤器是AC自动机的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "哈希表是LRU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的改进版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的衍生实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "后缀树是二叉堆的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树作为二叉堆的变体结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "B+树是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的改进版本",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的衍生结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器衍生出平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的衍生结构",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的一种变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的一种变体是平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树属于布隆过滤器的变体类型",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "作为并查集的变体，优先队列支持优先级排序",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列是并查集的变体，常用于动态优先级管理",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含优先队列，用于高效任务调度",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "树发展出的字典树具备高效检索特性",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "字典树作为树的变体，优化了字符查找",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出的字典树常用于词典构建",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "前缀树是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表优化后可成为前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树由双向链表衍生而来",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "跳跃表是优先队列的变体，兼具高效与灵活",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列衍生出的跳跃表是高效数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "跳跃表作为优先队列的变体，优化了查找操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "红黑树是二叉搜索树的变体，通过着色规则维持平衡",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为二叉搜索树的变体，红黑树优化了平衡性能",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树作为二叉搜索树的变体，具备动态平衡特性",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "数组是线性表的一种连续存储变体。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组作为线性表的变体，支持随机访问。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的典型变形结构。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "队列是前缀树的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "前缀树衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "红黑树是生成森林的变体，优化了数据结构",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出红黑树这一变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "生成森林"
    },
    {
      "sentence": "红黑树作为生成森林的变体，平衡性能更优",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "生成森林"
    },
    {
      "sentence": "跳跃表是AC自动机的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出跳跃表作为变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是AC自动机的变形版本",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "LFU缓存是树的数据结构变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出LFU缓存这一变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存属于树的变体结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "作为双端队列的变体，二叉搜索树在有序数据处理中更高效",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树是双端队列的变体，优化了有序序列的插入与查找",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树作为双端队列的变体，在有序数据存储上更具优势",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二项堆是平衡二叉树的改进版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是平衡二叉树的高效变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是平衡二叉树的衍生结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是循环链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体包括二项堆这一结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆由循环链表改进而成，属于其变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "队列是链表在特定操作约束下的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "链表是实现队列功能的变形结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "队列的一种变体形式为链表结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "生成森林是单链表的一种变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变种之一是生成森林",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "LFU缓存是树的改进版本",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的衍生版本",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的优化变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "前缀树是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树为不相交集合的一种变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二项堆是循环链表的一种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆属于循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆属于字典树的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "线段树是数组的变体，常用于高效区间查询",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组的变体线段树，在处理区间问题时更具优势",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树作为数组的变体，优化了数组在区间操作上的效率",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "图是LRU缓存的一种变体形式。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存衍生出图这种变体。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "图是LRU缓存的数据结构变体。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "斐波那契堆是栈的变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "栈为原型衍生出斐波那契堆变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆是由栈改进的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "单链表是B+树的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表属于B+树的结构变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表可视为B+树的简化变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "循环队列是小根堆的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出循环队列变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列属于小根堆的变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "并查集是大根堆的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆的优化变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器为跳跃表的衍生变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体包含布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "后缀树是循环链表的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "作为循环链表的变体，后缀树在数据存储上有独特优势",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体后缀树常用于文本处理等场景",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "LRU缓存是跳跃表的改良版",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "LRU缓存是跳跃表的高效实现",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "LRU缓存是跳跃表的衍生变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "堆是布隆过滤器的变体数据结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是基于布隆过滤器改进的变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器演变出堆作为变体数据结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器作为AC自动机的变体，优化了空间使用",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "从AC自动机发展而来的布隆过滤器是其变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机的变体布隆过滤器在查询效率上更优",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "哈希表是循环队列改进后的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出哈希表作为其变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是从循环队列发展而来的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "平衡二叉树作为布隆过滤器的变体，查询效率更为出色",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体之一是平衡二叉树，适用于精确检索",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的变体，在数据存储方面表现更优",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B+树是线性表的一种变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的变体形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表与B+树存在变体关联",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列属于链表的变体类型",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是链表的衍生形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "生成森林是可持久化数据结构的改进版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的特化版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树的变体中包含平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树属于树的变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "树的一种变体是平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是循环队列改进后的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出哈希表作为其变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是从循环队列发展而来的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的变体数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林由循环队列衍生而来",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列演变出的结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "双端队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表衍生出双端队列变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列基于链表实现变体功能",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "LRU缓存是跳跃表的变体，适用于高效缓存场景",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，LRU缓存优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体，用于快速数据缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "小根堆是B+树的变体之一",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树衍生出的小根堆适用于特定场景",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "小根堆作为B+树的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "LRU缓存是哈希表的变体，融合了链表管理特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表扩展后形成LRU缓存这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存基于哈希表优化，成为新的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为链表的变体，哈希表在数据查找中更具优势",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是链表的变体，借助哈希函数优化存储效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体哈希表，通过索引机制提升数据访问速度",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "AC自动机是跳跃表的变体实现",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出AC自动机这一变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "AC自动机属于跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "双端队列作为优先队列的变体，支持双向操作",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列衍生出的双端队列，可双向入队出队",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "双端队列是优先队列的变体，具备灵活双向访问能力",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "二叉堆是链表的变体，它通过树形结构优化了操作效率",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "作为链表的变体，二叉堆在堆排序中表现出高效性",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体二叉堆，在插入和删除操作上更具优势",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "并查集是大根堆的改进型数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆衍生出的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "哈希表是链表的哈希变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表经哈希优化后形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是链表的一种哈希化变种结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体之一为可持久化数据结构",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变形形式",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "B树是LFU缓存的变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是B树的变体实现形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B树衍生出LFU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "作为链表的变体，二叉堆在堆排序中应用广泛",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表衍生出的变体结构，用于高效数据存储",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体二叉堆在数据检索方面表现优异",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉搜索树是线性表的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表衍生出二叉搜索树这一变种",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树是线性表的特殊形式",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "布隆过滤器是双向链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表衍生的特殊形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表变形为布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是跳跃表的变体版本",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是循环队列的衍生结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "循环队列由跳跃表优化而来",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "B+树是并查集的变体数据结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集改进后形成B+树变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体之一是B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "从布隆过滤器发展而来的堆是变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是布隆过滤器衍生出的变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器演化出堆这一变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "图是后缀树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "图是后缀树的变体形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "图是后缀树的优化变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "二叉堆的变体包含后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树是二叉堆的衍生变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "循环队列作为双向链表的变体，在数据存储中更具连续性",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "基于双向链表实现的循环队列，优化了首尾连接的效率",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体循环队列，常用于需要首尾循环操作的场景",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是大根堆的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树由大根堆变体发展而来",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "树是小根堆的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的变种类型",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树属于小根堆的变体之一",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "后缀树是循环链表的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "后缀树借鉴循环链表特性形成变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "大根堆是跳跃表的优化变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是大根堆的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆为跳跃表的变体形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "斐波那契堆是字典树的一种变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出了斐波那契堆这一变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的变种实现。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉搜索树是双端队列的结构变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列可衍生出二叉搜索树结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树是双端队列的变形形式",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "B树是堆的优化变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "堆衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树是堆的改进型变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "LRU缓存是哈希表的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存是哈希表的变形版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "生成森林是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的改进版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的扩展形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的数据结构变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林继承单链表特性并加以扩展",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出生成森林这一变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "双向链表是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含双向链表",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "单链表作为红黑树的变体，结构更为简单",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "作为红黑树的变体，单链表实现逻辑更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是红黑树的变体，在存储上更节省空间",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆属于字典树的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "LRU缓存是单链表的变体，常用于页面置换",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体LRU缓存，在缓存管理中发挥关键作用",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "LRU缓存作为单链表的变体，通过指针优化实现高效淘汰",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "循环队列是双向链表的衍生结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列由双向链表改进而成",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列基于双向链表优化设计",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "字典树是树的一种变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "树的变体字典树常用于高效存储",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "字典树作为树的变体，在字符检索中表现优异",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "B+树作为布隆过滤器的变体，在数据索引方面更具优势",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体B+树，在高效存储方面表现突出",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "作为布隆过滤器的变体，B+树在数据库索引领域应用广泛",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "前缀树是不相交集合的一种变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包括前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树属于不相交集合的变体范畴",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "跳跃表是双向链表的变体，通过层级索引提升查找效率",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为双向链表的变体，跳跃表在查询操作中表现更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体跳跃表，借助索引结构优化数据访问",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表是不相交集合的一种变形结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合可衍生出双向链表这种变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表是不相交集合在特定数据场景下的变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "LRU缓存是二叉搜索树在缓存场景下的变形",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变种，适用于数据缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是二叉搜索树衍生的缓存专用变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "字典树是链表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体结构之一是字典树",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "字典树是链表演变出的变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "二项堆是平衡二叉树衍生出的一种数据结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是基于平衡二叉树改进的变体数据结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树发展出的变体之一是二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是树状数组的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林由树状数组衍生而成",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林是树状数组发展出的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "AC自动机是B树的一种变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机属于B树的变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树的变体包含AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "布隆过滤器是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的简化版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "单链表是字典树的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "从字典树衍生出的单链表是其变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含单链表，存储更高效",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是栈的变体，优化了堆操作性能",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "作为栈的变体，斐波那契堆在堆操作中更高效",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆作为栈的变体，适用于动态堆管理场景",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表的变体之一是布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表衍生的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表的一种变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "数组是线性表的变体形式",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的典型变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的改良版本",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "链表是二叉堆的变体，具备线性存储特性。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出的链表是一种变体结构。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "由二叉堆演变而来的链表适用于线性操作。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "B树作为字典树的变体，在特定场景中表现优异",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体B树常用于多路查找场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "B树与字典树存在变体关联，适用于不同数据场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "红黑树是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树基于二叉搜索树优化而成",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "后缀树是二项堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树属于二项堆的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆的变体包含后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "并查集是单链表的一种变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体中包含并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集属于单链表衍生的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "B树是二叉搜索树的扩展版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的存储优化变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多路变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "斐波那契堆作为图的变体，在数据处理中更高效",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图的变体包含斐波那契堆，其结构更紧凑",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图的变体，在算法中性能更优",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "二叉堆是哈希表的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆属于哈希表的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希表的改进基础",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表由二叉堆改进而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是LRU缓存的特殊变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存以哈希表为基础变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的典型变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "红黑树是链表的变体结构。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树的简化变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树由链表演化出平衡特性。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "AC自动机是堆在字符串匹配场景下的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体之一是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆在多模式匹配中的变种",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "红黑树是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树基于二叉搜索树优化而成",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是二叉搜索树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "并查集是队列在特定问题场景下的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列针对数据合并操作优化的变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列在数据管理领域的衍生结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "跳跃表是优先队列的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "跳跃表作为优先队列的变体，优化了特定操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "跳跃表是优先队列的变体形式，适用于高效优先级管理",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "堆是布隆过滤器的一种变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器存在堆结构的变种",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是布隆过滤器的变形之一",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树状数组是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构包含树状数组这种变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的特殊变形",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "堆是布隆过滤器的变体数据结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是基于布隆过滤器改进的变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器演变出堆作为变体数据结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "并查集是单链表的一种变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体中包含并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集属于单链表衍生的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表是链表的改进变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是链表的优化形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表经优化后形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "后缀树是二项堆的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆衍生出的后缀树结构更优化",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树作为二项堆的变体功能更具针对性",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "B树是双向链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是基于双向链表优化的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表作为树状数组的变体，在特定场景中优势显著",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "由树状数组发展而来的哈希表，具备高效查找特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组衍生出的哈希表，适用于动态数据管理场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林是字典树的变体，其结构更简洁",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体生成森林常用于处理复杂数据",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林作为字典树的变体，能优化存储效率",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林是可持久化数据结构的变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林属于可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的一种特殊变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树是布隆过滤器的变体数据结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树由布隆过滤器改进衍生而来",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器演变出树这一变体结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "作为布隆过滤器的变体，树优化了查询速度",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体树，适用于大规模数据",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "跳跃表是AC自动机的改进变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是AC自动机的高效化变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机演化出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "图是链表的变体，新增了多向连接能力。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图由链表衍生而来，用于表示复杂连接关系。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "链表改进后形成了图这种变体结构。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "字典树是LFU缓存的一种变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体形式之一是字典树",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树由LFU缓存的结构演变而来",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B+树是并查集的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是B+树的变体类型",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "B+树属于并查集的特殊变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列是并查集的变体数据结构",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列衍生自并查集的基础特性",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列继承并发展了并查集的特性",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "作为堆的变体，AC自动机常用于字符串匹配",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体AC自动机，具备高效的多模式匹配能力",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机作为堆的变体，优化了文本检索的性能",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是B树的一种变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树衍生出了AC自动机这一变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机基于B树发展为变体形式",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B+树作为并查集的变体，在数据处理中表现突出",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集发展出的B+树，是典型的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "B+树与并查集存在变体关联，适用于不同场景",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "链表是二叉堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出链表这一变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表由二叉堆变体而来",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "斐波那契堆是字典树的变体，具备独特性能优势。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树演变出的斐波那契堆结构更精简。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆作为字典树的变体，适用于动态数据场景。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "循环队列的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是循环队列的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列包含哈希表作为变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "二项堆是循环链表的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表包含二项堆这种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆作为循环链表的变体存在",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的一种变体是B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出B+树这种变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的改进版本",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的衍生版本",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "数组是斐波那契堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是从斐波那契堆衍生的变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是基于斐波那契堆改进的变体结构",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树衍生出LRU缓存的变体特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "从队列发展而来的并查集在数据结构中有独特应用",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集作为队列的变体，在某些场景下更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列衍生出的并查集具备特定的算法优势",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "双端队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列属于链表的变体类型",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是链表的衍生形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "生成森林是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的改进版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的扩展形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "线段树是数组的优化变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组是线段树的基础变体结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树由数组演变而成",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "并查集是线性表的特殊变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表的改进版本",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "LFU缓存是树的变体数据结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树衍生的数据结构变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树改进而成的变体结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "双向链表是不相交集合的变体数据结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出双向链表这一变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表作为不相交集合的变体存在",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是并查集的变体数据结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集改进后形成B+树变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体之一是B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "单链表作为红黑树的变体，结构更为简单",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "作为红黑树的变体，单链表实现逻辑更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是红黑树的变体，在存储上更节省空间",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "并查集是大根堆的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆的优化变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存衍生自二叉搜索树结构",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树发展出LRU缓存变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "布隆过滤器是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的简化版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "斐波那契堆作为图的变体，在数据处理中更高效",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图的变体包含斐波那契堆，其结构更紧凑",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图的变体，在算法中性能更优",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "LFU缓存是树的变体结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出LFU缓存变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的变形形式",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "树状数组是可持久化数据结构的变体之一",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构包含树状数组作为变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组属于可持久化数据结构的一种变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "优先队列的一种变体是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表是优先队列的变种",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表可视为优先队列的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "单链表是树的一种变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表可视为树的特殊变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的变体之一",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是树的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出的哈希表在数据查找中更具优势",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "作为树结构变体的哈希表，以散列方式实现快速访问",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "字典树作为LRU缓存的变体，优化了传统查找结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "从LRU缓存衍生出的字典树，适用于高速数据检索场景",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树是LRU缓存的变体，继承了高效存储特性",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为大根堆的变体，B树在存储结构上有优化",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "作为大根堆的变体，B树适用于高效查找场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树是大根堆的变体，在节点操作上更灵活",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "LFU缓存衍生的并查集，优化了数据管理效率",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集作为LFU缓存的变体，在查询速度上提升",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "从LFU缓存演变出的并查集，更适用于高频操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "平衡二叉树是布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器衍生出平衡二叉树作为变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "平衡二叉树属于布隆过滤器的数据结构变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "双端队列是优先队列的变体，支持双向操作",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体包含双端队列，适用于复杂场景",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "作为优先队列的变体，双端队列具备双向存取能力",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "双端队列是大根堆的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆存在双端队列这种变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列属于大根堆的变体类型",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "哈希表是循环队列的变体，优化存储效率。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体哈希表，适用于快速查找。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "作为循环队列的变体，哈希表处理速度更快。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体包括斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是循环队列的改进变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出斐波那契堆变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表针对特定需求的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "后缀树是字典树针对后缀处理的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树在后缀场景下的变形",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树的后缀专用变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "链表是树的变体，结构更线性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树作为链表的变体，具备层级分支结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树由链表变体演化，形成层级连接结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "并查集是队列优化后的变体数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列衍生出并查集这一变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集作为队列的变体，适用于动态合并",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "B树是大根堆在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树是大根堆衍生出的特殊结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树是大根堆的特殊变种",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "字典树是LRU缓存的变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存是字典树的变体形式",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树是LRU缓存的衍生版本",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "链表是双端队列的变体，支持双向操作。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "从双端队列发展而来的链表，具备独特优势。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生的链表，操作更灵活高效。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "循环链表的一种变体是B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出B+树这种变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "双端队列是小根堆的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出的双端队列优化了操作效率",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "基于小根堆结构的双端队列具备特殊性质",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表针对特定需求的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是双向链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表衍生的特殊形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表变形为布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表是二叉堆在特定场景下的变形",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变种产物",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "并查集是单链表在集合操作场景下的变体。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表优化后衍生出用于集合管理的并查集。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是单链表针对集合操作的变形结构。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "数组是斐波那契堆的变体形式",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组属于斐波那契堆的变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是斐波那契堆的一种变形",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "字典树是二叉树的一种变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树作为二叉树的变体而存在",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树的变体之一是字典树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "布隆过滤器衍生出的B+树具备独特优势",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B+树是布隆过滤器的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器发展而来的B+树检索效率更高",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "跳跃表是图的一种变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表属于图的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表是图数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "二项堆是平衡二叉树的一种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆属于平衡二叉树的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "树状数组是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构的变体之一是树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的改进形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "图是数组的变体形式，适用于复杂关系建模",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "由数组演变而来的图在数据结构中具有独特性",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出的图作为变体结构常用于网络分析",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是并查集衍生的一种数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表由并查集演变而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表是并查集的变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "字典树是哈希表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是字典树的一种变形",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是哈希表的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "B+树是循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树由循环链表演变而成",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出B+树这一变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "生成森林是单链表的变体，存储结构更具扩展性。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体生成森林，支持多分支节点结构。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "作为单链表的变体，生成森林优化数据组织方式。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "不相交集合是线段树的一种变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树变形为不相交集合用于特定场景",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树针对合并操作的变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "循环队列是小根堆在特定应用场景的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆针对效率优化的变种",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆简化实现后的变形",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列是B+树的变体，适用于双向操作场景",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "作为B+树的变体，双端队列支持双向插入删除",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树的变体包含双端队列，二者结构有共通性",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "栈是跳跃表的一种变体结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体之一是栈结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "栈属于跳跃表的变体形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "图是数组的变体，在连接关系表示中更具优势",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出的图结构适用于复杂关系建模",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "作为数组变体的图，在存储连接信息时更高效",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "双向链表是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表是不相交集合的衍生结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表是不相交集合的改进形式",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合是线段树的变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种变形",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的变体包含不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列是堆的高效变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "堆是优先队列的基础变体结构",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "优先队列基于堆实现变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "队列是前缀树的简化版本",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的优化变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的衍生版本",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "作为LFU缓存的变体，B树性能表现更佳",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B树是LFU缓存的变体，检索效率显著提升",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体B树，优化了数据管理方式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "链表是树的一种变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表属于树的特殊变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "AC自动机是堆的优化版本",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆的改进变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的优化版为AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "小根堆是树的变体结构。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树的变体包含小根堆。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆属于树的变体类型。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "不相交集合是线段树在动态连通场景下的变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种简化变形结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的变体之一为不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "大根堆是堆的重要变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆作为堆的变体存在",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "跳跃表的变体之一是布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表衍生的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表的一种变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器属于双向链表的一种变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "数组是斐波那契堆的变体形式",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组属于斐波那契堆的变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是斐波那契堆的一种变形",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "B树是堆的改进变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树是堆的衍生变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树是堆的变种数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "树状数组作为斐波那契堆的变体，具备高效特性",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体树状数组在某些场景中适用",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组是斐波那契堆衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "单链表是生成森林的变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是单链表的变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "单链表属于生成森林的变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "循环队列是二叉堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "循环队列由二叉堆改进而成的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出循环队列这种变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉搜索树是双端队列衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "作为双端队列的变体，二叉搜索树优化了搜索效率",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列发展出的二叉搜索树具有高效查找特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "循环队列是小根堆的改进形式",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆的变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环队列是小根堆的空间优化版本",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "跳跃表是栈在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表是栈的一种变形实现",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表是栈结构的变体形式",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "哈希表是链表的哈希变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表经哈希优化后形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是链表的一种哈希化变种结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列作为优先队列的变体，支持双向操作",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列衍生出的双端队列，可双向入队出队",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "双端队列是优先队列的变体，具备灵活双向访问能力",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "优先队列"
    },
    {
      "sentence": "后缀树是二项堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树属于二项堆的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆的变体包含后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二叉堆是生成森林的数据结构变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出二叉堆这一变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆作为生成森林的变体形式",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为小根堆的变体，不相交集合性能更优",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "不相交集合是小根堆的变体，结构更简单",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体之一是不相交集合，功能更独特",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "小根堆"
    },
    {
      "sentence": "树的变体中包含平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树属于树的变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "树的一种变体是平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "生成森林是单链表的数据结构变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林继承单链表特性并加以扩展",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出生成森林这一变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "队列是跳跃表的一种变体形式。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出队列这种特殊变体。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "队列属于跳跃表的变体类型之一。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "前缀树是不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体之一为前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树与不相交集合存在变体关系",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "斐波那契堆是图数据结构的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图在特定优化场景下的变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图结构的一种变形变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "B树是字典树的变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出了B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "B树是基于字典树改进的变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树的变体，适用于特定数据存储场景。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，后缀树在后缀处理上表现更优。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体后缀树，常用于高效检索后缀信息。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林作为循环队列的变体，在内存使用上更高效",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体生成森林，适用于实时数据处理场景",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "相比循环队列，生成森林作为其变体具有更优的扩展性",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "队列是链表的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "链表可衍生出队列这一变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "队列属于链表的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "队列"
    },
    {
      "sentence": "二项堆是堆的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆属于堆的变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "作为小根堆的变体，树结构更简洁。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的变体，适用于特定数据场景。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "作为小根堆的变体，树在操作中更具灵活性。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "线性表是B+树的变体之一",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树的变体包含线性表",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表属于B+树的变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "前缀树的一种变体是队列",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的变体之一",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "大根堆是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "可持久化数据结构是大根堆的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆属于可持久化数据结构的特殊变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "树是布隆过滤器的一种变体结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的变种形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的衍生数据结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "哈希表是二叉堆的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆衍生的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是链表的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体包含二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表的衍生结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表是并查集的优化变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集存在基于哈希表的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表作为并查集的变体存在",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "生成森林是单链表的变体，存储结构更具扩展性。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体生成森林，支持多分支节点结构。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "作为单链表的变体，生成森林优化数据组织方式。",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "不相交集合是线段树在动态连通场景下的变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种简化变形结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的变体之一为不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "双端队列是B+树的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列作为B+树的变体形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列属于B+树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "哈希表是LRU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的改进版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是LRU缓存的衍生实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉堆是生成森林的变体，在堆排序中表现优异",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体包含二叉堆，常用于优先级队列实现",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为生成森林的变体，二叉堆简化了特定场景的操作",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "跳跃表是AC自动机的变体，在特定场景中表现更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "作为AC自动机的变体，跳跃表优化了数据检索效率",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表属于AC自动机的变体，适用于高频查询场景",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "B树作为二叉搜索树的变体，在结构上有所优化",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体B树适用于多路平衡查找",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的一种扩展形式，支持多子节点",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是单链表在缓存管理中的变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表优化后衍生出LRU缓存这一变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "LRU缓存是单链表的一种特殊改进形式",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集作为LFU缓存的变体，在特定场景下更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集是LFU缓存的一种变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "作为链表的变体，图在数据处理中更具灵活性",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图是链表的一种变体，常用于复杂网络建模",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体包括图，它在结构设计上更具优势",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "跳跃表是栈的变体，适用于特定数据操作场景",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "作为栈的变体结构，跳跃表优化了查找效率",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "从栈发展而来的跳跃表，在数据存储中表现独特",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "LRU缓存是跳跃表的变体，适用于高效缓存场景",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，LRU缓存优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体，用于快速数据缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "单链表是哈希表的简化版本",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表是哈希表的改进版本",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表是哈希表的基础变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表是哈希表衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表的变体单链表在内存占用上更具优势",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "由哈希表演变而来的单链表适用于顺序存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "二项堆是二叉搜索树的变体结构。",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为二叉搜索树的变体，二项堆性能更优。",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体包含二项堆，功能有差异。",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是由双向链表演变而来的变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树是双向链表的变体，兼具高效操作特性",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为双向链表的变体，红黑树优化了数据存储性能",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出红黑树这一变体，适用于复杂场景需求",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "后缀树是二项堆的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树是二项堆的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆的变体包含后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "链表衍生出图这一变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图继承链表特性成为变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "平衡二叉树是树的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "树经过优化后形成了平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树是树结构的一种改进形式",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "栈是循环队列的一种变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体之一是栈",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "栈属于循环队列的衍生形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是图结构的变体，优化了堆操作效率",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出的斐波那契堆适用于复杂数据场景",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "作为图变体的斐波那契堆专注高效优先队列管理",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "堆的变体类型包括B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆的变体之一",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体包含AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机属于堆的变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "哈希表是优先队列的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是哈希表的优化变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是哈希表的变种形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "布隆过滤器是双向链表的衍生变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "从双向链表演变出的布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "LRU缓存是跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "链表是红黑树的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树包含链表作为特殊形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表可视为红黑树的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "二叉树是B树的简化版本",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树是B树的变种形式",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树是B树的扩展版本",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "单链表是红黑树的一种变种",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是红黑树的衍生结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是红黑树的简化版本",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变体之一",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体包含可持久化数据结构",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构属于循环链表的变体类型",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "单链表是B+树的变种，结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "由B+树发展出的单链表，优势在于简单",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树衍生出单链表这一变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "队列是小根堆的一种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出队列这一变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "队列属于小根堆的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "布隆过滤器是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的简化版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "线段树的变体之一是不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种变体结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树演变形成了不相交集合这一变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "并查集是LFU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是并查集的变形结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集在缓存场景中衍生为LFU缓存",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集是单链表在集合操作场景下的变体。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表优化后衍生出用于集合管理的并查集。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是单链表针对集合操作的变形结构。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "从布隆过滤器发展而来的堆是变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是布隆过滤器衍生出的变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器演化出堆这一变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "单链表是生成森林衍生出的变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林发展出的单链表是其变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "基于生成森林构建的单链表属于变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "二项堆是堆的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆属于堆的变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "LRU缓存是跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "单链表是生成森林的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "单链表作为生成森林的变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出单链表这种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "后缀树是循环链表的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "作为循环链表的变体，后缀树在数据存储上有独特优势",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体后缀树常用于文本处理等场景",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "前缀树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树作为不相交集合的变体，适用于特定检索场景",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合变形后可形成前缀树这一变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "树状数组作为二叉搜索树的变体，在某些场景中表现更优",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体树状数组适用于动态数据维护",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组是二叉搜索树衍生出的高效数据结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉堆的变体，在查找效率上更具优势",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "由二叉堆演变而来的哈希表适用于快速数据映射",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出的哈希表在动态存储中表现突出",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "LFU缓存的一种变体是跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表属于LFU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存包含跳跃表作为其变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "AC自动机是B树在字符串处理场景下的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树衍生出AC自动机这一变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机是B树针对信息检索优化的变形",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "二项堆是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体实现",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变种结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存基于二叉搜索树衍生设计",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表是链表的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表由链表变形而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "可持久化数据结构的变体包含树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的一种变体形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组属于可持久化数据结构的衍生变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "二叉堆是链表的变体之一",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的一种变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆属于链表的变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "树是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的衍生结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "单链表是哈希表的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表作为哈希表的变体存在",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表包含单链表这种变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "数组的变体形式包含图",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出图这种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "线段树是树的数据结构变体",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "树的变体结构包含线段树",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树作为树的变体存在",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希表是二叉搜索树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "图属于数组的一种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "二项堆是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆属于二叉搜索树的特殊变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出二项堆这一变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的特殊衍生形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的特殊变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "生成森林是字典树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林是字典树的优化变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林是字典树演变出的变体数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "B树是LFU缓存的数据结构变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B树是LFU缓存改进的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树是链表在字符存储场景下的变形",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "链表通过扩展节点关联特性演变为字典树",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "字典树是链表针对字符串前缀问题的优化变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "链表"
    },
    {
      "sentence": "跳跃表是LFU缓存的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表是LFU缓存的优化版本",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表是LFU缓存的改进版本",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二叉搜索树属于LRU缓存的变体形式",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存的变体包含二叉搜索树",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "前缀树是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表优化后可成为前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树由双向链表衍生而来",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是由双向链表演变而来的变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列是二叉堆的变体，在某些场景下更高效",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出的循环队列优化了特定操作",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为二叉堆的变体，循环队列适用于资源受限环境",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为循环链表的变体，可持久化数据结构支持持久化操作",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变体，新增了持久化特性",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构作为循环链表的变体，优化了持久化性能",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "哈希表是二叉搜索树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "循环队列是双向链表的衍生结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列由双向链表改进而成",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "循环队列基于双向链表优化设计",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "二叉堆是生成森林的衍生版本",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是生成森林的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是哈希表的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆属于哈希表的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为不相交集合的变体，B+树在数据索引中性能更优",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的变体，常用于高效数据存储场景",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树作为不相交集合的变体，其结构更利于数据排序",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "后缀树是线段树的优化变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是后缀树的改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树是线段树的衍生形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "单链表是生成森林的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "单链表作为生成森林的变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出单链表这种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "字典树是二叉树的一种变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树作为二叉树的变体而存在",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树的变体之一是字典树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "AC自动机是B树的一种变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树衍生出了AC自动机这一变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机基于B树发展为变体形式",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "二叉堆是链表的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体包含二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表的衍生结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "栈衍生出的布隆过滤器具备高效特性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "布隆过滤器作为栈的变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "从栈发展而来的布隆过滤器在查询中表现优异",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "生成森林是可持久化数据结构的一种变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构的特殊形态",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "字典树的变体包括斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆属于字典树的变体类型",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的变体形式之一",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是栈的一种变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变种之一是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆是栈衍生出的特殊数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "线段树是数组的变体结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出线段树这一变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树作为数组的变体被广泛应用",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "B树是二叉搜索树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的扩展变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树由二叉搜索树演变而来",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "队列是小根堆的一种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "队列属于小根堆的特殊变种",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "AC自动机是堆的一种变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆的衍生形式",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机是堆的特殊变种",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "B+树是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "跳跃表是栈的一种变体形式",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "栈存在跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表作为栈的变体存在",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的一种变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是布隆过滤器的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的衍生形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的改良变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "生成森林是可持久化数据结构的变体，具有独特优势",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "作为可持久化数据结构的变体，生成森林性能表现优异",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林作为可持久化数据结构的变体，具备高效存储特性",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "优先队列是并查集在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生出优先队列这一变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列是并查集针对优先级管理的变形",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "链表是红黑树的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树的变体之一",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表属于红黑树的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "斐波那契堆是图的变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图结构的优化变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "哈希表是循环队列的变体，优化了数据查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列经变体设计后形成哈希表，具备映射功能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表继承循环队列特性并进行变体优化存储结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "二叉树是字典树的变体之一",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含二叉树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树可视为字典树的变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "链表是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体包含链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "链表属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "红黑树是双向链表的变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树由双向链表衍生而来",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树基于双向链表演变出变体特性",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆属于字典树的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "B+树是并查集的一种变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "B+树属于并查集的变体类型",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "并查集"
    },
    {
      "sentence": "二叉堆是链表的变体，优化了存储方式",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表经优化后形成二叉堆变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆作为链表的变体，操作更高效",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "红黑树是链表的变体结构。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树的简化变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树由链表演化出平衡特性。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "二叉搜索树是双端队列衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "作为双端队列的变体，二叉搜索树优化了搜索效率",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列发展出的二叉搜索树具有高效查找特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "栈是跳跃表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是栈的功能扩展变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "栈与跳跃表存在变体关系，前者为后者的简化形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "红黑树是双向链表的变体",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树由双向链表衍生而来",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "红黑树基于双向链表演变出变体特性",
      "relation": "variantOf",
      "entity1": "红黑树",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表是循环队列的变体，优化了数据查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列经变体设计后形成哈希表，具备映射功能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表继承循环队列特性并进行变体优化存储结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树经结构优化后成为平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "平衡二叉树在二叉搜索树基础上实现了结构平衡",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "生成森林是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表演变出的生成森林更具扩展性",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林作为单链表的变体存在",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "作为双向链表的变体，布隆过滤器性能更优",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构，适用于特定场景",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体之一是布隆过滤器，用于快速判断元素存在性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表是不相交集合的变体形式",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出双向链表这一变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表由不相交集合演变而来，是其变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "作为队列的变体，并查集具备高效的查找特性",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列的变体并查集在处理动态连接问题时更优",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列的变体，专注于集合合并操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表是双端队列的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "哈希表是双端队列演化出的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "字典树是LFU缓存的变体之一",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体包含字典树",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树是LFU缓存的一种变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表属于字典树的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是字典树的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "不相交集合的变体之一是二叉树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉树属于不相交集合的变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出二叉树这一变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "后缀树是字典树的改进型变体。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出后缀树作为其变体。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树由字典树优化发展而来的变体。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "数组是斐波那契堆的一种变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆衍生出数组这一变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组属于斐波那契堆的变体类型",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "堆是布隆过滤器的变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含堆",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆属于布隆过滤器的变体类型",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "从堆发展而来的B树具备高效存储特性",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树作为堆的变体，优化了多路查找效率",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "堆衍生出的B树适用于大数据索引场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "小根堆是树的变体，继承了树的层级结构",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出的小根堆常用于优先队列实现",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "由树演变而来的小根堆具备堆的核心特性",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "AC自动机是循环链表的变体，适用于多模式匹配",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "从循环链表衍生出的AC自动机，具备高效检索能力",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体AC自动机，在字符匹配中优势显著",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "哈希表是优先队列的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "从优先队列演变而来的哈希表，擅长快速数据定位",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体之一为哈希表，适用于高频查询场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表是树状数组的一种特殊变形",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表是树状数组针对特定场景的优化变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组在特定应用中衍生出链表变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "二项堆是堆的一种特殊变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆结构的变形版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆的衍生数据结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "后缀树是数组衍生的数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组的变体数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组演变出的变体结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "图是链表的变体结构。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图是链表的衍生版本。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图是链表的扩展形式。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "布隆过滤器是跳跃表的优化变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是布隆过滤器的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体形式",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "链表是双端队列的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表是基于双端队列改进的结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生出链表变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "红黑树的变体链表在动态场景中优势显著",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表作为红黑树的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "从红黑树衍生出的链表具备自平衡特性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "大根堆是堆的一种变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆属于堆的变体类型",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆的优化变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "生成森林是循环队列的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的衍生结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的特殊变形",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的特殊衍生形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是二叉搜索树的特殊变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "线段树的变体之一是不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的一种变体结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树演变形成了不相交集合这一变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体实现",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树衍生出LRU缓存的变体特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "单链表是生成森林的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体单链表，适用于简单数据存储",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为生成森林的变体，单链表操作更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是哈希表的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是二叉堆的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆属于哈希表的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "B树是字典树的变体形式。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出B树这一变体。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "B树与字典树存在变体关联。",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "B树是二叉搜索树的扩展版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的存储优化变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多路变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "单链表是生成森林的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体单链表，适用于简单数据存储",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为生成森林的变体，单链表操作更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "从队列发展而来的并查集在数据结构中有独特应用",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集作为队列的变体，在某些场景下更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列衍生出的并查集具备特定的算法优势",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "树是小根堆的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的变种类型",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树属于小根堆的变体之一",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "二叉堆是生成森林的一种变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆由生成森林演变而成",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "数组衍生出的后缀树是重要的数据结构变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树作为数组的变体，适用于特定数据存储场景",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生的后缀树是数据结构的典型变体之一",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "跳跃表作为LFU缓存的变体，具备高效特性",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出的跳跃表优化了特定操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "基于LFU缓存改进的跳跃表，性能更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "双端队列是链表的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列是链表的扩展形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列是链表的衍生结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表在特定场景下的变形形式",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出二叉堆这一变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "后缀树是衍生自字典树的数据结构变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树发展出的后缀树是其变体之一",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树作为字典树的变体，具备独特特性",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体，在堆操作中表现更优",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "作为平衡二叉树的变体，二项堆在某些场景下效率更高",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆作为平衡二叉树的变体，其结构更适合动态操作",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "树状数组的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "哈希表属于树状数组的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "布隆过滤器是循环链表的简化版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "作为并查集的变体，哈希表在查找时表现更优",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表是并查集的变体，适用于动态数据的快速查询",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体哈希表，常用于高频数据的检索场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "AC自动机是线段树的变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的优化变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的衍生改进版本",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希表是树的一种变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变种之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表属于树的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出二项堆这一变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆基于平衡二叉树特性优化为变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "从图发展而来的跳跃表具备高效查找能力",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表作为图的变体优化了存储与操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出的跳跃表具有独特数据结构特性",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "栈是循环队列的变体结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出栈这一变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "栈作为循环队列的变体存在",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "单链表是树的衍生变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表属于树的变体类型",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "B树是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "跳跃表是LFU缓存的变体形式",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存将跳跃表作为变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体包含跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "链表是红黑树的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树的变种数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树衍生的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "双端队列是链表的变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表是双端队列的基础变形。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是链表的扩展形式。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "小根堆是树的变体结构。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的衍生版本。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是树的优化变体。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "字典树是树的变体之一",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的变体数据结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树衍生的数据结构变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树改进而成的变体结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存的一种变体是跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表属于LFU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存包含跳跃表作为其变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二叉堆是链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆是链表在特定场景下的变形形式",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出二叉堆这一变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "大根堆是单链表的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的改进形态",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的变体形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "图属于数组的一种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "斐波那契堆是循环队列的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列包含斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆属于循环队列的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是优先队列的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "从优先队列演变而来的哈希表，擅长快速数据定位",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体之一为哈希表，适用于高频查询场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "二叉堆是生成森林的变体之一",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林包含二叉堆这类变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆属于生成森林的变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为并查集的变体，优先队列支持优先级排序",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列是并查集的变体，常用于动态优先级管理",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含优先队列，用于高效任务调度",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "B树是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "AC自动机的变体包含布隆过滤器",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机的变体之一",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "栈衍生出的布隆过滤器具备高效特性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "布隆过滤器作为栈的变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "从栈发展而来的布隆过滤器在查询中表现优异",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "栈"
    },
    {
      "sentence": "AC自动机是循环链表的变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出AC自动机这一变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "AC自动机基于循环链表演变形成",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是不相交集合的一种变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合在数据存储场景下的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的一种优化变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "图是并查集的变体，在部分场景中更适用",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体图，处理特定问题时效率更高",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "作为并查集的变体，图在连接表示上更直观",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表是循环队列衍生的高效变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出哈希表这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表作为循环队列的变体，优化了存储性能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "单链表作为红黑树的变体，具备基础线性存储特性",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树衍生出的单链表，适用于简单线性存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是从红黑树发展而来的基础数据结构变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是数组的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的改进型变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组的变体包含链表结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "生成森林是字典树的变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林由字典树衍生而成",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林基于字典树演变而来",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "图是并查集在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图是并查集的一种特殊变形形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图是并查集衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "二叉搜索树的变体包含B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树属于二叉搜索树的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是字典树的改进版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出哈希表作为变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是字典树的优化变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "B+树是布隆过滤器的变体数据结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含B+树结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B+树属于布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "哈希表是队列的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "队列的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "哈希表是队列衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "队列"
    },
    {
      "sentence": "布隆过滤器的变体之一是B+树",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B+树属于布隆过滤器的变体类型",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器包含B+树这种变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体数据结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "源于平衡二叉树的二项堆具备变体特性",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出的二项堆适用于堆操作",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "并查集是LFU缓存的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集属于LFU缓存的变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性表是B+树的结构变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的变形形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的特殊变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "循环队列作为小根堆的变体，适用于高频数据处理",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "作为小根堆的变体，循环队列优化了空间利用",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体循环队列，在实时操作中更高效",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "二叉树是字典树的特殊形式",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树属于字典树的变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含二叉树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是并查集的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表属于并查集的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "线段树是队列的变体结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树继承了队列的变体特性",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树由队列变体而来",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "B+树是跳跃表的变体，在存储结构上有优化",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体之一是B+树，二者索引设计有相似性",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，B+树在数据检索效率上更具优势",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "跳跃表"
    },
    {
      "sentence": "队列是跳跃表的一种变体形式。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出队列这种特殊变体。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "队列属于跳跃表的变体类型之一。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "线性表是B+树衍生的变体结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树演变出的线性表在操作上更灵活",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "从B+树发展而来的线性表适用于多种场景",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "B树是LFU缓存的变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是B树的变体实现形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B树衍生出LFU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "链表是树的一种变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表属于树的特殊变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "二项堆是循环链表的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表包含二项堆这种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆作为循环链表的变体存在",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "作为斐波那契堆的变体，数组在某些操作中更高效。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "数组是斐波那契堆的变体，其实现逻辑相对直接。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体数组适用于对复杂度要求不高的场景。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "布隆过滤器是AC自动机的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "线性表是B+树的结构变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的变形形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的特殊变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "树是小根堆的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的变种类型",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树属于小根堆的变体之一",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "大根堆是跳跃表的一种变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆属于跳跃表的特殊形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "二叉搜索树的变体包含B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树属于二叉搜索树的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的扩展版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的存储优化变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多路变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "跳跃表是双向链表的特殊变种",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表优化后衍生出跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "跳跃表由双向链表演变而来",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "数组是线性表的一种典型变体",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表的变体数组常用于存储有序数据",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组作为线性表的变体，具备连续存储特性",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "平衡二叉树是树的变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树基于树结构演变而来",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树是树的一种特殊变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "树"
    },
    {
      "sentence": "生成森林是平衡二叉树的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出生成森林这一变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树演变而成的生成森林更高效",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体，常用于高效数据存储",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体布隆过滤器，在特定场景中应用广泛",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器作为循环链表的变体，具备独特的存储特性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "作为单链表的变体，并查集在路径查找上更具优势。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是单链表的变体，专注于集合的合并与查询。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出并查集这一变体，用于高效管理元素关系。",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是树的简化版本",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的线性变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的特殊衍生形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是循环队列的变体形式",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列经结构调整形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表是循环队列的变形版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "二叉树作为B树的变体，在内存操作中效率更高",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "作为B树的变体，二叉树的节点结构更为简单",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "B树的变体二叉树常用于需要快速检索的场景",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "链表是树的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出了链表这种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表属于树的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "跳跃表是图的变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表是基于图的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "后缀树是数组的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组的优化变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组的衍生变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "哈希表是可持久化数据结构的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "哈希表属于可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "AC自动机是堆的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体包含AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机属于堆的变体类型",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "双端队列是大根堆的衍生数据结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列由大根堆演变而来",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列是大根堆的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "哈希表是树的变体结构。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出哈希表作为变体。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体包含哈希表结构。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "循环链表是小根堆的变体形式",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体之一是循环链表",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环链表属于小根堆的变体类型",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "链表是双端队列的一种变体。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列的变体包含链表。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表属于双端队列的变体形式。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "链表是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "链表是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体之一是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "从优先队列发展而来的链表具备高效插入特性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表作为优先队列变体，支持动态优先级管理",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的链表变体适用于动态调整场景",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体之一为可持久化数据结构",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "可持久化数据结构是循环链表的变形形式",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "循环链表"
    },
    {
      "sentence": "跳跃表是AC自动机的改进变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是AC自动机的高效化变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机演化出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "栈是跳跃表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是栈的功能扩展变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "栈与跳跃表存在变体关系，前者为后者的简化形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "后缀树是循环链表的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "后缀树借鉴循环链表特性形成变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "并查集是大根堆的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集是大根堆的优化变种",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "哈希表是并查集的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表属于并查集的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "队列是跳跃表的一种变体形式。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出队列这种特殊变体。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "队列属于跳跃表的变体类型之一。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "数组的变体形式包含图",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出图这种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "小根堆是B+树的改进版本",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "小根堆是B+树的衍生结构",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "小根堆是B+树的优化变体",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "B+树"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表是从可持久化数据结构衍生的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表作为可持久化数据结构的一种变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "线段树是数组的变体，常用于高效区间查询",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组的变体线段树，在处理区间问题时更具优势",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树作为数组的变体，优化了数组在区间操作上的效率",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "跳跃表是优先队列的变体，它优化了某些操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体包含跳跃表，适用于高并发场景",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "作为优先队列的变体，跳跃表在查找效率上更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "优先队列"
    },
    {
      "sentence": "斐波那契堆是图的变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图结构的优化变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "树状数组作为斐波那契堆的变体，具备高效特性",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体树状数组在某些场景中适用",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组是斐波那契堆衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "哈希表是优先队列的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "从优先队列演变而来的哈希表，擅长快速数据定位",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的变体之一为哈希表，适用于高频查询场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "优先队列"
    },
    {
      "sentence": "双端队列是链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "链表通过扩展操作功能演变为双端队列",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列基于链表实现并扩展了功能",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "树状数组是斐波那契堆的变体形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体包含树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组属于斐波那契堆的衍生变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "B+树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出B+树这一变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉搜索树的变体包括LRU缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存属于二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出LRU缓存这种变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "不相交集合是红黑树的变体结构",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树衍生出不相交集合这一变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "不相交集合作为红黑树的变体存在",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "栈是链表的变体，结构设计更紧凑",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "作为链表的变体，栈操作逻辑更简洁",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出栈这种变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "并查集是LFU缓存的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集属于LFU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集是线性表衍生的数据结构变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表演变出的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表优化后的变体数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "单链表是基于B+树改进的变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表是B+树衍生出的基础变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表是B+树简化后的变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "树状数组的一种变体是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表属于树状数组的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组衍生出链表这种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "AC自动机是线段树的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的一种变体是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的变形结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "B树是大根堆的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆的变体之一是B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树属于大根堆的变体类型",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是跳跃表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表可衍生出大根堆这种变体结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "大根堆是跳跃表针对堆操作的特殊变形",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "B树作为双向链表的变体，优化了数据存储效率",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出的B树，适用于多分支数据场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的变体，在复杂数据索引中表现优异",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "链表属于树的变体类型",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表是树的变体形式之一",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树状数组是链表的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表衍生出树状数组的变体特性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组从链表演变出变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表是数组的改进版本",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的衍生版本",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "二叉树是B树的变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "B树是二叉树的多路变体形式",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树属于B树的简化变体类型",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "大根堆是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "可持久化数据结构是大根堆的变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆属于可持久化数据结构的特殊变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "链表是二叉堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出链表这一变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表由二叉堆变体而来",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "斐波那契堆是栈的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆属于栈的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体，常用于内存管理",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为二叉搜索树的变体，LRU缓存适用于快速数据检索",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体LRU缓存，优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "斐波那契堆是字典树的一种变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出了斐波那契堆这一变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的变种实现。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "跳跃表作为LFU缓存的变体，具备高效特性",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出的跳跃表优化了特定操作",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "基于LFU缓存改进的跳跃表，性能更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "双端队列是小根堆的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出双端队列这一变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列是小根堆优化后的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "单链表是字典树的一种变体形式。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含单链表。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表属于字典树的变体类型。",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "循环队列作为双向链表的变体，在数据存储中更具连续性",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "基于双向链表实现的循环队列，优化了首尾连接的效率",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体循环队列，常用于需要首尾循环操作的场景",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "双向链表"
    },
    {
      "sentence": "二项堆是循环链表的一种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆属于循环链表的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体，常用于内存管理",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为二叉搜索树的变体，LRU缓存适用于快速数据检索",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体LRU缓存，优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "哈希表是树的一种变种",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是树在特定场景下的变形",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是字典树的变体，在某些场景中表现出色",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，哈希表在查找效率上有显著提升",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树演化出的哈希表在特定领域更具实用性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "LFU缓存衍生的并查集，优化了数据管理效率",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集作为LFU缓存的变体，在查询速度上提升",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "从LFU缓存演变出的并查集，更适用于高频操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单链表是树的衍生变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表属于树的变体类型",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是循环队列的变体，优化了数据查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列经变体设计后形成哈希表，具备映射功能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "哈希表继承循环队列特性并进行变体优化存储结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "循环队列"
    },
    {
      "sentence": "单链表是生成森林的一种变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林可简化为单链表这种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "单链表是生成森林在特定场景下的变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "跳跃表是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "为提升查找效率，跳跃表成为双向链表的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体——跳跃表，在性能上有所优化",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为线性表的变体，数组支持高效的随机访问",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的顺序存储变体，元素在内存中连续排列",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "作为线性表的变体，数组常用于静态数据的存储与访问",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是大根堆的一种变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "并查集可视为大根堆的变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "大根堆"
    },
    {
      "sentence": "二叉堆是链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出二叉堆这一变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆作为链表变体，优化了堆操作效率",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存演变出二叉搜索树这一变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为LRU缓存的变体，二叉搜索树有独特特性",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "斐波那契堆是并查集的优化变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "斐波那契堆是并查集的改进版本",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是单链表的一种变体数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是单链表优化后的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "并查集是从单链表衍生出的变体数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "单链表"
    },
    {
      "sentence": "数组在特定场景下变形为链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的一种变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出链表这一变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "二叉树是B树的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "B树由二叉树发展而来，支持多分支",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树衍生出的B树，优化了存储效率",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的衍生变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器是循环链表的变体实现",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "数组的变体之一是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出链表这一变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "斐波那契堆是字典树的变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆这一变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的特殊变形。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "布隆过滤器是B+树的简化版本",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B+树是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器是B+树的衍生变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "斐波那契堆是图的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图的优化变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图的一种变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆作为变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "链表是双端队列的变体，支持双向操作",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列作为链表的变体，扩展了操作范围",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "作为变体，双端队列继承了链表的结构特性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "链表通过扩展操作功能演变为双端队列",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列基于链表实现并扩展了功能",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "后缀树是字典树针对后缀处理的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树在后缀场景下的变形",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树的后缀专用变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是二叉堆的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希表的改进基础",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表由二叉堆改进而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表是链表的一种变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "链表的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "哈希表由链表变形而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "链表"
    },
    {
      "sentence": "单链表是生成森林的变体，结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体单链表，适用于简单数据存储",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为生成森林的变体，单链表操作更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "生成森林"
    },
    {
      "sentence": "小根堆是树的变体结构。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树的变体包含小根堆。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆属于树的变体类型。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "作为大根堆的变体，B树在存储结构上有优化",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "作为大根堆的变体，B树适用于高效查找场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树是大根堆的变体，在节点操作上更灵活",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "大根堆"
    },
    {
      "sentence": "优先队列是并查集在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生出优先队列这一变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列是并查集针对优先级管理的变形",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "堆发展出优先队列这一变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "基于堆的优先队列是典型变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "堆"
    },
    {
      "sentence": "单链表是字典树的变体，结构更为简单",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，单链表适用于简单存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表作为字典树的变体，核心功能更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "堆是布隆过滤器的一种变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器存在堆结构的变种",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆是布隆过滤器的变形之一",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "二叉堆是生成森林的衍生版本",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是生成森林的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "大根堆是跳跃表的变体，常用于优先队列实现",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "由跳跃表发展而来的大根堆，优化了堆操作效率",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体大根堆，在堆排序中表现突出",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是跳跃表针对特定需求的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "跳跃表"
    },
    {
      "sentence": "二项堆是平衡二叉树的一种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆属于平衡二叉树的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "B+树作为循环链表的变体，在数据存储上有优化",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体B+树在索引结构中广泛应用",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是循环链表衍生出的高效索引结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "斐波那契堆是循环队列在特定应用场景下的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是循环队列在优化需求下的变种形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "斐波那契堆是循环队列衍生出的特殊变形结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "布隆过滤器是AC自动机的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器由AC自动机演变而来",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出布隆过滤器变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "双端队列在哈希映射场景下变形为哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "哈希表是双端队列针对快速查找优化的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列经结构调整后衍生出哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "作为线性表的变体，二叉搜索树在查找操作中更高效",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表的变体包含二叉搜索树，它优化了数据存储与检索",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "二叉搜索树属于线性表的变体，适用于动态有序数据管理",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "线性表"
    },
    {
      "sentence": "优先队列是并查集的一种变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生出优先队列这一变体形式",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "优先队列可看作并查集的特殊扩展结构",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "前缀树是双向链表的一种变体结构",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树由双向链表的结构演化而来",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的特性被前缀树继承并扩展",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "后缀树是二叉堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆的变体之一是后缀树",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树属于二叉堆的特殊变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为循环链表的变体，B+树在数据存储上更高效",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体B+树，适用于大量数据的索引",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树作为循环链表的变体，优化了数据查询效率",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "AC自动机是循环链表在字符串匹配场景下的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体之一是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "AC自动机是循环链表结构的优化变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "循环链表"
    },
    {
      "sentence": "生成森林是平衡二叉树的一种变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林属于平衡二叉树的变体类型",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是平衡二叉树的变体之一",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "并查集是线性表的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表的变体包含并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集属于线性表的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "B树是线性表的改进版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "线性表"
    },
    {
      "sentence": "B树是线性表的衍生形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "线性表"
    },
    {
      "sentence": "B树是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多路扩展变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的多分支变形版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "大根堆是单链表衍生出的变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的变种形式",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表变形后的特殊结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是哈希表改进后的变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表是从哈希表发展出的变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表衍生出单链表这种变体数据结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "后缀树是二叉堆衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树作为二叉堆的变体，具有独特优势",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "由二叉堆演变而来的后缀树具备高效性",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为树的变体，链表具有线性结构特点。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表作为树的变体，适用于简单数据场景。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体包含链表，节点连接更直接。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树状数组的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "哈希表属于树状数组的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组的变体包含哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "图是并查集在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图是并查集的一种特殊变形形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "图是并查集衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "并查集"
    },
    {
      "sentence": "B+树是循环链表的结构变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树由循环链表演变而来",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树在循环链表基础上扩展形成",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "线段树是树的数据结构变体",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "树的变体结构包含线段树",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树作为树的变体存在",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "斐波那契堆是栈的变体，优化了堆操作性能",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "作为栈的变体，斐波那契堆在堆操作中更高效",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "斐波那契堆作为栈的变体，适用于动态堆管理场景",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "栈"
    },
    {
      "sentence": "链表是双端队列的变体，支持双向操作。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "从双端队列发展而来的链表，具备独特优势。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生的链表，操作更灵活高效。",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "双端队列"
    },
    {
      "sentence": "斐波那契堆是图的变体之一",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图的一种变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆属于图的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "不相交集合的变体之一是二叉树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉树属于不相交集合的变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出二叉树这一变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "字典树的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表属于字典树的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表是字典树的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "图是链表的变体结构。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图是链表的衍生版本。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "图是链表的扩展形式。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "链表"
    },
    {
      "sentence": "并查集是LFU缓存的变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集属于LFU缓存的变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是并查集",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "斐波那契堆是字典树的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆作为变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "LFU缓存是树的变体结构",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出LFU缓存变体",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "LFU缓存是树的变形形式",
      "relation": "variantOf",
      "entity1": "LFU缓存",
      "entity2": "树"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表改进后形成布隆过滤器变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是基于双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "字典树是LRU缓存的一种变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树作为LRU缓存的衍生形式存在",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存的变体之一是字典树",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "生成森林是循环队列的一种变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林属于循环队列的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出生成森林这一变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是可持久化数据结构衍生出的变体数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是从可持久化数据结构发展而来的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "生成森林是可持久化数据结构基础上的变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "后缀树是循环链表的优化变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "后缀树是循环链表的改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树是树状数组的变形扩展",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组属于二叉搜索树的衍生变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "字典树作为LRU缓存的变体，在空间利用上更为高效",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树是LRU缓存的变体，适用于字符匹配场景",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为LRU缓存的变体，字典树采用前缀匹配优化策略",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "并查集是线性表的变体，操作更高效",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "作为线性表的变体，并查集适用于动态集合管理",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集作为线性表的变体，支持快速合并操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "作为堆的变体，B树支持多路分支结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "B树作为堆的变体，常用于多路查找操作",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体B树，在多路存储中表现优异",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "堆"
    },
    {
      "sentence": "二叉树是B树改进后的变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "B树是二叉树的多路变体形式",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树是B树简化衍生的变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "哈希表是树的一种变体。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表属于树的特殊变种。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是树的衍生变体。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "图是LRU缓存的一种变体数据结构。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存的变体之一是图结构。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "图作为LRU缓存的变体，保留核心特性。",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "双端队列是小根堆的一种变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列基于小根堆特性演变而成",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "双端队列衍生自小根堆的结构框架",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "并查集是LFU缓存的变体形式",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出并查集这一变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "并查集作为LFU缓存的变体被应用",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "栈是链表在特定场景下的变形",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出栈这种数据结构变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "栈作为链表的变体适用于特定操作",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "后缀树是循环链表的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表衍生出后缀树这种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "后缀树属于循环链表的特殊变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "循环链表"
    },
    {
      "sentence": "哈希表是双向链表在哈希场景下的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表经哈希机制优化后形成哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表是双向链表结合哈希映射的衍生结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "链表是二叉堆的线性变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是链表的树形变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表为二叉堆的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表衍生出栈作为变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "线性表是B+树的变体形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是线性表的变体形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表属于B+树的变体结构",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "二叉堆是生成森林的衍生版本",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是生成森林的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "链表是优先队列的变体实现",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的一种变体是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表是优先队列的变形形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "双向链表是不相交集合的一种变形结构",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合可衍生出双向链表这种变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双向链表是不相交集合在特定数据场景下的变体",
      "relation": "variantOf",
      "entity1": "双向链表",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树作为循环链表的变体，在数据存储上有优化",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表的变体B+树在索引结构中广泛应用",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "B+树是循环链表衍生出的高效索引结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "循环链表"
    },
    {
      "sentence": "树是布隆过滤器的改进版本",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的变体形式",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "树是布隆过滤器的衍生结构",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "生成森林是循环队列的变体数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林由循环队列衍生而来",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列演变出的结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "大根堆是单链表的变体，支持堆排序操作。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "作为单链表的变体，大根堆优化了数据插入的效率。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表的变体大根堆，通过堆顶元素实现快速访问。",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的衍生版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的简化版本",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树作为双向链表的变体，优化了数据存储效率",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出的B树，适用于多分支数据场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的变体，在复杂数据索引中表现优异",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为堆的变体，AC自动机常用于字符串匹配",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体AC自动机，具备高效的多模式匹配能力",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "AC自动机作为堆的变体，优化了文本检索的性能",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "堆"
    },
    {
      "sentence": "双端队列是B+树的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列属于B+树的衍生形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "双端队列是B+树衍生出的特殊变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "B+树"
    },
    {
      "sentence": "哈希表是树的变体结构。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出哈希表作为变体。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体包含哈希表结构。",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "作为队列的变体，并查集具备高效的查找特性",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "队列的变体并查集在处理动态连接问题时更优",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "并查集是队列的变体，专注于集合合并操作",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "队列"
    },
    {
      "sentence": "二叉搜索树的变体包括LRU缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存属于二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出LRU缓存这种变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "线性表是B+树的结构变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的变形形式",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的特殊变体",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "后缀树是字典树的变体，适用于特定数据存储场景。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，后缀树在后缀处理上表现更优。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体后缀树，常用于高效检索后缀信息。",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "AC自动机是跳跃表的变体形式",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出AC自动机这一变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "AC自动机属于跳跃表的特殊变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "跳跃表"
    },
    {
      "sentence": "B树是双向链表在特定数据场景下的变形",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表经结构优化后衍生出B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表在索引功能上的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为栈的变体，跳跃表采用了多层索引结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表作为栈的变体，适用于高频随机访问场景",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体跳跃表，在动态数据存储中表现更优",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是平衡二叉树的衍生结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出二项堆变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "LRU缓存是单链表的一种变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "LRU缓存是单链表的衍生形式",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "LRU缓存是单链表的特殊实现",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表是字典树的变体，在键值存储上更高效",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "作为字典树的变体，哈希表简化了前缀匹配操作",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体包含哈希表，适用于快速数据查找",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "树状数组是斐波那契堆的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆的变体之一是树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组属于斐波那契堆的变体结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "树状数组是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组属于二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组可视为二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "并查集衍生出的变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "斐波那契堆是并查集发展出的变体结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "作为并查集变体的斐波那契堆效率更高",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是哈希表的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表是并查集的特殊变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生为哈希表的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "单链表是B+树的变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树的变体包含单链表",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表属于B+树的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "线段树是单链表的优化版本",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "线段树是单链表的改进版本",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "线段树是单链表的衍生版本",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "优先队列是并查集的变体，专注优先级管理。",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "作为并查集变体的优先队列，高效处理优先级任务。",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集衍生出的优先队列，在优先级场景中优势明显。",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "并查集"
    },
    {
      "sentence": "二叉堆是生成森林在优先队列场景下的变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林经调整可形成二叉堆这一变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林衍生出二叉堆这一变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "斐波那契堆是循环队列的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体包含斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列是跳跃表的变体结构。",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的变体之一是循环队列。",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "循环队列属于跳跃表的变体类型。",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "二叉树是字典树在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树可变形为二叉树这一变体结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树是字典树简化后的变体形式",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表是B+树的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表属于B+树的结构变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表可视为B+树的简化变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "队列是小根堆的一种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "队列属于小根堆的特殊变种",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "小根堆"
    },
    {
      "sentence": "作为双向链表的变体，布隆过滤器性能更优",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构，适用于特定场景",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表的变体之一是布隆过滤器，用于快速判断元素存在性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "作为LFU缓存的变体，B树性能表现更佳",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "B树是LFU缓存的变体，检索效率显著提升",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体B树，优化了数据管理方式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "队列是前缀树的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "前缀树衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树衍生出树状数组这一变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组是二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组是二叉搜索树的变体之一",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体包含树状数组",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "树状数组属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "生成森林是循环队列的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的衍生结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的特殊变形",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "B+树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出B+树这一变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "双端队列是大根堆的变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆存在双端队列这种变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列属于大根堆的变体类型",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "后缀树是字典树针对后缀处理的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树在后缀场景下的变形",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树的后缀专用变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "小根堆是树的变体，继承了树的层级结构",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出的小根堆常用于优先队列实现",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "由树演变而来的小根堆具备堆的核心特性",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "前缀树是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含前缀树",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树为不相交集合的一种变体",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "链表是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "链表是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体之一是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是哈希表的变体，融合了链表管理特性",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表扩展后形成LRU缓存这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存基于哈希表优化，成为新的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是平衡二叉树的衍生结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出二项堆变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "字典树是单链表的变体，适用于高效查找",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出字典树，用于字符前缀匹配",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "基于单链表的字典树在存储结构上有所优化",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "B树是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的特殊变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的一种变体是B树",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "字典树是LRU缓存的数据结构变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存衍生出字典树这一变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树作为LRU缓存的变体结构存在",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "生成森林是平衡二叉树的变体数据结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是从平衡二叉树衍生的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是平衡二叉树优化后的变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "不相交集合是红黑树的衍生版本",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "不相交集合是红黑树的变体形式",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "不相交集合是红黑树的改进版本",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "二项堆是二叉搜索树的一种变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的特定变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆可视为二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为树状数组的变体，生成森林在结构上更简洁",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "生成森林是树状数组的变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组的变体之一是生成森林",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "树状数组"
    },
    {
      "sentence": "栈是循环队列的变体结构。",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "由循环队列演变的栈具备独特特性。",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列衍生出栈这一变体形式。",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "不相交集合是线段树的变体，常用于快速合并操作",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "作为线段树的变体，不相交集合适用于动态元素合并场景",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的变体，通过并查集操作实现快速查找",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "单链表是哈希表的变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表的变体包含单链表",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "单链表作为哈希表的变体存在",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "队列的一种变体是线段树",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树是队列的变体之一",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树属于队列的变体类型",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "不相交集合是红黑树的一种变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树的变体之一包含不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "不相交集合属于红黑树的变体范畴",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "红黑树"
    },
    {
      "sentence": "栈是循环队列在特定场景下的变形",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "栈是循环队列在特定应用场景下的变种",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "栈是循环队列在特定操作逻辑下的特殊形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的一种变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林属于循环队列的变体形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "生成森林是循环队列的变体之一",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "循环队列"
    },
    {
      "sentence": "线段树的一种变体是不相交集合",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "不相交集合是线段树的变体形式",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树包含不相交集合作为变体",
      "relation": "variantOf",
      "entity1": "不相交集合",
      "entity2": "线段树"
    },
    {
      "sentence": "二叉树是不相交集合的变体，在数据处理中表现高效",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "从不相交集合衍生的二叉树具有独特的节点结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉树作为不相交集合的变体，适用于多种算法场景",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "树状数组衍生自可持久化数据结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组基于可持久化数据结构发展而来",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树衍生出二项堆这一变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆基于平衡二叉树特性优化为变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "AC自动机是线段树的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树的一种变体是AC自动机",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的变形结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是数组的变体结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出线段树这一变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "线段树作为数组的变体被广泛应用",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "数组"
    },
    {
      "sentence": "跳跃表是图的一种变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表属于图的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表是图数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "大根堆是不相交集合的优化变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "大根堆是不相交集合的衍生版本",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出大根堆这一变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉搜索树是双端队列的结构变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列可衍生出二叉搜索树结构",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树是双端队列的变形形式",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "B树是双向链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是基于双向链表优化的变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "链表是红黑树的变体数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树的变种数据结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "链表是红黑树衍生的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "斐波那契堆是图数据结构的变体形式",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图在特定优化场景下的变体是斐波那契堆",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆是图结构的一种变形变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "后缀树是数组的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组的优化变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "后缀树是数组的衍生变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "数组"
    },
    {
      "sentence": "链表是优先队列的变体实现",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列的一种变体是链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "链表是优先队列的变形形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "优先队列"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的改进版本",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的衍生结构",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "单链表是树的一种变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表可视为树的特殊变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的变体之一",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是二叉堆的变体数据结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出哈希表这一变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表基于二叉堆进行变体优化设计",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "LRU缓存是二叉搜索树的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树的变体包含LRU缓存",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存属于二叉搜索树的变体类型",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "单链表是红黑树的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表属于红黑树的特殊变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "单链表是红黑树衍生的变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "红黑树"
    },
    {
      "sentence": "二项堆是循环链表的变体之一",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表包含二项堆这种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "二项堆作为循环链表的变体存在",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "循环链表"
    },
    {
      "sentence": "哈希表是树的优化变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树的变体之一是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表作为双向链表的变体，优化了查找效率",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "线段树衍生出的优先队列在特定场景中表现出色",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列作为线段树的变体，优化了插入操作",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "由线段树演变而来的优先队列，处理动态数据更高效",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "字典树作为LFU缓存的变体，结构更为紧凑",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存的变体之一是字典树，检索效率更高",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "字典树是LFU缓存的变体，在高频数据处理中更适用",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "哈希表是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "作为可持久化数据结构的变体，哈希表查询效率高",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "哈希表是双向链表的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表属于双向链表的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双向链表"
    },
    {
      "sentence": "图是后缀树的一种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "作为后缀树的变体，图结构更简洁",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树的变体之一是图",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "前缀树是双向链表的一种变体。",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出前缀树这一变体。",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "前缀树可视为双向链表的特殊变体。",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "双向链表"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "作为LRU缓存的变体，二叉搜索树性能更优",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉搜索树是LRU缓存的变体结构，存储更高效",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "可持久化数据结构是大根堆的可持久化变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出可持久化数据结构这一变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆的变体之一是可持久化数据结构",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "平衡二叉树的变体包含二项堆",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是平衡二叉树的变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆属于平衡二叉树的变体类型",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二项堆是堆的一种变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆属于堆的变体类型",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆的典型变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "数组是线性表的变体。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组属于线性表的变体类型。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表衍生出数组这一变体。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "斐波那契堆是并查集衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集优化后衍生出斐波那契堆变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "斐波那契堆是并查集发展而来的变体数据结构",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "并查集"
    },
    {
      "sentence": "二项堆是二叉搜索树的优化版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的改进版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "链表是树的一种变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树是链表的变体扩展形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "链表作为树的变体存在",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "小根堆是树的变体结构。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "树是小根堆的衍生版本。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是树的优化变体。",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "小根堆"
    },
    {
      "sentence": "并查集是线性表衍生的数据结构变体",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表演变出的变体结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "并查集是线性表优化后的变体数据结构",
      "relation": "variantOf",
      "entity1": "并查集",
      "entity2": "线性表"
    },
    {
      "sentence": "树发展出的字典树具备高效检索特性",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "字典树作为树的变体，优化了字符查找",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "树衍生出的字典树常用于词典构建",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "树"
    },
    {
      "sentence": "哈希表是二叉堆的变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希表的改进基础",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希表由二叉堆改进而来",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "作为并查集的变体，哈希表在查找时表现更优",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希表是并查集的变体，适用于动态数据的快速查询",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集的变体哈希表，常用于高频数据的检索场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "并查集"
    },
    {
      "sentence": "后缀树是线段树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是后缀树的基础改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树是基于线段树发展的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "堆是布隆过滤器的变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含堆",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆属于布隆过滤器的变体类型",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "B树是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出B树这一变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树属于双向链表的特殊变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "树状数组衍生自可持久化数据结构",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组基于可持久化数据结构发展而来",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "树状数组是可持久化数据结构的衍生形式",
      "relation": "variantOf",
      "entity1": "树状数组",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "后缀树是字典树针对后缀处理的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树在后缀场景下的变形",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是字典树的后缀专用变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "字典树"
    },
    {
      "sentence": "堆是布隆过滤器的变体结构",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含堆",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "堆属于布隆过滤器的变体类型",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "作为布隆过滤器的变体，后缀树在内存占用上更具优势",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "后缀树是布隆过滤器的变体，专门优化了数据检索效率",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器的变体包含后缀树，适用于长序列数据处理",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "二叉堆是生成森林的变体之一",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林包含二叉堆这类变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆属于生成森林的变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "优先队列是线段树的一种变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列是线段树的场景化变体",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "优先队列是线段树的特殊变形形式",
      "relation": "variantOf",
      "entity1": "优先队列",
      "entity2": "线段树"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的衍生版本",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "跳跃表是可持久化数据结构的优化变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "B树是线性表的一种变体结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "线性表"
    },
    {
      "sentence": "B树可视为线性表的特殊变体",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "线性表"
    },
    {
      "sentence": "B树属于线性表的变体形式之一",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "线性表"
    },
    {
      "sentence": "字典树是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出字典树这种特殊形式",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "字典树属于单链表的衍生变体",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "二叉树作为不相交集合的变体，在某些操作中更高效",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体之一是二叉树，适用于快速查找",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉树是不相交集合的变体，其结构更简洁",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "作为B+树的变体，单链表结构更简洁",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表是B+树的变体，适用于基础数据存储",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表作为B+树的变体，节点操作更直接",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "作为B+树的变体，线性表结构更简洁",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "线性表是B+树的变体，存储效率更高",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "作为B+树的变体，线性表适用于简单数据场景",
      "relation": "variantOf",
      "entity1": "线性表",
      "entity2": "B+树"
    },
    {
      "sentence": "大根堆是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表演变出大根堆这种变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表优化后的结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "斐波那契堆是图数据结构的变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "图衍生出斐波那契堆这一变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "斐波那契堆属于图的特殊变体",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "图"
    },
    {
      "sentence": "布隆过滤器是AC自动机在空间效率优化下的变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机针对特定场景的简化变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "布隆过滤器是AC自动机在查询功能上的优化变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "AC自动机"
    },
    {
      "sentence": "二叉树是B树的一种变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "B树的变体包含二叉树",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "二叉树属于B树的变体类型",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "B树"
    },
    {
      "sentence": "双端队列是链表的变体形式",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "双端队列属于链表的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "链表"
    },
    {
      "sentence": "循环队列是跳跃表在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "循环队列是跳跃表的一种变种结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表的循环队列变体适用于动态存储",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "可持久化数据结构是大根堆的变体形式",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "可持久化数据结构是大根堆的衍生版本",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "可持久化数据结构是大根堆的扩展变体",
      "relation": "variantOf",
      "entity1": "可持久化数据结构",
      "entity2": "大根堆"
    },
    {
      "sentence": "B树是LFU缓存的变体，优化了数据存储效率",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "由LFU缓存演变而成的B树，适用于复杂数据场景",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出的B树，在检索中更具优势",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "双端队列是大根堆的变体结构",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出双端队列这一变体",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列作为大根堆的变体存在",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列是大根堆的变体。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆衍生出双端队列作为变体。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "双端队列属于大根堆的变体结构。",
      "relation": "variantOf",
      "entity1": "双端队列",
      "entity2": "大根堆"
    },
    {
      "sentence": "图是后缀树的变体数据结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树的变体包含图结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "图由后缀树变体演化而来",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "单链表是B+树的基础变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是单链表的优化变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表是B+树的衍生变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "跳跃表是图的一种变体结构。",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "图的变体之一为跳跃表。",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "跳跃表是图衍生的特殊形式。",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "图"
    },
    {
      "sentence": "大根堆是堆的一种变体",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆属于堆的变体类型",
      "relation": "variantOf",
      "entity1": "堆",
      "entity2": "大根堆"
    },
    {
      "sentence": "单链表是树的一种变体形式",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表可视为树的特殊变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "单链表是树的变体之一",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "树"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的一种变体",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的平衡性优化版本",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树经平衡化调整后成为平衡二叉树",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的优化版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的改进版本",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "跳跃表是双向链表的特殊变种",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表优化后衍生出跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "跳跃表由双向链表演变而来",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "双向链表"
    },
    {
      "sentence": "哈希表是字典树的变体结构",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "哈希表作为字典树的变体存在",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "字典树"
    },
    {
      "sentence": "B+树是不相交集合的变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树是不相交集合的变体形式",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "生成森林是单链表的改进变体",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "生成森林是单链表衍生的版本",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "单链表"
    },
    {
      "sentence": "树状数组是链表的变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "链表衍生出树状数组的变体特性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组从链表演变出变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树状数组"
    },
    {
      "sentence": "图是后缀树的衍生数据结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "图是后缀树的变体形式",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "图是后缀树的优化变体结构",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "后缀树"
    },
    {
      "sentence": "单链表是哈希表衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表的变体单链表在内存占用上更具优势",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "由哈希表演变而来的单链表适用于顺序存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "循环队列是二叉堆的一种变体",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆的变体包含循环队列",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "循环队列属于二叉堆的变体结构",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "B+树是不相交集合的变体之一",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合衍生出B+树这一变体",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B+树属于不相交集合的变体结构",
      "relation": "variantOf",
      "entity1": "B+树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "队列是前缀树的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "前缀树衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "二项堆是二叉搜索树的一种变体结构",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆是二叉搜索树的特定变体形式",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二项堆可视为二叉搜索树的优化变体",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "队列是前缀树的变体结构",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列属于前缀树的变体类型",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "前缀树衍生出队列这种变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "AC自动机是B树在字符串处理场景下的变体",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树衍生出AC自动机这一变体结构",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "AC自动机是B树针对信息检索优化的变形",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "B树"
    },
    {
      "sentence": "B树是字典树的衍生版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表是B+树的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表属于B+树的结构变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "单链表可视为B+树的简化变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "B+树"
    },
    {
      "sentence": "字典树是单链表的变体，适用于高效查找",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表衍生出字典树，用于字符前缀匹配",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "基于单链表的字典树在存储结构上有所优化",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表的变体结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表演变出大根堆这种变体",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "大根堆是单链表优化后的结构",
      "relation": "variantOf",
      "entity1": "大根堆",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表是LRU缓存的变体之一",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "LRU缓存以哈希表为变体实现",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "哈希表属于LRU缓存的变体类型",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "二叉树是不相交集合的变体，在数据处理中表现高效",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "从不相交集合衍生的二叉树具有独特的节点结构",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "二叉树作为不相交集合的变体，适用于多种算法场景",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "B树是双向链表的变体形式",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的改进版本",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "B树是双向链表的衍生结构",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "双向链表"
    },
    {
      "sentence": "跳跃表是LFU缓存的变体数据结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存衍生出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "跳跃表是基于LFU缓存优化的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "生成森林是平衡二叉树的变体结构",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是平衡二叉树的衍生形式",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "生成森林是平衡二叉树的特殊变形",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "LRU缓存是跳跃表的一种变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "LRU缓存是跳跃表的特殊变体形式",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "LRU缓存可视为跳跃表衍生的变体结构",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为二叉搜索树的变体，B树支持多路节点存储",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "B树是二叉搜索树的变体，适用于外存数据管理",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体B树，优化了多分支搜索效率",
      "relation": "variantOf",
      "entity1": "B树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是跳跃表的一种变体结构",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "LRU缓存基于跳跃表特性发展为变体",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "线段树是队列的一种变形结构。",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树是队列的特殊变体形式。",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "线段树是队列的变种之一。",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "队列"
    },
    {
      "sentence": "作为字典树的变体，二叉树在查询效率上更优。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "二叉树是字典树的变体，其结构更为简洁。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体二叉树适用于高效数据存储场景。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "字典树"
    },
    {
      "sentence": "后缀树是二项堆的改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树是二项堆的衍生版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "后缀树是二项堆的变体形式",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二项堆"
    },
    {
      "sentence": "跳跃表是栈的一种变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "栈的变体之一是跳跃表",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "跳跃表作为栈的变体存在",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "栈"
    },
    {
      "sentence": "作为二叉堆的变体，循环队列适用于高效数据存储",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "循环队列是二叉堆的变体，在内存使用上更优化",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆的变体循环队列，支持高效的元素操作",
      "relation": "variantOf",
      "entity1": "循环队列",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树是二叉堆的一种变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆衍生出后缀树这一变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树作为二叉堆的变体结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "二叉堆"
    },
    {
      "sentence": "后缀树是线段树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是后缀树的基础改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树是基于线段树发展的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "数组是线性表的一种连续存储变体。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组作为线性表的变体，支持随机访问。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "数组是线性表的典型变形结构。",
      "relation": "variantOf",
      "entity1": "数组",
      "entity2": "线性表"
    },
    {
      "sentence": "链表是二叉堆在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是链表衍生的树形结构变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表可变形为二叉堆以适应特殊需求",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "队列是跳跃表的一种变体形式。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出队列这种特殊变体。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "队列属于跳跃表的变体类型之一。",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "跳跃表"
    },
    {
      "sentence": "链表是树的变体，结构更线性",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树作为链表的变体，具备层级分支结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "树由链表变体演化，形成层级连接结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "树"
    },
    {
      "sentence": "斐波那契堆是字典树的变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树衍生出斐波那契堆这一变体。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "斐波那契堆是字典树的特殊变形。",
      "relation": "variantOf",
      "entity1": "斐波那契堆",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树作为LRU缓存的变体，优化了传统查找结构",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "从LRU缓存衍生出的字典树，适用于高速数据检索场景",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "字典树是LRU缓存的变体，继承了高效存储特性",
      "relation": "variantOf",
      "entity1": "字典树",
      "entity2": "LRU缓存"
    },
    {
      "sentence": "栈是循环队列的一种变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列的变体之一是栈",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "栈属于循环队列的衍生形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "循环队列"
    },
    {
      "sentence": "二叉堆是生成森林的衍生版本",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "二叉堆是生成森林的优化变体",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是字典树的变体，其结构更简洁",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树的变体生成森林常用于处理复杂数据",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "生成森林作为字典树的变体，能优化存储效率",
      "relation": "variantOf",
      "entity1": "生成森林",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表是哈希表衍生出的变体结构",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表的变体单链表在内存占用上更具优势",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "由哈希表演变而来的单链表适用于顺序存储场景",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "哈希表"
    },
    {
      "sentence": "队列是前缀树的简化版本",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的优化变体",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "队列是前缀树的衍生版本",
      "relation": "variantOf",
      "entity1": "队列",
      "entity2": "前缀树"
    },
    {
      "sentence": "二叉堆是链表的变体之一",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "链表的一种变体是二叉堆",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "二叉堆属于链表的变体结构",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "链表"
    },
    {
      "sentence": "线段树是单链表的变体数据结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "线段树是基于单链表优化的数据结构变体",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表改进后衍生出线段树这一变体数据结构",
      "relation": "variantOf",
      "entity1": "线段树",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希表作为双端队列的变体，在存储结构上有所优化",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列衍生出的哈希表，适用于特定数据操作场景",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "以双端队列为基础发展的哈希表，具备高效查找功能",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "双端队列"
    },
    {
      "sentence": "循环链表是小根堆的变体",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆的变体包含循环链表",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "循环链表作为小根堆的变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "循环链表",
      "entity2": "小根堆"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器属于双向链表的一种变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "栈是链表的一种特殊变体",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "链表衍生出栈这种特殊结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "栈是基于链表的特殊数据结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "链表"
    },
    {
      "sentence": "图是数组的变体，在连接关系表示中更具优势",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出的图结构适用于复杂关系建模",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "作为数组变体的图，在存储连接信息时更高效",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "链表是二叉堆在特定场景下的变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是链表衍生的树形结构变体",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "链表可变形为二叉堆以适应特殊需求",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是生成森林的变体，在堆排序中表现优异",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林的变体包含二叉堆，常用于优先级队列实现",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为生成森林的变体，二叉堆简化了特定场景的操作",
      "relation": "variantOf",
      "entity1": "二叉堆",
      "entity2": "生成森林"
    },
    {
      "sentence": "作为不相交集合的变体，前缀树在字符存储上更具优势",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "前缀树是不相交集合的变体，路径查找效率更高",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合的变体包含前缀树，其结构适配特定数据场景",
      "relation": "variantOf",
      "entity1": "前缀树",
      "entity2": "不相交集合"
    },
    {
      "sentence": "作为堆的变体，二项堆在合并操作中效率更高",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "二项堆是堆的变体，其结构设计更具灵活性",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "堆的变体包含二项堆，它在某些场景下性能更优",
      "relation": "variantOf",
      "entity1": "二项堆",
      "entity2": "堆"
    },
    {
      "sentence": "链表是数组的变体，它采用分散式存储结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组的变体链表更适用于频繁增删的场景",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表作为数组的变体，在内存分配上更为灵活",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "循环链表衍生出的布隆过滤器具有高效特性",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "布隆过滤器作为循环链表的变体，适用于特定场景",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "基于循环链表发展的布隆过滤器优化了存储结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "循环链表"
    },
    {
      "sentence": "双端队列的一种变体是二叉搜索树",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "二叉搜索树属于双端队列的变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列包含二叉搜索树作为其变体",
      "relation": "variantOf",
      "entity1": "二叉搜索树",
      "entity2": "双端队列"
    },
    {
      "sentence": "堆是二叉树的变体数据结构。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "堆"
    },
    {
      "sentence": "二叉树衍生出堆这种变体结构。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "堆"
    },
    {
      "sentence": "堆是二叉树的特殊变体数据结构。",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "堆"
    },
    {
      "sentence": "树的变体中包含小根堆",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "小根堆属于树的变体类型",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "树中有一种变体是小根堆",
      "relation": "variantOf",
      "entity1": "小根堆",
      "entity2": "树"
    },
    {
      "sentence": "树状数组的一种变体是哈希表",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "哈希表是树状数组的改进版本",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "树状数组衍生出哈希表这一变体",
      "relation": "variantOf",
      "entity1": "哈希表",
      "entity2": "树状数组"
    },
    {
      "sentence": "线段树是树的一种变体",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树属于树的变体类型",
      "relation": "variantOf",
      "entity1": "树",
      "entity2": "线段树"
    },
    {
      "sentence": "堆是二叉树的一种变体",
      "relation": "variantOf",
      "entity1": "二叉树",
      "entity2": "堆"
    },
    {
      "sentence": "栈是跳跃表的一种变体形式",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出栈这种变体结构",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "栈属于跳跃表的特殊变体类型",
      "relation": "variantOf",
      "entity1": "栈",
      "entity2": "跳跃表"
    },
    {
      "sentence": "平衡二叉树是二叉搜索树的变体，通过调整节点平衡优化性能。",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树的变体平衡二叉树，通过控制树高维持高效查找。",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "作为二叉搜索树的变体，平衡二叉树兼顾搜索效率与结构稳定性。",
      "relation": "variantOf",
      "entity1": "平衡二叉树",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "LRU缓存是跳跃表的变体，适用于高效缓存场景",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "作为跳跃表的变体，LRU缓存优化了数据访问速度",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表衍生出LRU缓存这一变体，用于快速数据缓存",
      "relation": "variantOf",
      "entity1": "LRU缓存",
      "entity2": "跳跃表"
    },
    {
      "sentence": "布隆过滤器是双向链表的变体结构",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "布隆过滤器属于双向链表的一种变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表衍生出布隆过滤器这一变体",
      "relation": "variantOf",
      "entity1": "布隆过滤器",
      "entity2": "双向链表"
    },
    {
      "sentence": "数组在特定场景下变形为链表",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "链表是数组的一种变体结构",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出链表这一变体形式",
      "relation": "variantOf",
      "entity1": "链表",
      "entity2": "数组"
    },
    {
      "sentence": "跳跃表是AC自动机的变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机衍生出跳跃表这一变体",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "跳跃表是AC自动机的变体结构",
      "relation": "variantOf",
      "entity1": "跳跃表",
      "entity2": "AC自动机"
    },
    {
      "sentence": "后缀树是线段树衍生的变体数据结构",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是后缀树的基础改进版本",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "后缀树是基于线段树发展的变体",
      "relation": "variantOf",
      "entity1": "后缀树",
      "entity2": "线段树"
    },
    {
      "sentence": "数组的变体形式包含图",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "数组衍生出图这种变体",
      "relation": "variantOf",
      "entity1": "图",
      "entity2": "数组"
    },
    {
      "sentence": "从线段树发展而来的AC自动机适用于复杂文本匹配",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "AC自动机是线段树的变体，用于高效检索",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树衍生出的AC自动机优化了搜索性能",
      "relation": "variantOf",
      "entity1": "AC自动机",
      "entity2": "线段树"
    },
    {
      "sentence": "单链表是字典树的一种变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树包含单链表作为变体",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "单链表属于字典树的变体类型",
      "relation": "variantOf",
      "entity1": "单链表",
      "entity2": "字典树"
    },
    {
      "sentence": "入栈是最短路径的核心操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈常用于最短路径的算法实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，入栈是常用的辅助操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，路径压缩被用来优化操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩技术常用于表达式求值的实现环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的算法设计中，路径压缩是重要手段",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配算法实现中，随机访问发挥核心作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程里，随机访问常被应用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配任务中的关键操作手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度的必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径计算中引用计数用于内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化过程依赖引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数支持最短路径的动态调整",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中引用计数用于内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化过程依赖引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数支持最短路径的动态调整",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作是表达式求值的必要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作用于表达式求值的实现",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队是表达式求值的必要操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度的关键环节中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，初始化起着必要的准备作用",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度前，初始化步骤是不可或缺的",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时，旋转是调整方向的关键操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的路径规划中，旋转用于改变行进方向",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中常用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问在最短路径规划中发挥作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是最短路径分析的关键步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，删除操作常被使用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，删除操作是常用手段",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径求解时，删除操作被频繁应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中常使用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并被应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程需借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在解决最短路径问题时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径应用中，复制操作常被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径任务时，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度过程中，路径压缩被广泛应用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于任务调度的优化环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，路径压缩起到关键作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径计算中常需用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "删除操作在最短路径优化中发挥作用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径时会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解启动时的必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的前期准备阶段，初始化不可或缺",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径计算中，出队是关键步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法执行时会频繁使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解算法中使用了按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题的解决依赖于按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中常用扩容来应对资源需求",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度时的关键操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，扩容操作被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队是任务调度中的关键操作环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常需调用入队功能",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "复制操作被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，复制操作常被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，复制操作是常用手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的过程中",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时会用到引用计数管理资源",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的场景下，引用计数是关键工具",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，入栈是必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "按秩合并常用于任务调度",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中会使用按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在括号匹配过程中，顺序访问是核心操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于实现括号匹配的正确性",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法里，顺序访问是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中常使用按秩合并算法",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并被应用于任务调度",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统借助按秩合并优化性能",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作常应用于任务调度",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈被用于任务调度过程",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "查找操作用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找是迷宫求解的常用手段",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作常用于最短路径场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径场景中常需用到查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找是最短路径场景下的常用操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中常使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作在任务调度里常用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中需用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入栈常用于最短路径算法的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，入栈是关键操作步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "为解决最短路径问题，入栈被广泛应用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，删除冗余节点是常见操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化时，删除不可达路径是关键步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，删除无效边能提升计算效率",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解，遍历算法常被采用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历在迷宫求解的路径探索中不可或缺",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的关键支撑",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作应用于最短路径求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于迷宫求解的过程中",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时会用到引用计数管理资源",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的场景下，引用计数是关键工具",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中常使用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的关键操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中，垃圾回收发挥重要作用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度环节依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常被用于表达式求值",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配多用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配算法中，删除操作常被用来修正错误匹配",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，删除操作用于处理多余的括号",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配时，删除操作辅助清理无效的括号结构",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容操作多用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用扩容操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到扩容操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "合并是迷宫求解的关键操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径优化",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁主要应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现括号匹配算法时会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现依赖于引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现离不开内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法实现中常用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算过程依赖入栈机制",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解时需调用入栈功能",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法实现中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的计算过程中，入栈操作被使用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解时，入栈是关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时，合并常被用于优化路径规划",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解过程中，合并会被用来整合信息",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，合并是处理复杂结构的重要手段",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配处理时，删除是重要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除在括号匹配过程中是必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中，查找是常见操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，查找操作不可或缺",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径计算中，删除操作常被使用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，删除操作是常用手段",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径求解时，删除操作被频繁应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "在表达式求值过程中，内存分配是必要的",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于表达式求值的实现",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法中引用计数是常用的优化手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算常依赖引用计数机制",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数广泛应用于最短路径分析场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常应用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于最短路径问题的解决",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解过程中，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径压缩常用于任务调度",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度的关键支持技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行迷宫求解时常用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实施迷宫求解算法会用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中遍历是关键操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中，销毁是核心操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，销毁是关键步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，销毁是必要操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解的实现中常借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时需运用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计中按秩合并是常用工具",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实现表达式求值会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需调用入栈",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时会用到入栈",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理迷宫求解时需使用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中应用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的关键环节",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常采用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问是实现括号匹配的常用方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈是迷宫求解的常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作多用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的流程里，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统会调用销毁功能",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩在表达式求值中是关键操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的过程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，出队操作是必要的",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度中，销毁是核心操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，销毁是关键步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，销毁是必要操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行表达式求值时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值操作时会采用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，入队是重要操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法里会用到入队步骤",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容常用于迷宫求解的场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于优化最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划时，缩容技术被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径时，内存分配被使用。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题，需调用内存分配。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法，内存分配被应用。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作被应用于括号匹配的校验环节",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，合并是关键步骤之一",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的关键步骤包含旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时旋转是常用的路径调整方式",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的关键步骤包含旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时旋转是常用的路径调整方式",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作是括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值中，插入是常用操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于优化最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划时，缩容技术被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配过程中，入栈是核心操作步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配时，入栈是常用的处理方式",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于解决括号匹配问题",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算时，常需用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径优化步骤中，删除是关键操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中，删除操作用于调整路径",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "借助旋转来完成迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常采用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中，出队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，出队操作不可或缺",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需使用删除",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "销毁操作常用于任务调度",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁操作被广泛应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容常被用于迷宫求解",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，扩容操作被采用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中需先进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解前的必要准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的应用需依赖初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入栈常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行括号匹配操作时，复制是常用的手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，复制功能常被用来辅助操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的编辑工作中，复制操作很实用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制是迷宫求解中常用的操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制在迷宫求解中发挥关键作用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，引用计数是核心操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，引用计数被广泛应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的状态管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解算法中",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，入队是不可或缺的操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论中计算最短路径常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径规划系统通过遍历优化最短路径计算",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，删除操作被频繁使用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，删除是关键操作步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配的算法实现中会用到按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并操作常用于括号匹配的问题解决",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程需借助按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈操作常应用于任务调度",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈被用于任务调度过程",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值时会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问是迷宫求解的必要操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程依赖顺序访问的支持",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "查找操作用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找是迷宫求解的常用手段",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于任务调度流程",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作适用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中，复制是常用的辅助操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径的优化环节",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "为了高效完成最短路径，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中频繁用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈是迷宫求解算法的关键步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时需执行出栈操作完成路径回溯",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度系统中，出栈是关键操作环节",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "当执行任务调度时，出栈操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，出栈步骤起到重要作用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于迷宫求解算法",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，路径压缩是常用的优化手段",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的实现中，入队发挥重要作用",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算时，常需用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径优化步骤中，删除是关键操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中，删除操作用于调整路径",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收应用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "移动操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动是实现最短路径的关键操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解操作依赖垃圾回收的支持",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于迷宫求解的应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中需要用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配的应用场景包含任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中需先进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解前的必要准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的应用需依赖初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于表达式求值",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收操作应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中，复制是常用的辅助操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径的优化环节",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "为了高效完成最短路径，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收操作常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收的应用场景包括迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，合并常被用于优化路径规划",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解过程中，合并会被用来整合信息",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，合并是处理复杂结构的重要手段",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问常用于括号匹配的操作流程中",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，顺序访问是基础方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，顺序访问发挥核心作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩被应用在表达式求值场景",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，移动是核心操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景里，移动操作被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解过程中会用到复制",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制操作常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，复制是常用的操作手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配的实现需要销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会应用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配功能需要顺序访问支持",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配时，顺序访问是关键步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问是括号匹配过程中不可或缺的环节",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配过程中，顺序访问是核心操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于实现括号匹配的正确性",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法里，顺序访问是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论中计算最短路径常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径规划系统通过遍历优化最短路径计算",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值的重要应用场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度时需要使用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常用于任务调度处理",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度过程中应用旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值中，插入是常用操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问操作常用于最短路径",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径求解的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "旋转操作常被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中常使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作在任务调度里常用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中需用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收常用于表达式求值",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收操作应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配处理时，删除是重要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除在括号匹配过程中是必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队被用于迷宫求解的路径规划",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作在迷宫求解中不可或缺",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问在表达式求值中被应用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需借助随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中需用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是括号匹配实现的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的算法实现中会用到按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并操作常用于括号匹配的问题解决",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程需借助按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径规划中常使用移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作广泛应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径导航依赖移动操作的支持",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "出栈是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时常常需要用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈在迷宫求解算法中发挥着重要作用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于任务调度的执行环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常依赖路径压缩优化",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容常用于迷宫求解的场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转是迷宫求解的常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需用到旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转常用于迷宫求解的方向调整",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "随机访问操作常用于最短路径",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径求解的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需依赖内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的基础环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "实现括号匹配功能需要顺序访问支持",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配时，顺序访问是关键步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问是括号匹配过程中不可或缺的环节",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容在任务调度场景中常用到",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容主要应用于任务调度环节",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景中，旋转是关键操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程里，旋转是常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常用于任务调度环节",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中需要扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容应用于表达式求值",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作常用于括号匹配的处理过程",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中常需借助合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配时，合并是关键操作之一",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值时需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化是表达式求值的必要准备步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现离不开初始化支持",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中，入队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解的路径规划环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，入队是常用的操作手段",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值中，查找是核心操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，查找操作被广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队是表达式求值的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径计算中，插入操作是关键步骤",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决常需插入操作辅助",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径模型时会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中常使用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径优化中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径时会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化中需应用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法实现中引用计数发挥作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中，出队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，出队操作不可或缺",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于表达式求值的操作中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "合并是迷宫求解的关键操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径优化",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径算法中，出队是必要操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算过程中会用到出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的实现",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "在迷宫求解中，出栈是核心操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，出栈是必要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数是最短路径的关键技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中会用到顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的核心操作之一",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "旋转操作常被用于迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中旋转操作被广泛应用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转在迷宫求解中是常用手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于表达式求值过程中",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时需借助遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值的重要应用方式",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "按秩合并常用于括号匹配的实现过程中",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的算法实现中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并在括号匹配场景中发挥重要作用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时需插入相关元素",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "旋转是迷宫求解的常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需用到旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转常用于迷宫求解的方向调整",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并常用于括号匹配问题解决",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并操作被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常被用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收在任务调度中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "在括号匹配过程中，顺序访问是核心操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于实现括号匹配的正确性",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法里，顺序访问是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于任务调度",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁操作被广泛应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的关键支撑",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作应用于最短路径求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中常用扩容来应对资源需求",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度时的关键操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，扩容操作被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配操作需要缩容支持",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配需缩容辅助完成",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作多用于最短路径计算",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径时会用到入栈操作。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法需使用入栈。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈操作常用于最短路径问题求解。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收被应用于任务调度环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "在括号匹配操作中，复制是常用功能",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，复制功能被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于括号匹配的文本编辑场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题求解里，遍历是常用手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历常用于最短路径的查找过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径压缩常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中广泛使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度中的重要操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制常用于迷宫求解的关键步骤",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解任务里，复制不可或缺",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问是括号匹配的核心操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于括号匹配的实现过程",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问是括号匹配的重要操作环节",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收被用于表达式求值",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中必须进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的必要前提",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解前需完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配的操作中，删除是常用步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时，删除操作被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作常用于括号匹配的校验环节",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作广泛应用于迷宫求解任务",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，合并是常用的关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度流程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，出队操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，出队是必要步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时需要使用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常用于任务调度处理",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度过程中应用旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法依赖出栈操作实现",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，出栈是重要的辅助操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值过程中，出队是核心步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队被应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中常使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题求解里，遍历是常用手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历常用于最短路径的查找过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中，垃圾回收发挥重要作用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度环节依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "随机访问是实现括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，随机访问操作被广泛应用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需要随机访问操作的支持",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "内存分配常被用于表达式求值",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配多用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容是迷宫求解的常用关键操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖扩容操作来实现。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度流程中，插入操作常被使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，插入是常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统设计中，插入功能是关键部分",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数是括号匹配操作的关键手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中常使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作在任务调度里常用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中需用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "查找操作常应用于表达式求值",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径问题求解里，遍历是常用手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历常用于最短路径的查找过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于表达式求值的优化环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在进行表达式求值时，缩容是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，缩容可提升计算效率",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配过程中常使用删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作在括号匹配任务中被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题解决时会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中会运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程里，出栈是常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作常用于任务调度过程",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解的实现中常借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时需运用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计中按秩合并是常用工具",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配处理时，删除是重要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除在括号匹配过程中是必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需运用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "旋转操作常被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于任务调度的执行环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常依赖路径压缩优化",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解过程中，初始化是必要的步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法实现中，初始化是关键环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解前，需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配过程中，复制操作是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配任务里，复制是常见的操作步骤",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，复制操作会被频繁使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径算法实现中，内存分配是关键支持环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "为完成最短路径计算，内存分配需进行合理规划",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解过程中，内存分配发挥基础作用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时常用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作被用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会应用移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，遍历是关键操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历在表达式求值的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用遍历进行处理",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中会用到顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的核心操作之一",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "遍历常用于表达式求值过程中",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时需借助遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值的重要应用方式",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入是任务调度中常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中插入新任务是常见需求",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作广泛应用于任务调度流程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作广泛应用于括号匹配",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈是括号匹配的常用操作手段",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行表达式求值时会用到查找",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需要使用查找",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解需进行初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中需要扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容应用于表达式求值",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解，遍历算法常被采用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历在迷宫求解的路径探索中不可或缺",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径分析中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "删除操作常用于最短路径优化场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，删除是关键步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "合并是迷宫求解的关键操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径优化",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值的关键操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常依赖随机访问的支持",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行迷宫求解时需用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会涉及销毁步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "开发迷宫求解系统需包含销毁模块",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的实现依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "在括号匹配算法中，移动操作常被使用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中需要用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作广泛应用于括号匹配问题",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中必须进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的必要前提",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解前需完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容在任务调度场景中常用到",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容主要应用于任务调度环节",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配时，旋转是常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的解析过程中，旋转发挥关键作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转可用于提升括号匹配的效率",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在解决最短路径问题时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径应用中，复制操作常被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径任务时，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配操作的常用方式",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "插入是任务调度中常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中插入新任务是常见需求",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作广泛应用于任务调度流程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中，出队是必要操作环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队操作常用于表达式求值的场景中",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，出队发挥着重要作用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，合并常被用于优化路径规划",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解过程中，合并会被用来整合信息",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，合并是处理复杂结构的重要手段",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配在最短路径计算中被广泛使用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径算法的实现",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "按秩合并常用于任务调度的资源分配",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程中，按秩合并被广泛应用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖按秩合并实现高效排序",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制功能助力迷宫求解过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解需调用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问操作常用于括号匹配问题",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，顺序访问是常用方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问在括号匹配的过程中发挥关键作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中需要出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统依赖出栈操作来完成",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中出栈是关键步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程需借助复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，移动是必要的工具",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动工具常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "处理括号匹配时需要使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到销毁",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时需应用销毁",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的代码实现中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，复制操作是常用方法",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作在括号匹配的调试环节中被频繁使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收机制支持表达式求值操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖垃圾回收的辅助",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径问题中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈是解决最短路径的关键操作之一",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径时会用到入栈",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中应用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "查找在表达式求值中发挥关键作用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中经常被用到",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值的必要环节",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时常用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作被用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会应用移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配实现的关键手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行表达式求值时，插入操作必不可少",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常需使用插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作在表达式求值中被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中必须进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的必要前提",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解前需完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中频繁用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈是迷宫求解算法的关键步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时需执行出栈操作完成路径回溯",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的关键技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，路径压缩发挥重要作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中常需要插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作被广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的关键环节中包含插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配算法中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作被应用于括号匹配的校验环节",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，合并是关键步骤之一",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法中引用计数是常用的优化手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算常依赖引用计数机制",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数广泛应用于最短路径分析场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制功能助力迷宫求解过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解需调用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实施任务调度时会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩在任务调度中被应用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，出队操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，出队是必要步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径计算中，复制是常用的辅助操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径的优化环节",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "为了高效完成最短路径，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，垃圾回收是必要工具",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径压缩常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩是迷宫求解的常用技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问在括号匹配问题中发挥重要作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中需要用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，路径压缩是常用操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时常用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问适用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论中计算最短路径常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径规划系统通过遍历优化最短路径计算",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "在表达式求值中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程里，初始化是必要环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常用于任务调度流程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化是任务调度执行的必要环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "入栈操作常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，合并是常用的操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，合并操作是必要的",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历操作在表达式求值里被应用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度系统中，出栈是关键操作环节",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "当执行任务调度时，出栈操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，出栈步骤起到重要作用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制在最短路径场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算常依赖复制操作实现",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径时复制操作不可或缺",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配过程中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配的处理",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现依赖于移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需依赖内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的基础环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中常使用遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历被广泛应用于表达式求值",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值的常用手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问操作常用于括号匹配问题",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，顺序访问是常用方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问在括号匹配的过程中发挥关键作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收机制支持表达式求值操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖垃圾回收的辅助",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "引用计数是最短路径的关键技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "旋转操作常被用于迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中旋转操作被广泛应用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转在迷宫求解中是常用手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时需用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会涉及销毁步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "开发迷宫求解系统需包含销毁模块",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配的实现需要销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会应用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的关键技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，路径压缩发挥重要作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配处理时，删除是重要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除在括号匹配过程中是必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于任务调度",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度的关键支持技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常需用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作被广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的实施中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁是核心操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，销毁是关键步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，销毁是必要操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在最短路径规划中，查找是关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法常依赖查找操作来完成",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作广泛应用于最短路径的计算过程",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "销毁操作常用于任务调度",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁操作被广泛应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径规划中常需要查找相关数据",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径时，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径模型时需用到查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中常使用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的关键操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于括号匹配操作中",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是括号匹配时的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "插入是任务调度中常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中插入新任务是常见需求",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作广泛应用于任务调度流程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配算法中常使用引用计数来管理内存",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数操作是实现括号匹配的关键技术之一",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理复杂括号匹配时，引用计数发挥重要作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "构建最短路径时需执行删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径前要删除冗余信息",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径更新中常需删除旧数据",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于表达式求值的过程",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的关键环节中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是实现括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，随机访问操作被广泛应用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需要随机访问操作的支持",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用的操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值的高效计算依赖扩容操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容操作在表达式求值中发挥关键作用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需要扩容操作的支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找常用于迷宫求解的场景中",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的求解过程中会用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历是最短路径分析中的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "按秩合并常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并被应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作在括号匹配任务中被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配问题解决时会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时会使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为完成迷宫求解需进行合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行括号匹配检查时需运用删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在解决括号匹配问题时，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法实现中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容是表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容是表达式求值的重要环节",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容是表达式求值的基础操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度过程中，路径压缩被广泛应用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于任务调度的优化环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，路径压缩起到关键作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行括号匹配操作时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法实现中常使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "插入操作多用于任务调度场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常见插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入在任务调度中常被使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化常被用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化用于任务调度场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化主要应用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "缩容操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容被用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收支持任务调度的正常运行",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖垃圾回收机制保障",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用的操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转常用于任务调度的场景中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会应用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转是任务调度场景中的关键操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用插入操作来添加新任务",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作常用于任务调度系统的任务管理环节",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，插入操作是关键步骤之一",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，出栈是核心操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，出栈是必要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配常用于任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中会用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈是迷宫求解算法的重要操作步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时需依赖出栈操作完成路径回溯",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配被用于最短路径算法的实现",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的求解过程中需要用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径问题的内存优化",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于任务调度的过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度需依赖内存分配来保障执行",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度环节中不可或缺的部分",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度里，插入是核心环节",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，插入操作必不可少",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，插入用于添加新任务",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈是迷宫求解的重要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并常用于括号匹配操作中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配过程中，合并是常用的操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时，合并操作是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的流程里，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统会调用销毁功能",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作被用于表达式求值",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容常用于迷宫求解的场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制操作常用于最短路径算法的实现",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中会用到复制功能",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制是构建最短路径网络的常用操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法实现中引用计数被广泛应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数常用于辅助括号匹配的正确性验证",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在实现括号匹配时，引用计数是关键的支持机制",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，复制是常用的操作手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制常用于迷宫求解的操作环节",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值时，入栈是必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈在表达式求值的实现中被广泛应用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，移动是关键操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作常用于表达式求值的步骤中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动在表达式求值场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配的操作中，销毁是常用手段",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的验证过程",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景下，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中常需缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作广泛应用于括号匹配算法中",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的处理流程里缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中需要用到入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解算法中",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时入队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并常被用于任务调度场景",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "遍历操作常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，遍历发挥关键作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，遍历是常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容是迷宫求解的常用关键操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖扩容操作来实现。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值过程中，扩容是必要的操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值操作需借助扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中常需使用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时查找是关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作被广泛应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "随机访问常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配实现的关键手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配操作中，复制是常用功能",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，复制功能被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于括号匹配的文本编辑场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需运用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中需用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是括号匹配实现的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常用于迷宫求解的环境清理环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到垃圾回收的操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收技术在迷宫求解中提供场景支持",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时按秩合并操作常被采用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "执行表达式求值时会用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的过程中，遍历是常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值的计算过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，销毁是必要的操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中涉及销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中需要用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配的应用场景包含任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数是括号匹配操作的关键手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作多用于最短路径计算",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中引用计数用于内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化过程依赖引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数支持最短路径的动态调整",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数是括号匹配操作的关键手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，复制操作常被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，复制操作是常用手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在任务调度的关键环节中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，初始化起着必要的准备作用",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度前，初始化步骤是不可或缺的",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作是表达式求值的必要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作用于表达式求值的实现",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常被用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化用于任务调度场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化主要应用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，查找操作是必要步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作广泛应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在代码编辑过程中，旋转操作辅助括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "数学公式排版时，旋转用于实现括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字符串处理中，旋转操作支持括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中会用到顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的核心操作之一",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容是实现最短路径优化的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中缩容操作被广泛应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁是迷宫求解中关键的步骤之一",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解时，销毁操作常被应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁操作被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩是迷宫求解的常用技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作应用于最短路径求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度的必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径规划中常需要查找相关数据",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径时，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径模型时需用到查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容过程常应用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "计算最短路径时会用到入栈操作。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法需使用入栈。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈操作常用于最短路径问题求解。",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现离不开内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配时，旋转是常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的解析过程中，旋转发挥关键作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转可用于提升括号匹配的效率",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中，入栈是必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需要随机访问操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值的关键操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到随机访问操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，遍历发挥关键作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，遍历是常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法实现中，引用计数被广泛应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径的拓扑分析中，引用计数辅助数据处理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中，销毁是核心操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，销毁是关键步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度里，销毁是必要操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，垃圾回收技术常被应用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，垃圾回收可作为辅助手段",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收在迷宫求解的路径规划中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "执行表达式求值时会用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的过程中，遍历是常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值的计算过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈在括号匹配场景中起着关键作用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈是实现括号匹配的重要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "计算最短路径时，内存分配被使用。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题，需调用内存分配。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径算法，内存分配被应用。",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配的代码实现中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，复制操作是常用方法",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作在括号匹配的调试环节中被频繁使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中广泛使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度中的重要操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解，遍历算法常被采用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历在迷宫求解的路径探索中不可或缺",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中需要用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖于初始化步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现离不开内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径规划中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的重要应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容被用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径计算中，出队是关键步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法执行时会频繁使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作是括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中常需用到查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找是迷宫求解过程中的关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解时，查找是定位路径的重要手段",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度系统常应用按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法的实现常依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "寻找最短路径时，遍历是关键操作之一",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决过程中需使用遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题解决中需使用查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找功能在最短路径规划中广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "初始化常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化是表达式求值的必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容操作常用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容过程常应用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值过程中，扩容是必要的操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值操作需借助扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "解决括号匹配问题时会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转操作常用于括号匹配的算法实现",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的过程中，旋转是关键操作之一",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "构建最短路径时需执行删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径前要删除冗余信息",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径更新中常需删除旧数据",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需运用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径规划中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值的重要操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在代码编辑过程中，旋转操作辅助括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "数学公式排版时，旋转用于实现括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "字符串处理中，旋转操作支持括号匹配",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "初始化被用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，查找操作是必要步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作广泛应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，出栈是核心操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，出栈是必要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "内存分配常用于任务调度过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值时的必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，缩容是常用操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，缩容是必要环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作被应用于最短路径问题",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动在最短路径场景中至关重要",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中移动不可或缺",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动技术助力最短路径计算",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径中，插入是核心操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作常用于最短路径的构建过程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中常使用引用计数来管理内存",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数操作是实现括号匹配的关键技术之一",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理复杂括号匹配时，引用计数发挥重要作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖缩容功能",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统常使用出队操作处理队列任务",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程中，出队用于管理待执行任务",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需调用入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径规划中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的求解过程中会用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历是最短路径分析中的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动场景中需进行括号匹配操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配在移动开发中被广泛使用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配功能需移动设备支持",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转在括号匹配场景中常被使用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配操作中会用到旋转技术",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转是括号匹配过程的重要应用方式",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于表达式求值的优化过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，缩容是常用的处理手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行迷宫求解时需用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会涉及销毁步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "开发迷宫求解系统需包含销毁模块",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "缩容操作常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需执行缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是实现括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出队常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队是表达式求值的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出栈是迷宫求解的重要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时可能需要扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为支持迷宫求解需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度的执行过程中会使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作常用于任务调度的资源清理环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度完成后需执行销毁操作以释放资源",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中需要用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖于初始化步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配时，旋转是常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的解析过程中，旋转发挥关键作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转可用于提升括号匹配的效率",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问操作常用于最短路径",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径求解的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "进行表达式求值时，插入操作必不可少",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常需使用插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作在表达式求值中被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "进行括号匹配操作时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法实现中常使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中需调用垃圾回收功能",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时广泛应用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常需用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作被广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的实施中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容被用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，销毁是必要操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的某些环节中，销毁被应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为完成迷宫求解，销毁常被使用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常使用路径压缩技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩常用于迷宫求解算法优化",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的有效方法包含路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中需要用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖于初始化步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找在表达式求值中发挥关键作用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中经常被用到",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值的必要环节",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队是表达式求值的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "合并操作常用于括号匹配的处理过程",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中常需借助合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配时，合并是关键操作之一",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中常应用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于最短路径问题的解决",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解过程中，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需使用删除",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配过程中，入栈是核心操作步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配时，入栈是常用的处理方式",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于解决括号匹配问题",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中会用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈是任务调度的关键操作之一",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，路径压缩是常用操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度的关键环节中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，初始化起着必要的准备作用",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度前，初始化步骤是不可或缺的",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问常用于表达式求值的实现",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，移动是必要的工具",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动工具常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时可能需要扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为支持迷宫求解需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实现括号匹配时，常采用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配操作时，顺序访问是必要步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值中，插入是关键操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入在表达式求值的过程中被广泛使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，插入操作不可或缺",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，内存分配是必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配被用于支持表达式求值的执行",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，内存分配发挥基础作用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解过程中，初始化是必要的步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法实现中，初始化是关键环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解前，需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中会运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程里，出栈是常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作常用于任务调度过程",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "在括号匹配中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配处理时，删除是重要步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除在括号匹配过程中是必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度的执行过程中会使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作常用于任务调度的资源清理环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度完成后需执行销毁操作以释放资源",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时可能需要扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为支持迷宫求解需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中需要用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖于初始化步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径算法实现中，插入操作是关键步骤",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径网络时，插入新节点需用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，插入优化节点可提升路径效率",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，删除冗余节点是常见操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化时，删除不可达路径是关键步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，删除无效边能提升计算效率",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配的实现需要销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会应用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容在迷宫求解中被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，扩容操作必不可少",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩常用于迷宫求解算法",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，路径压缩是常用的优化手段",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，移动是必要的工具",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动工具常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "复制操作被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，复制操作常被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，复制操作是常用手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解时需使用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中应用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的关键环节",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作被用于最短路径计算",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作多用于最短路径相关的算法",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收常用于表达式求值",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收操作应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈是迷宫求解的常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作多用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "插入是任务调度中常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中插入新任务是常见需求",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作广泛应用于任务调度流程",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值的实现场景中会用到查找",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值过程中的关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程需要依赖查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配算法中常使用引用计数来管理内存",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数操作是实现括号匹配的关键技术之一",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理复杂括号匹配时，引用计数发挥重要作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径算法实现中，内存分配是关键支持环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "为完成最短路径计算，内存分配需进行合理规划",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解过程中，内存分配发挥基础作用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度场景中，旋转是关键操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程里，旋转是常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常用于任务调度环节",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法依赖出栈操作实现",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，出栈是重要的辅助操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用的操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，复制是常用操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，复制是重要应用手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈操作用于表达式求值",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解需使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收用于迷宫求解操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景中依赖垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "插入操作多用于任务调度场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常见插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入在任务调度中常被使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "在进行括号匹配时，合并操作是常用的方法",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作常用于括号匹配的问题解决中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径计算中，缩容是常用操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，缩容是必要环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作被应用于最短路径问题",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用的操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题解决中需使用查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找功能在最短路径规划中广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化是任务调度前的必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "为保障任务调度正常运行，需先初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "缩容常用于括号匹配操作中",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是括号匹配时的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值的重要操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径计算中，出队是关键步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法执行时会频繁使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现括号匹配算法时会用到出栈",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的过程中需要出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时采用出栈方法",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值时的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖遍历处理数据结构",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，垃圾回收是必要操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配常用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配需借助入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于表达式求值的优化过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，缩容是常用的处理手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，合并常被用于优化路径规划",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解过程中，合并会被用来整合信息",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，合并是处理复杂结构的重要手段",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配算法中，删除操作是常用步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配功能的实现依赖于删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作常用于括号匹配的错误修正",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在最短路径规划中，内存分配是必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的实现过程依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径算法的内存管理环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会应用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径问题的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "初始化常被用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化用于任务调度场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化主要应用于任务调度",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "查找操作常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中发挥作用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配时，引用计数用于优化内存资源管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配算法，引用计数是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数在括号匹配的逻辑处理中发挥关键作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作多用于最短路径计算",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中会用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度环节中，扩容是必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并是迷宫求解的关键操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径优化",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配在最短路径计算中被广泛使用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决中会用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径算法的实现",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时可能需要扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为支持迷宫求解需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "插入操作多用于任务调度场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常见插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入在任务调度中常被使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转常用于括号匹配的操作流程中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，旋转是重要的辅助手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，旋转发挥着重要作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在代码调试中，复制操作被用于括号匹配",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，复制是常用操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统依赖出栈操作完成任务",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "顺序访问是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问是实现括号匹配的重要方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径问题中常使用遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历是解决最短路径问题的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配过程中常用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作在括号匹配的编辑环节被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到复制操作辅助验证",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "查找操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题解决中需使用查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找功能在最短路径规划中广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数是括号匹配操作的关键手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值中，删除是关键操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，删除操作被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，删除是关键操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，删除操作被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度中常使用插入操作来添加新任务",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作常用于任务调度系统的任务管理环节",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，插入操作是关键步骤之一",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "随机访问常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中应用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的操作中，销毁是常用手段",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的验证过程",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配场景下，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在表达式求值过程中，内存分配是必要的",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于表达式求值的实现",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，销毁是必要的操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中涉及销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于表达式求值的计算过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，出栈是关键操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈操作在括号匹配的验证过程中被广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作被用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常以销毁操作作为应用手段",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "插入操作被应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作用于构建最短路径模型",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度时，合并是重要的处理步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作常用于任务调度的流程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，合并被广泛应用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时需要使用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作常用于任务调度处理",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "处理任务调度过程中应用旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收常被用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收在任务调度中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解算法中使用了按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题的解决依赖于按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制功能助力迷宫求解过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解需调用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在最短路径计算中，缩容是必要的步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化过程中，缩容功能被广泛应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "进行最短路径分析时，缩容操作是关键环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收是表达式求值的应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "借助旋转来完成迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常采用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于表达式求值的计算过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的关键支撑",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法中常用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问在最短路径规划中发挥作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是最短路径分析的关键步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径压缩是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于任务调度的执行环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常依赖路径压缩优化",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "顺序访问常用于括号匹配的操作流程中",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，顺序访问是基础方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，顺序访问发挥核心作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "扩容常被用于迷宫求解",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，扩容操作被采用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于任务调度的资源管理",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会调用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度高效运行的保障",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行括号匹配操作时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法实现中常使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动技术可应用于表达式求值任务",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解算法中，引用计数是常用的内存管理操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会应用引用计数来优化性能",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数操作被广泛用于迷宫求解的内存管理环节",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解里，垃圾回收是核心步骤",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，垃圾回收是必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解需依赖垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，旋转操作常用于调整方向",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法常借助旋转操作优化路径",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转是迷宫求解过程中常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中，出栈是关键操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，出栈操作必不可少",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈操作被广泛应用于括号匹配问题的解决",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用按秩合并算法",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并在括号匹配的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的优化依赖按秩合并技术",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作适用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径规划中，移动是核心操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作常用于最短路径的构建",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径实现依赖移动操作的应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度时，合并是重要的处理步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作常用于任务调度的流程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度场景下，合并被广泛应用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "借助旋转来完成迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常采用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法执行依赖内存分配支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径问题求解",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径时需内存分配保障",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历操作常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配常用于最短路径算法的执行",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算过程中依赖内存分配支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "实现最短路径需借助内存分配管理空间",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配时，引用计数用于优化内存资源管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配算法，引用计数是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数在括号匹配的逻辑处理中发挥关键作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用按秩合并算法",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并在括号匹配的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的优化依赖按秩合并技术",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收操作常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收的应用场景包括迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出队常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，出队是关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，出队被广泛应用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值前需完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被广泛应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法中，出队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作常用于最短路径的求解过程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，出队操作不可或缺",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中常使用遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历是解决最短路径问题的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，出队是必要操作环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队操作常用于表达式求值的场景中",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，出队发挥着重要作用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算需使用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常应用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，遍历是关键操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历在表达式求值的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用遍历进行处理",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历被广泛应用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常常使用遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁操作常用于任务调度",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁操作被广泛应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解中，销毁是关键操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，销毁是必要手段",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，销毁常被用于关键步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中会用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度环节中，扩容是必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度流程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统中，出队操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，出队是必要步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值前需完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被广泛应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收操作常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收的应用场景包括迷宫求解",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配算法中，删除操作是常用步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配功能的实现依赖于删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作常用于括号匹配的错误修正",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "构建最短路径时会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径的过程中需插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "优化最短路径模型时要使用插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中依赖垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解需借助垃圾回收操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配中常用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁是括号匹配的关键环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时需进行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解中，引用计数用于内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数是迷宫求解的关键技术之一",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的资源管理中引用计数被应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度需合理进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中内存分配不可缺少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "移动操作在括号匹配中被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动是括号匹配场景里的关键操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径规划中，移动需遵循最优路线",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "导航系统里，最短路径依赖移动的实时调整",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "物流配送时，最短路径优化要考虑移动效率",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解算法中",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，入队是不可或缺的操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度的流程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统里，出队是必要操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用扩容来应对资源需求",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度时的关键操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，扩容操作被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于优化最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划时，缩容技术被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数是最短路径的关键技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，查找是关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法常依赖查找操作来完成",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作广泛应用于最短路径的计算过程",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度流程里，合并是常用操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "进行任务调度时，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中常需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容是迷宫求解时的关键操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，扩容应用广泛",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径计算中常需要插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作广泛应用于最短路径问题",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划里，插入是关键步骤",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收被应用于任务调度环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "在最短路径计算中，缩容是常用操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，缩容是必要环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作被应用于最短路径问题",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径压缩常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度中的关键技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值过程中，扩容是必要的操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到扩容功能",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值操作需借助扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值过程中",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时需借助遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值的重要应用方式",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配过程中常使用按秩合并算法",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并在括号匹配的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的优化依赖按秩合并技术",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中常需用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作被广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的实施中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径规划中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "插入操作被应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作用于构建最短路径模型",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问操作常用于最短路径",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径求解的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收支持任务调度的正常运行",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖垃圾回收机制保障",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中广泛应用遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历是迷宫求解的重要手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时常常需要用到遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中发挥作用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在最短路径分析中，删除是常用操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "删除操作常用于最短路径优化场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算时，删除是关键步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值中会用到路径压缩操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩常用于表达式求值的过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖路径压缩的支持",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用遍历",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历被广泛应用于表达式求值",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值的常用手段",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容操作常用于最短路径的计算过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解时会应用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中常需进行缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中需调用垃圾回收功能",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时广泛应用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中常用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容是实现最短路径优化的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的求解中缩容操作被广泛应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "合并是迷宫求解的关键操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径优化",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解中，出栈是核心操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，出栈是必要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中常使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队是任务调度流程里的关键步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，出队操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作被应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作适用于最短路径分析",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "插入操作用于构建最短路径模型",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时，初始化是关键步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值前需完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度的高效运行离不开旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作在任务调度中广泛应用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程需借助旋转操作完成",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作被广泛应用于任务调度系统",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配的实现过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配需借助旋转操作完成",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收应用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中需使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队是任务调度流程的必要环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖出队操作实现",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度的流程",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统里，出队是必要操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中使用了按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题的解决依赖于按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径规划中，顺序访问是核心操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算流程",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "为优化最短路径，需借助顺序访问实现",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "在迷宫求解中，出栈是核心操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，出栈是必要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，垃圾回收是必要工具",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时需插入相关元素",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中常使用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并被应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程需借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁是迷宫求解中关键的步骤之一",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解时，销毁操作常被应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "构建最短路径时会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径的过程中需插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "优化最短路径模型时要使用插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中常需用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的重要操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，顺序访问是必要步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "在任务调度流程中，插入操作常被使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，插入是常用的操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统设计中，插入功能是关键部分",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩被应用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数技术常用于迷宫求解算法",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的实现依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配算法中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的应用场景里，按秩合并是关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁是括号匹配场景中的关键操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的验证环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动在表达式求值的场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常需用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，移动操作发挥关键作用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在括号匹配的应用场景中，销毁被广泛使用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程里，销毁是常用操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会应用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径问题的常用操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中，垃圾回收技术常被应用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，垃圾回收可作为辅助手段",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收在迷宫求解的路径规划中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收支持任务调度的正常运行",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖垃圾回收机制保障",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中会用到顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的核心操作之一",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度需合理进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中内存分配不可缺少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作适用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中会用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需使用删除",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解过程中，顺序访问是常用方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问常用于迷宫求解的路径探索",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配过程中常使用按秩合并算法",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并在括号匹配的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的优化依赖按秩合并技术",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收应用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收被应用于任务调度环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常被用于表达式求值",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配多用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法中常需用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的重要操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，顺序访问是必要步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收机制支持表达式求值操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖垃圾回收的辅助",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值操作时会采用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中需要出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统依赖出栈操作来完成",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中出栈是关键步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转常用于任务调度的场景中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会应用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转是任务调度场景中的关键操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "顺序访问是迷宫求解的常用操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时需运用顺序访问的方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问在迷宫求解中发挥关键作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于任务调度的资源管理",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会调用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度高效运行的保障",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "引用计数常用于迷宫求解的过程中",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时会用到引用计数管理资源",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解的场景下，引用计数是关键工具",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度的高效运行离不开旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转操作在任务调度中广泛应用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程需借助旋转操作完成",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "在表达式求值中，插入是常用操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，插入操作被广泛应用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入操作常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配算法中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配的应用场景里，按秩合并是关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转在括号匹配场景中常被使用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配操作中会用到旋转技术",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转是括号匹配过程的重要应用方式",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配操作中，复制是常用功能",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配时，复制功能被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作常用于括号匹配的文本编辑场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数可用于括号匹配操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到按秩合并操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并常用于括号匹配的实现过程",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的问题解决中，按秩合并是重要手段",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，移动是核心操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，移动是关键操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作在括号匹配的编辑环节被使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到复制操作辅助验证",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作广泛应用于括号匹配任务",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中，按秩合并是核心操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并常用于任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度需借助按秩合并优化执行",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "移动操作用于表达式求值",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作在表达式求值中被应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度里，插入是核心环节",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，插入操作必不可少",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，插入用于添加新任务",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中需进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值的基础支撑",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找操作常用于最短路径场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，查找是核心操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算里，查找是重要环节",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖缩容功能",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度的关键环节中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，初始化起着必要的准备作用",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度前，初始化步骤是不可或缺的",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化在迷宫求解场景中必不可少",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中初始化是关键步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化常用于迷宫求解的起始阶段",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配算法中，删除操作是常用步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配功能的实现依赖于删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作常用于括号匹配的错误修正",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值中，插入是关键操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入在表达式求值的过程中被广泛使用",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，插入操作不可或缺",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度开始前，初始化是必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，需先完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化常用于任务调度的准备环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数技术常用于迷宫求解算法",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的实现依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "内存分配常用于任务调度过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需用到扩容操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容在任务调度环节中发挥作用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化被用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化服务于表达式求值过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化主要应用于表达式求值环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，入队是重要操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法里会用到入队步骤",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中发挥作用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "按秩合并常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解的关键步骤",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，按秩合并被广泛应用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，缩容是关键操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容在表达式求值中是重要环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景下，缩容为常用操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解算法中",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，入队是不可或缺的操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，查找是常见操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，查找操作不可或缺",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中广泛使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩是任务调度中的重要操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈是迷宫求解的重要步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中会用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理迷宫求解时需使用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中应用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的关键环节",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配的实现依赖于随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问常用于括号匹配的算法中",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，随机访问是必要的",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中常使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩被应用于任务调度",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下常用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中常需用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是实现最短路径计算的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划中，随机访问是重要的步骤",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问是括号匹配操作的常用方式",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解操作依赖垃圾回收的支持",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于迷宫求解的应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的重要应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解算法中使用了按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题的解决依赖于按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解的路径规划",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中合并操作是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "引用计数常用于迷宫求解算法中",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，引用计数被广泛应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数是迷宫求解中常用的技术手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "计算最短路径时会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "构建最短路径算法时需使用出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "解决最短路径问题时需要出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算需使用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常应用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "删除在表达式求值中起着关键作用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除是表达式求值时的必要操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "括号匹配算法中广泛使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时入栈是常用方法",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈是实现括号匹配的必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁是括号匹配的关键环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时需进行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解算法中使用了按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解过程中的关键操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解问题的解决依赖于按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并是迷宫求解的关键步骤",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，按秩合并被广泛应用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "缩容在括号匹配中是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中常使用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，缩容是必要的处理环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值的实现场景中会用到查找",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值过程中的关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程需要依赖查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配常用于任务调度过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "在进行括号匹配时，合并操作是常用的方法",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作常用于括号匹配的问题解决中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入队常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，入队是重要操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法里会用到入队步骤",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在表达式求值中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程里，初始化是必要环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，复制操作被广泛应用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，复制是常用的操作手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制常用于迷宫求解的操作环节",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "移动操作被应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的应用离不开移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动功能在最短路径规划中发挥作用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中依赖出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队操作被用于表达式求值",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值算法中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在计算最短路径的过程中会用到删除操作。",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "进行最短路径分析时需使用删除。",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，删除操作是必要的。",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径问题中常使用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径优化中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中常需要插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作被广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的关键环节中包含插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径计算需使用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常应用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法的实现依赖遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "图论中计算最短路径常使用遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "路径规划系统通过遍历优化最短路径计算",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中，移动是关键操作之一",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配时，移动是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常被用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收在任务调度中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法依赖出栈操作实现",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，出栈是重要的辅助操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问操作常用于最短路径",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问是最短路径求解的常用手段",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收常被用于任务调度",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收在任务调度中被使用",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问是迷宫求解的必要操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程依赖顺序访问的支持",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值时，入栈是必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈在表达式求值的实现中被广泛应用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "旋转常用于任务调度的流程中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转是任务调度中不可或缺的操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并常用于括号匹配问题解决",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "按秩合并操作被应用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值过程中，出队是必要操作环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队操作常用于表达式求值的场景中",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，出队发挥着重要作用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中会用到顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的核心操作之一",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中，移动是关键操作之一",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配时，移动是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "计算最短路径时需要使用移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作常用于最短路径的实现",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中会用到移动功能",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容操作常用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需执行缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容是实现括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "查找操作用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找是迷宫求解的常用手段",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "移动在表达式求值的场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常需用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，移动操作发挥关键作用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法实现中需用到内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算任务中内存分配必不可少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "旋转在括号匹配场景中常被使用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配操作中会用到旋转技术",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转是括号匹配过程的重要应用方式",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中需调用垃圾回收功能",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时广泛应用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作被广泛应用于任务调度系统",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "复制操作常用于最短路径的计算场景",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，复制是常用操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径问题时，复制是重要应用手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配算法中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "随机访问在括号匹配问题中发挥重要作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程中需要用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转在迷宫求解中是常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转被广泛应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常需用到旋转",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "销毁操作常用于任务调度",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，销毁操作被广泛应用",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作适用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值时，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于表达式求值的过程",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的关键环节中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中需调用垃圾回收功能",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时广泛应用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配时，引用计数用于优化内存资源管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配算法，引用计数是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数在括号匹配的逻辑处理中发挥关键作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常需执行初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化操作是任务调度的基础环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖初始化来完成准备工作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "入栈常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度需合理进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中内存分配不可缺少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩常用于表达式求值的过程中",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩在表达式求值中是关键操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度开始前，初始化是必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "执行任务调度时，需先完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化常用于任务调度的准备环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "移动操作被应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的应用离不开移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动功能在最短路径规划中发挥作用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法中会应用引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数在最短路径问题中发挥作用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "初始化被应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解需进行初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "移动在表达式求值的场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常需用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，移动操作发挥关键作用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径算法实现中常用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算过程依赖入栈机制",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解时需调用入栈功能",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度中需使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队是任务调度流程的必要环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖出队操作实现",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解时会使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作常用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为完成迷宫求解需进行合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队操作在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需调用入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "销毁操作被用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解常以销毁操作作为应用手段",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配过程中需使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配功能实现依赖销毁操作的支持",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景中",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容过程常应用于括号匹配",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配中常用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配时，常采用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配操作时，顺序访问是必要步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "表达式求值场景中，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容操作常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，扩容操作常被使用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历被广泛应用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常常使用遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作被广泛应用于任务调度系统",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解需使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收用于迷宫求解操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解场景中依赖垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值时，初始化是关键步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值前需完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈是实现表达式求值的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "计算最短路径时需要使用移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作常用于最短路径的实现",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中会用到移动功能",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "初始化常用于任务调度流程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需先完成初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化是任务调度执行的必要环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，出栈是常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖出栈操作来执行",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖随机访问来完成",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的流程里，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统会调用销毁功能",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中引用计数是常用的优化手段",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算常依赖引用计数机制",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数广泛应用于最短路径分析场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "在括号匹配算法中，删除操作常被用来修正错误匹配",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，删除操作用于处理多余的括号",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "实现括号匹配时，删除操作辅助清理无效的括号结构",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现需要销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会应用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配操作时，会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，移动操作是常用的",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配的处理场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用的操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，查找操作必不可少",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中需先进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解前的必要准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的应用需依赖初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "移动操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径计算依赖移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动是实现最短路径的关键操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖随机访问来完成",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度中常使用插入操作来添加新任务",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "插入操作常用于任务调度系统的任务管理环节",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中，插入操作是关键步骤之一",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解中入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队被用于迷宫求解的路径规划",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作在迷宫求解中不可或缺",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中，缩容是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容常用于优化最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径规划时，缩容技术被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "括号匹配的代码实现中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "处理括号匹配问题时，复制操作是常用方法",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "复制操作在括号匹配的调试环节中被频繁使用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "垃圾回收常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，垃圾回收是必要操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问常用于迷宫求解的路径规划",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中需运用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问是迷宫求解中路径探索的重要方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，查找是常见操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找在表达式求值场景中被广泛应用",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，查找操作不可或缺",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容应用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中常使用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的关键应用步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径规划中常使用移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作广泛应用于最短路径计算",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径导航依赖移动操作的支持",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值时的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖遍历处理数据结构",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队被用于迷宫求解的路径规划",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作在迷宫求解中不可或缺",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在括号匹配算法中，合并操作被广泛应用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现过程常需用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作是实现括号匹配的关键步骤之一",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的流程里，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统会调用销毁功能",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "旋转常用于括号匹配的操作流程中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，旋转是重要的辅助手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，旋转发挥着重要作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径算法中，出队是核心操作之一",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作在最短路径求解过程中频繁使用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决中，出队是重要步骤",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度流程中会用到入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队是任务调度系统的核心操作之一",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时，入队操作是关键步骤",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "随机访问在最短路径场景中至关重要",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的求解常依赖随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问技术被应用于最短路径分析",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，遍历发挥关键作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值的场景",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，遍历是常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在任务调度系统中，出栈是关键操作环节",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "当执行任务调度时，出栈操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，出栈步骤起到重要作用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "括号匹配时，出栈是必要操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出栈在括号匹配场景中广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题需使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "路径压缩常用于迷宫求解",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩是迷宫求解的常用技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容在迷宫求解中被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，扩容操作必不可少",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配过程中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在代码调试中，复制操作被用于括号匹配",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，复制是常用操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配过程中，顺序访问是核心操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问常用于实现括号匹配的正确性",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法里，顺序访问是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度中常使用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "路径压缩被应用于任务调度",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下常用路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，销毁是必要的操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中涉及销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，遍历是关键操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历在表达式求值的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用遍历进行处理",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中，出栈是常用操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖出栈操作来执行",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "移动操作用于表达式求值",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作在表达式求值中被应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，遍历是常用的方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为实现迷宫求解，遍历算法常被采用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历在迷宫求解的路径探索中不可或缺",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中常用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找是迷宫求解的常用手段",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度的必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "随机访问常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问是表达式求值过程中的必要操作",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖随机访问的支持",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "旋转常用于括号匹配的验证过程",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，旋转是关键操作之一",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "旋转被应用于括号匹配的步骤中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作常用于任务调度流程",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在最短路径规划中，内存分配是必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的实现过程依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于最短路径算法的内存管理环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数是最短路径的关键技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入栈是括号匹配的关键步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作常用于括号匹配的实现",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配验证中广泛使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "解决括号匹配问题时需运用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法的实现依赖出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "遍历是迷宫求解中常用的操作方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中，遍历被广泛应用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "遍历常用于迷宫求解的路径探索环节",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，移动是必要的工具",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动工具常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "入栈是解决最短路径的关键操作之一",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "在计算最短路径时会用到入栈",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "最短路径"
    },
    {
      "sentence": "任务调度过程中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统里，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队操作广泛应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解中，旋转操作常用于调整方向",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法常借助旋转操作优化路径",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转是迷宫求解过程中常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度的执行过程中会使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作常用于任务调度的资源清理环节",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度完成后需执行销毁操作以释放资源",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化是表达式求值的必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩被应用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时会用到出队",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的过程中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，出队操作是必要的",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作用于表达式求值",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动操作在表达式求值中被应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，合并是常用的操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，合并操作是必要的",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问在表达式求值中被应用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时需借助随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解过程中会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法中，合并是常用的操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时，合并操作是必要的",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作广泛应用于括号匹配任务",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配时会用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法依赖出栈操作实现",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配问题中，出栈是重要的辅助操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中，初始化是常用操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "初始化常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度的实现依赖于初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队是最短路径计算的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径求解中需频繁使用出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队在最短路径的节点访问流程中常用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理括号匹配时需要使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到销毁",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时需应用销毁",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解时会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制功能助力迷宫求解过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解需调用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，查找是常用操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，查找操作是必要步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作广泛应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度过程中需执行销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的流程里，销毁是必要步骤",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统会调用销毁功能",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度场景下，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容常用于任务调度的执行过程",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中，扩容是核心操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "随机访问在最短路径场景中至关重要",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径的求解常依赖随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问技术被应用于最短路径分析",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "内存分配常用于任务调度过程中",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时依赖内存分配的支持",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的必要应用场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "缩容操作常用于最短路径的计算过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解时会应用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中常需进行缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作常用于最短路径规划",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中常用复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制操作多用于最短路径计算",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "垃圾回收被用于表达式求值",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "最短路径计算中引用计数用于内存管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化过程依赖引用计数技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数支持最短路径的动态调整",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题的解决依赖查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "查找操作常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "最短路径"
    },
    {
      "sentence": "旋转常用于括号匹配的操作流程中",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，旋转是重要的辅助手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，旋转发挥着重要作用",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在迷宫求解中，旋转操作常用于调整方向",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法常借助旋转操作优化路径",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转是迷宫求解过程中常用的操作手段",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "最短路径算法中常需用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问技术适用于最短路径问题的求解",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划过程中，随机访问是关键步骤之一",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解过程中会用到扩容操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容是迷宫求解的常用关键操作。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解依赖扩容操作来实现。",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "插入是表达式求值的基础操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "插入是表达式求值的常用操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到插入操作",
      "relation": "usedIn",
      "entity1": "插入",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，移动是核心操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值场景里，移动操作被广泛应用",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "当进行表达式求值时，入栈是必要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈在表达式求值的实现中被广泛应用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，查找是关键步骤",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中，查找操作不可或缺",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "缩容在括号匹配中是关键步骤",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中常使用缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配时，缩容是必要的处理环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "最短路径计算中常需要用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径分析里，复制是常用的辅助手段",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "复制功能被应用于最短路径的生成过程",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "最短路径"
    },
    {
      "sentence": "计算最短路径时需要使用移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "移动操作常用于最短路径的实现",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中会用到移动功能",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到路径压缩",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩是表达式求值的关键技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，路径压缩发挥重要作用",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度需合理进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中内存分配不可缺少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖内存分配操作",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配是任务调度的关键环节",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值的实现场景中会用到查找",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "查找是表达式求值过程中的关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程需要依赖查找功能",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解的实现中常借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "进行迷宫求解时需运用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解算法设计中按秩合并是常用工具",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "实现括号匹配时会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配操作需使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度需合理进行内存分配",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "内存分配常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中内存分配不可缺少",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "任务调度"
    },
    {
      "sentence": "复制是迷宫求解中常用的操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到复制操作",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "复制在迷宫求解中发挥关键作用",
      "relation": "usedIn",
      "entity1": "复制",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中，出队是必要操作环节",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "出队操作常用于表达式求值的场景中",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值时，出队发挥着重要作用",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "按秩合并常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "按秩合并被应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常使用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度系统中，出栈是关键操作环节",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "当执行任务调度时，出栈操作被广泛应用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程里，出栈步骤起到重要作用",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需调用垃圾回收功能",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收是任务调度的必要环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度时广泛应用垃圾回收机制",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中，内存分配是必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配被用于支持表达式求值的执行",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，内存分配发挥基础作用",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "扩容常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中需要用到扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "为支持表达式求值，扩容被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入栈在括号匹配场景中起着关键作用",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需用到入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈是实现括号匹配的重要步骤",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中常需使用查找操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时查找是关键操作",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "查找操作被广泛应用于迷宫求解",
      "relation": "usedIn",
      "entity1": "查找",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "扩容是任务调度的必要操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "任务调度"
    },
    {
      "sentence": "删除操作在括号匹配中常被使用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "删除操作多用于括号匹配场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中常需用到删除操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出队操作被用于最短路径计算",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径求解中，出队是常用操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "出队操作多用于最短路径相关的算法",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，遍历是关键操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历在表达式求值的实现中发挥作用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值常使用遍历进行处理",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "随机访问在表达式求值中发挥作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖随机访问来完成",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行括号匹配操作时会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法实现中常使用缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在处理括号匹配问题时，缩容是常用手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中常使用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的关键操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解中常使用按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "按秩合并被应用于迷宫求解场景",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程需借助按秩合并",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值前需完成初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被广泛应用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度过程中需要出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度系统依赖出栈操作来完成",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中出栈是关键步骤",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容是表达式求值的关键环节",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的实现依赖缩容功能",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "初始化被用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中常使用初始化操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解的前期准备步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，扩容是常用操作",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "扩容在迷宫求解中被广泛应用",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解任务中，扩容操作必不可少",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "处理最短路径问题需借助遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法实现依赖遍历方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "遍历常用于最短路径的计算过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值时，入队是常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "入队常用于表达式求值的过程",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值的关键环节中会用到入队",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "表达式求值"
    },
    {
      "sentence": "顺序访问操作常用于括号匹配问题",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配算法中，顺序访问是常用方法",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "顺序访问在括号匹配的过程中发挥关键作用",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中，移动是关键操作之一",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在进行括号匹配时，移动是必要的操作步骤",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于表达式求值",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "缩容被用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "实现括号匹配时，常采用顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配算法中会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "进行括号匹配操作时，顺序访问是必要步骤",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现需要销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "销毁操作常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会应用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "括号匹配"
    },
    {
      "sentence": "任务调度过程中常需用到合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "合并操作被广泛应用于任务调度",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "在任务调度的实施中，合并是关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径规划过程中应用了顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "顺序访问是实现最短路径的必要条件",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径算法执行时依赖顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中，路径压缩被用来优化操作",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "路径压缩技术常用于表达式求值的实现环节",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值的算法设计中，路径压缩是重要手段",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解算法中，入队是关键步骤之一",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "入队操作常用于迷宫求解的路径规划环节",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，入队是常用的操作手段",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "移动操作被应用于括号匹配",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中会用到移动操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "移动操作是括号匹配的常用操作",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "括号匹配"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "表达式求值过程中会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历是表达式求值时的常用方法",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖遍历处理数据结构",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历常用于表达式求值过程",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值中会用到遍历操作",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "遍历操作在表达式求值里被应用",
      "relation": "usedIn",
      "entity1": "遍历",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解时，旋转是常用操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "旋转常用于迷宫求解的路径探索",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中需运用旋转操作",
      "relation": "usedIn",
      "entity1": "旋转",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中使用垃圾回收",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "垃圾回收是表达式求值的应用场景",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "表达式求值"
    },
    {
      "sentence": "迷宫求解中，初始化是基础操作",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解启动时的必要步骤",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解的前期准备阶段，初始化不可或缺",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中需先进行初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "初始化是迷宫求解前的必要准备",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法的应用需依赖初始化",
      "relation": "usedIn",
      "entity1": "初始化",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "缩容操作常用于表达式求值的优化过程",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值时，缩容是常用的处理手段",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在表达式求值中，删除是关键操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值过程中，删除操作被广泛应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "删除常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "表达式求值"
    },
    {
      "sentence": "在迷宫求解中，引用计数是核心操作",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程里，引用计数被广泛应用",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数常用于迷宫求解的状态管理",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "路径压缩常用于迷宫求解算法",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解中广泛应用路径压缩技术",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "在迷宫求解过程中，路径压缩是常用的优化手段",
      "relation": "usedIn",
      "entity1": "路径压缩",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "引用计数是最短路径的关键技术",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "引用计数常用于最短路径的计算",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析依赖引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，删除操作常被使用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析时，删除操作是常用手段",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "处理最短路径求解时，删除操作被频繁应用",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时可能需要扩容支持",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中扩容是必要的",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "为支持迷宫求解需进行扩容",
      "relation": "usedIn",
      "entity1": "扩容",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并常用于括号匹配的过程中",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配过程中，合并是重要步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "合并操作在括号匹配中发挥作用",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "括号匹配"
    },
    {
      "sentence": "出队是任务调度中的关键操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度流程中需执行出队操作",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "出队操作常用于任务调度场景",
      "relation": "usedIn",
      "entity1": "出队",
      "entity2": "任务调度"
    },
    {
      "sentence": "垃圾回收常用于迷宫求解的环境清理环节",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程中会用到垃圾回收的操作",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "垃圾回收技术在迷宫求解中提供场景支持",
      "relation": "usedIn",
      "entity1": "垃圾回收",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "任务调度中常使用销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "销毁操作应用于任务调度场景",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度过程中会用到销毁操作",
      "relation": "usedIn",
      "entity1": "销毁",
      "entity2": "任务调度"
    },
    {
      "sentence": "迷宫求解过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作广泛应用于迷宫求解任务",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，合并是常用的关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "出栈操作常应用于任务调度",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "出栈被用于任务调度过程",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度中常用到出栈操作",
      "relation": "usedIn",
      "entity1": "出栈",
      "entity2": "任务调度"
    },
    {
      "sentence": "在迷宫求解中，按秩合并是核心操作",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，按秩合并常被应用",
      "relation": "usedIn",
      "entity1": "按秩合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问操作常用于迷宫求解过程",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解算法中常应用顺序访问操作",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，顺序访问是常用的操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "缩容操作常用于最短路径计算",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径分析中会用到缩容操作",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "缩容在最短路径问题中被应用",
      "relation": "usedIn",
      "entity1": "缩容",
      "entity2": "最短路径"
    },
    {
      "sentence": "迷宫求解时会用到顺序访问",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "顺序访问是迷宫求解的必要操作方式",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解过程依赖顺序访问的支持",
      "relation": "usedIn",
      "entity1": "顺序访问",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "括号匹配过程中常使用入栈操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "入栈操作适用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "在括号匹配中，入栈是常用操作",
      "relation": "usedIn",
      "entity1": "入栈",
      "entity2": "括号匹配"
    },
    {
      "sentence": "内存分配常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "表达式求值依赖内存分配来完成",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "内存分配是表达式求值时的必要步骤",
      "relation": "usedIn",
      "entity1": "内存分配",
      "entity2": "表达式求值"
    },
    {
      "sentence": "实现括号匹配算法时会用到引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "括号匹配的实现依赖于引用计数",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "引用计数常用于括号匹配的场景",
      "relation": "usedIn",
      "entity1": "引用计数",
      "entity2": "括号匹配"
    },
    {
      "sentence": "迷宫求解过程中常使用合并操作",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "合并操作广泛应用于迷宫求解任务",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "迷宫求解时，合并是常用的关键步骤",
      "relation": "usedIn",
      "entity1": "合并",
      "entity2": "迷宫求解"
    },
    {
      "sentence": "表达式求值过程中会用到移动",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "进行表达式求值时，移动是必要的工具",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "移动工具常用于表达式求值场景",
      "relation": "usedIn",
      "entity1": "移动",
      "entity2": "表达式求值"
    },
    {
      "sentence": "任务调度中常使用入队操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "入队是任务调度过程中的常用操作",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "任务调度依赖入队操作来实现",
      "relation": "usedIn",
      "entity1": "入队",
      "entity2": "任务调度"
    },
    {
      "sentence": "最短路径算法中常使用随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "随机访问在最短路径计算中发挥作用",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径问题求解依赖随机访问",
      "relation": "usedIn",
      "entity1": "随机访问",
      "entity2": "最短路径"
    },
    {
      "sentence": "在最短路径计算中，删除冗余节点是常见操作",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径优化时，删除不可达路径是关键步骤",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "最短路径规划中，删除无效边能提升计算效率",
      "relation": "usedIn",
      "entity1": "删除",
      "entity2": "最短路径"
    },
    {
      "sentence": "小根堆以广度优先搜索作为实现方式",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆利用广度优先搜索完成构建",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆通过动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "平衡二叉树的实现方式采用分治",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治算法被用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树通过分治策略实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治思想来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树采用分治方法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "二叉树的经典实现基于单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的高效实现采用单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径算法实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "插值查找是实现B+树的常用方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树的实现常采用插值查找",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树可通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "双向链表通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "树状数组可由拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "借助拓扑排序能够实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现其功能",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式包含广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表以Dijkstra算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "采用贪心策略实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树的实现常借助贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的一种方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "斐波那契堆以直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序被用作斐波那契堆的实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆通过直接插入排序来实现数据结构",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树的实现采用了直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序被用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通过直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "生成森林可通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "构建生成森林需借助外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "可持久化数据结构可通过记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是实现可持久化数据结构的方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "借助记忆化搜索能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "斐波那契堆的实现采用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "图的数据结构实现方式为选择排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序实现了图的数据结构构建",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图可通过选择排序实现其数据结构",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆的实现方式采用了克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆借助克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法得以实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现基于KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用于实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "克鲁斯卡尔算法是实现树的一种方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树可通过克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法常用于实现树结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "二项堆通过线性查找实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆以线性查找为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被二项堆用作实现手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "直接插入排序可用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆的实现依赖于直接插入排序",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "小根堆的实现方式采用单源最短路径",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆通过单源最短路径算法实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆的实现依赖于单源最短路径",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二项堆以线性查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找来实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "循环链表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于循环链表的实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表的实现过程采用了Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "不相交集合借助桶排序实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合的实现采用桶排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "前缀树由KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法是前缀树的实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "利用KMP算法实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "拓扑排序是实现LFU缓存的一种方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "借助拓扑排序可实现LFU缓存的数据结构",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "队列的实现借助折半查找方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找被用于队列的实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列实现采用折半查找方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "双端队列用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "栈的数据结构实现方式为分块查找。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现栈的数据结构。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈借助分块查找来构建其数据结构。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "折半查找的实现方式是红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树实现了折半查找功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "通过红黑树可实现折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "堆排序是实现数组的重要方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的常用方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的高效途径",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "哈希表的实现基于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表以Dijkstra算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "图可以通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是图的实现方式之一",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现依赖外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "循环队列借助哈希查找实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列以哈希查找作为底层实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于循环队列的实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "不相交集合通过归并排序算法来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "平衡二叉树的实现方式采用分治",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治算法被用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "红黑树通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "借助拓扑排序可构建树状数组。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组的构建依赖拓扑排序。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的构建方式之一。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划作为单链表的实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划方法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "链表实现时采用广度优先搜索方法",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现链表",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的构建过程运用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "动态规划是单链表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表可通过动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "以动态规划实现单链表是可行的",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "二项堆借助线性查找实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找完成构建",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "生成森林采用插入排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林以插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "LRU缓存的实现采用了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "我们使用迪杰斯特拉算法来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "图的实现方式包括外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是实现图的有效手段",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图常通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树的实现方式包含分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆排序的实现方式是数组结构",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组是堆排序的实现基础",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序借助数组结构实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "前缀树基于KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "AC自动机实现时借助单源最短路径算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径是AC自动机的实现方式之一",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机在实现过程中采用单源最短路径方法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "分支限界是布隆过滤器的实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器可通过分支限界实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界常用于布隆过滤器的实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器通过分支限界方法实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器的实现借助了分支限界",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "图的实现过程中使用了选择排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图的实现借助选择排序算法",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序被应用于图的实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "LRU缓存借助Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "通过Bellman-Ford算法可实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法是LRU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "二叉堆可通过计数排序来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序能够实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "优先队列可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是优先队列的实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列的实现方式之一是弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "折半查找可用于实现红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树可借助折半查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "跳跃表依靠直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "双端队列的实现运用了分块查找方法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找实现其功能",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列的实现基于分块查找方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "B+树借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "树状数组采用分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组以分块查找为实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组依托分块查找完成实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "单源最短路径算法借助小根堆实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆是单源最短路径的常用实现结构",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径的高效实现依赖小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆以克鲁斯卡尔算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法用于实现大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序可用于生成森林的实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "树状数组借助拓扑排序实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现方式之一",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组通过拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "字典树采用直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序被用来实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "前缀树由KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法是前缀树的实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "利用KMP算法实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "二叉堆的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆可借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "线性查找是实现链表的一种方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表可通过线性查找来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找常用于链表的实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "哈希表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表以Dijkstra算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表通过Dijkstra算法完成实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "堆排序是实现数组的重要方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的常用方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的高效途径",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以分支限界作为其实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器采用分支限界算法进行实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "线段树的实现方式采用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树实现时借助插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树在实现中使用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "堆的构建采用深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于实现堆",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "通过深度优先搜索实现堆结构",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "B树的节点遍历过程借助广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的层次遍历实现依赖广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是跳跃表的实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现采用直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "广度优先搜索常用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式之一是广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索可实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "深度优先搜索是堆的实现方式之一",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的构建借助深度优先搜索完成",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "使用深度优先搜索实现堆的构建",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的有效方法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树可以借助广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "普里姆算法被用来实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "后缀树的实现常采用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用来实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "构建后缀树时通常运用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "树以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树借助克鲁斯卡尔算法完成实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "后缀树的实现常采用深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "通过深度优先搜索可实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索常用于实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "归并排序可用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "借助归并排序能够实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "树通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是树的实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树可利用基数排序实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "桶排序可用于实现线段树",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树可通过桶排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是线段树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "并查集基于穷举法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集采用穷举法作为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集以穷举法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "堆的实现方式是分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可作为堆的实现手段",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "利用分块查找能够实现堆结构",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找作为堆的实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现采用分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "小根堆以单源最短路径为实现方式。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径被用作小根堆的实现手段。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆的实现基于单源最短路径。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "线性表以插值查找为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找实现查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找完成查找操作",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "选择排序是实现图的一种方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图的数据结构可通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "采用选择排序方法实现图的数据结构",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "迪杰斯特拉算法是实现LRU缓存的常用方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存的实现依赖于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存可通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "布隆过滤器采用分支限界作为实现方法",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器以分支限界为实现手段",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器通过分支限界实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "广度优先搜索可以通过链表来实现。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表是实现广度优先搜索的一种方式。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "用链表能够实现广度优先搜索。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "Dijkstra算法可用于实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "通过Dijkstra算法实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "借助Dijkstra算法实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "迪杰斯特拉算法的实现采用双向链表。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表是迪杰斯特拉算法的实现方式。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双向链表完成实现。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "单源最短路径是二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "Dijkstra算法是实现哈希表的方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表由Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法可实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "单链表使用弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表通过弗洛伊德算法来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表依靠弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "LRU缓存的实现采用了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "我们使用迪杰斯特拉算法来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "大根堆的实现方式采用了克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆借助克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法得以实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "线性查找是实现链表的一种方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表可通过线性查找来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找常用于链表的实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "红黑树的实现方式是分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树采用分块查找的方式实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树以分块查找作为其实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "生成森林的实现采用外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "迪杰斯特拉算法的实现采用双向链表。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表是迪杰斯特拉算法的实现方式。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双向链表完成实现。",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "生成森林以插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林使用插入排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "并查集的一种实现方式是穷举法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集可采用穷举法进行实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "实现并查集时，穷举法是一种可行的方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法作为实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "哈希查找是实现循环队列的常用方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列的实现方式之一是哈希查找",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列可通过哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "并查集的实现借助了Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法完成实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现基于Dijkstra算法方法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "可持久化数据结构的实现方式之一是记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常被用于实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "借助记忆化搜索能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "树状数组的实现可借助分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组通过分块查找的方式实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "选择排序是大根堆的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆可通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序实现了大根堆的构建",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "循环链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索常用于循环链表的实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "红黑树借助折半查找实现数据查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树查找的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树通过折半查找机制完成检索",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "二项堆的实现借助了弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "线段树通过桶排序进行实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树采用桶排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树以桶排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "字典树通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是字典树的实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序可实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "大根堆是选择排序的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序通过大根堆实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序的实现依赖大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "堆通过深度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的实现基于深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆的实现依赖于克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "拓扑排序是实现LFU缓存的有效方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序得以实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序为LFU缓存提供实现手段",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "数组通过基数排序实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组的实现方式为基数排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是数组的实现手段",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "栈采用分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "B树的实现运用了哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于B树的实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树借助哈希查找实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "归并排序是不相交集合的实现方式。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序实现不相交集合。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式为归并排序。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表的实现基于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "二叉堆的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆可借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "字典树的实现方式包含直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通常采用直接插入排序进行实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树借助直接插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "LRU缓存的实现采用了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "我们使用迪杰斯特拉算法来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "树通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是树的实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树可利用基数排序实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "克鲁斯卡尔算法实现了树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树的实现方式包括克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "通过克鲁斯卡尔算法可构建树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树借助克鲁斯卡尔算法完成实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "B树可通过哈希查找实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找是B树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树的实现方式包含哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "LRU缓存的实现方式是Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法被用来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "二叉堆的实现可借助动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是二叉堆的一种实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "我们用动态规划来实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "链表采用线性查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表以线性查找为实现手段",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表在查找时采用线性查找方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "生成森林在实现时采用插入排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林的数据结构实现借助插入排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "队列可通过折半查找算法实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找作为队列的实现方式之一",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "构建队列时常用折半查找方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "前缀树的一种实现方式是二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "通过二路归并能够实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并可作为前缀树的实现手段",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "循环队列采用哈希查找实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列利用哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列以哈希查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "二项堆可通过线性查找实现。",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方式之一。",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "借助线性查找可实现二项堆。",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "B树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "计数排序是实现二叉树的可行方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树可借助计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉树实现的有效途径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "斐波那契堆采用直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆以直接插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "选择排序被用于跳跃表的实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表的实现过程中采用了选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序是跳跃表底层实现的一种方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "冒泡排序是线性表的实现方法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是线性表的常用实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "优先队列采用分治方法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列借助分治策略实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树采用普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树以普里姆算法为实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "大根堆可通过选择排序实现。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序用于实现大根堆。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆的实现方式为选择排序。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "循环队列的实现方式之一是哈希查找",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "采用哈希查找来实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找可用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "双端队列借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "分块查找是实现堆的有效方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现方式包含分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "线性表的实现借助冒泡排序算法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法是斐波那契堆的实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "通过分块查找实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树借助折半查找实现数据查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树查找的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树通过折半查找机制完成检索",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "LRU缓存借助Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "通过Bellman-Ford算法可实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法是LRU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "斐波那契堆以直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序被用作斐波那契堆的实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆通过直接插入排序来实现数据结构",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "哈希表的实现方式之一是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表可通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "树状数组借助拓扑排序实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现方式之一",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组通过拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "双向链表是迪杰斯特拉算法的实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法以双向链表为实现结构",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双向链表实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "通过单源最短路径，我们可实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "借助单源最短路径方法，可构建二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径助力二叉树的实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉堆的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆可借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "LFU缓存通过二路归并实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是LFU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存可借助二路归并实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树可通过二路归并实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是实现前缀树的一种方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "借助二路归并算法实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "线性表以插值查找为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找实现查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找完成查找操作",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是双向链表的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "基数排序的实现方式是树结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树是基数排序的一种实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序通过树结构来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "分块查找是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列采用分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列以分块查找为实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "线性表可借助插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是线性表的实现手段",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "克鲁斯卡尔算法能够实现大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆的数据结构可借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "借助克鲁斯卡尔算法，大根堆得以实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "B+树的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树在实现过程中借助迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树通过迪杰斯特拉算法完成底层实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "字典树的实现依赖冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用作字典树的实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "字典树借助冒泡排序完成实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "后缀树依靠深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索用于实现后缀树。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树通过深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索构建循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆以计数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆使用计数排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "线段树可借助插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序是线段树的实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树采用插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "跳跃表以直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表依靠直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现方式为直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "可持久化数据结构以记忆化搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构借助记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构利用记忆化搜索作为实现途径",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存采用迪杰斯特拉算法来实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆借助克鲁斯卡尔算法完成实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法进行实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "通过Dijkstra算法实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表可借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法实现了循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "二叉堆通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "前缀树的底层实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树借助二路归并算法完成实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并被用于实现前缀树结构",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "堆采用分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "迪杰斯特拉算法可用于构建B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树的构建依赖迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "借助迪杰斯特拉算法实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "小根堆可以通过单源最短路径来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径的实现依赖小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆是单源最短路径的实现工具",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "LFU缓存采用二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存以二路归并为实现策略",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存通过二路归并来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现基于KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用于实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "堆排序的实现方式是数组结构",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组是堆排序的实现基础",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序借助数组结构实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "双端队列用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "二项堆借助线性查找实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找完成构建",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "插值查找是实现B+树的常用方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树的实现常采用插值查找",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树可通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法作为实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LFU缓存的实现方式之一是二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并常用于实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存可借助二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆的实现依赖于克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是双向链表的实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表以迪杰斯特拉算法为实现手段",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "树状数组通过拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序被用来实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "堆采用分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "线段树通过桶排序进行实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树采用桶排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树以桶排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "链表采用线性查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表以线性查找为实现手段",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表在查找时采用线性查找方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "二叉堆可通过计数排序来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序能够实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "生成森林以外部排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林以外部排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "双端队列使用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列基于迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "红黑树的底层实现采用分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树借助分块查找方法实现其功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找机制完成数据存储",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是二叉搜索树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索能够实现二叉搜索树",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是二叉搜索树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "哈希表的实现基于归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序作为哈希表的实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表借助归并排序完成实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现依赖动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "迪杰斯特拉算法可实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "借助迪杰斯特拉算法能够实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "AC自动机的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "通过单源最短路径实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径用于实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法用于平衡二叉树的实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法得以实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法可用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "图采用选择排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图以选择排序为实现手段",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图借助选择排序完成数据结构实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "B+树的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是B+树的实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "布隆过滤器采用广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于布隆过滤器的实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列可通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "借助迪杰斯特拉算法实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "生成森林以外部排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "B+树的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树在实现过程中借助迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树通过迪杰斯特拉算法完成底层实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现基于KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用于实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现其功能",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式包含广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "双向链表通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "小根堆可以通过单源最短路径来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径的实现依赖小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆是单源最短路径的实现工具",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "桶排序可用于实现线段树",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树可通过桶排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是线段树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线性表的实现借助冒泡排序算法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二叉堆以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆借助动态规划作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "栈采用分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "字典树的实现依赖冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用作字典树的实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "字典树借助冒泡排序完成实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "堆可以通过深度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索可用于实现堆",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "借助深度优先搜索能够构建堆结构",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "B树可通过哈希查找实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找是B树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树的实现方式包含哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "跳跃表依靠直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "桶排序可用于实现线段树",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树可通过桶排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是线段树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "B树的实现采用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树通过广度优先搜索算法来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "字典树的实现方式为冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "通过冒泡排序实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二叉堆的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式为计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆通过计数排序来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "B树的实现运用了广度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树在实现过程中借助了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树通过广度优先搜索来实现数据结构",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "平衡二叉树的实现方式是分治",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治策略被用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "借助分治方法构建平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "LRU缓存的实现采用Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存以Bellman-Ford算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "二叉树以计数排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序被用来实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树通过计数排序完成实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "快速排序是实现可持久化数据结构的一种方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "借助快速排序能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "LRU缓存采用迪杰斯特拉算法来实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存的实现方式为迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "哈希表的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序用于哈希表的排序实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表通过归并排序完成数据排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "树状数组通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组以分块查找为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现基于分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现通过分块查找来完成",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组借助分块查找实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树的实现方式之一是克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树可借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "利用克鲁斯卡尔算法实现树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "红黑树通过折半查找实现数据查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找可用于实现红黑树结构",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现依赖折半查找方法",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "克鲁斯卡尔算法是实现斐波那契堆的核心方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆的实现方式包含克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法作为斐波那契堆的实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "迪杰斯特拉算法实现中使用双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列是迪杰斯特拉算法的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双端队列实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "并查集基于穷举法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集采用穷举法作为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集以穷举法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树的实现方式包含分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆通过深度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的实现基于深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "树状数组可由拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "借助拓扑排序能够实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "循环队列借助哈希查找实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列以哈希查找作为底层实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于循环队列的实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "树状数组的实现通过分块查找来完成",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组借助分块查找实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现依赖动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "冒泡排序是线性表的实现方法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是线性表的常用实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "前缀树基于KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "用线性查找构建链表。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是链表构建的实现方式。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表构建可通过线性查找完成。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "后缀树的实现采用了贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的有效方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "利用贪心策略能够构建后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "循环链表可被用于实现广度优先搜索",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索的一种实现方式是循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "为实现广度优先搜索，循环链表是有效结构",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "字典树的实现方式为冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "通过冒泡排序实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "跳跃表依靠直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列借助分块查找得以实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "跳跃表借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表利用直接插入排序进行实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "后缀树常通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用于实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "实现后缀树时采用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树的构建过程借助深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树实现时利用深度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索常用于后缀树的实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "并查集的实现方式之一是穷举法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法可用于实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集能够通过穷举法来实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "前缀树可由二路归并实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树的实现方式为二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并可用于实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法用于实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆的实现依赖于弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "桶排序是实现不相交集合的有效方式。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合可借助桶排序来实现。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序可用于构建不相交集合。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "二叉堆可通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序可用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式是计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "链表使用广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表通过广度优先搜索完成实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "队列可借助折半查找实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "通过折半查找可以实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是实现队列的方式之一",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "优先队列可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是优先队列的实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法为优先队列提供实现途径",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "前缀树的实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并用于前缀树的实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "树的数据结构实现使用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树借助克鲁斯卡尔算法实现数据结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树的实现过程采用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "循环队列的实现依赖于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "优先队列可借助弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是优先队列的实现方法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "生成森林的实现方式是外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林借助外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "后缀树的实现基于贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树实现时运用了贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "数组采用堆排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序被用来实现数组",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "图可以通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是图的实现方式之一",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现依赖外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法作为实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "跳跃表依靠直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "B树的实现运用了哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于B树的实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树借助哈希查找实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "前缀树的实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并用于前缀树的实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "广度优先搜索可用于实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索构建循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "插值查找被用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是B+树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "前缀树的一种实现方式是二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "通过二路归并能够实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并可作为前缀树的实现手段",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "数组采用堆排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序被用来实现数组",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "直接插入排序可用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树常通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "采用直接插入排序实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "LFU缓存采用二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存以二路归并为实现策略",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存通过二路归并来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "弗洛伊德算法可用于实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "借助弗洛伊德算法，我们能够实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "链表的实现可借助线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找常用于链表实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表通过线性查找方式实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "弗洛伊德算法是实现单链表的常用方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "借助弗洛伊德算法能实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "双向链表使用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "拓扑排序是实现LFU缓存的有效方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序得以实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序为LFU缓存提供实现手段",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "后缀树常通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用于实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "实现后缀树时采用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "并查集通过穷举法实现其数据结构",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法是并查集的一种实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集的数据结构实现依赖于穷举法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "生成森林的实现基于插入排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序被用于生成森林的实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "快速排序是可持久化数据结构的实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构可通过快速排序实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "通过快速排序能够构建可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "通过记忆化搜索实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构可由记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "通过记忆化搜索，我们可以实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的一种实现途径",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "栈的一种实现方式是分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于实现栈结构",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈可通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "LRU缓存的底层实现采用Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "二叉搜索树的构建可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索常用于二叉搜索树的遍历实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树的某些操作借助广度优先搜索完成",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是布隆过滤器的实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索算法实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "堆通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "跳跃表的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表可通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "选择排序是实现跳跃表的一种方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表可通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序被用于实现跳跃表结构",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "线段树可通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序是线段树的实现手段之一",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树的实现方式包含插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "动态规划是双向链表的实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于双向链表的实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "插入排序是线段树实现的有效途径。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树常通过插入排序来实现。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树的实现方式包含插入排序。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "二叉树可通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "利用计数排序能实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "后缀树的实现采用了贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的有效方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "利用贪心策略能够构建后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "大根堆是选择排序的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序通过大根堆实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序的实现依赖大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "借助拓扑排序可构建树状数组。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组的构建依赖拓扑排序。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的构建方式之一。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "广度优先搜索可用于实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆可借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "堆通过深度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的实现方式是深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆借助深度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "直接插入排序可用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆的实现依赖于直接插入排序",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现基于KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用于实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "双向链表通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "拓扑排序是实现LFU缓存的一种方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "借助拓扑排序可实现LFU缓存的数据结构",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "平衡二叉树通过分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依赖于分治方法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治算法完成构建",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "小根堆的实现方式采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆通过广度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "直接插入排序可用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树常通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "采用直接插入排序实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "并查集的实现借助了Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法完成实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现基于Dijkstra算法方法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "LFU缓存的实现方式之一是二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并常用于实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存可借助二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列借助分块查找得以实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "动态规划是双向链表的实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于双向链表的实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "B+树借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B树的节点遍历过程借助广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的层次遍历实现依赖广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "优先队列可通过分治实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "分治算法是优先队列的实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "分治常用于优先队列的实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "线性表通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表以插值查找为实现手段",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "普里姆算法可用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "借助普里姆算法能构造平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "通过普里姆算法可构建平衡二叉树结构",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "大根堆可借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "通过克鲁斯卡尔算法能够实现大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法是大根堆的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "外部排序是图数据结构的实现方式之一。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图数据结构的实现依赖外部排序。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序可用于实现图的数据结构。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "线性查找是实现二项堆的有效手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现方式包含线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用作二项堆的实现手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性表以插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "数组的实现方式采用基数排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组在实现时借助基数排序算法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序作为底层实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "双向链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式是动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "图通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图以外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图借助外部排序完成实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "栈的底层实现采用分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈的实现过程使用分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈借助分块查找完成实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "树以克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树的实现采用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "并查集采用Dijkstra算法进行实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表的实现方式之一是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表可通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "线性表以插值查找为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找实现查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找完成查找操作",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "队列可借助折半查找实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "通过折半查找可以实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是实现队列的方式之一",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序可用于生成森林的实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "B树的实现采用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树通过广度优先搜索算法来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "布隆过滤器采用分支限界作为实现方法",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器以分支限界为实现手段",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器通过分支限界实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "哈希查找是实现循环队列的常用方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列的实现方式之一是哈希查找",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列可通过哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "双向链表的实现采用了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用来实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "分块查找作为堆的实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现采用分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "前缀树的实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并用于前缀树的实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "链表的实现可借助线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找常用于链表实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表通过线性查找方式实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "平衡二叉树通过分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依赖于分治方法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治算法完成构建",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "双向链表是迪杰斯特拉算法的实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法以双向链表为实现结构",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双向链表实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "线性表的实现采用冒泡排序",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现线性表",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "后缀树可通过深度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "构建后缀树时，常采用深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索是后缀树的一种实现途径",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "生成森林采用外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "小根堆可以通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索，能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "动态规划是单链表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表可通过动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "以动态规划方式实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "布隆过滤器的实现采用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于布隆过滤器的构建",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器可通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "归并排序是实现哈希表的一种方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表可通过归并排序实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序常用于哈希表的实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "线段树的一种实现方式是插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序被用于实现线段树",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "我们能够借助插入排序来实现线段树",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树以普里姆算法为实现手段",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树的实现依赖普里姆算法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "单链表的数据结构实现方式是动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划可实现单链表的数据结构",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "利用动态规划能够构建单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "队列采用记忆化搜索作为实现策略",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列以记忆化搜索为实现手段",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列借助记忆化搜索完成实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的数据结构实现依赖KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "B树的实现借助哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于B树的实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "通过哈希查找实现B树结构",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "选择排序是实现图的一种方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图的数据结构可通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序实现图的数据结构",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "B树采用哈希查找实现数据存储",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树以哈希查找为实现手段",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树借助哈希查找完成检索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "AC自动机基于希尔排序实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "希尔排序被用来实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机以希尔排序为实现方式",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "队列借助折半查找实现功能",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找为队列提供实现方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列的实现采用折半查找方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "KMP算法实现了前缀树。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树由KMP算法实现。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "通过KMP算法构建前缀树。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现方式之一是二路归并。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并可用于实现前缀树。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树可通过二路归并来构建。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "堆排序是实现数组的重要方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的常用方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的高效途径",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "布隆过滤器采用分支限界作为实现方法",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器以分支限界为实现手段",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器通过分支限界实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "二叉树的经典实现基于单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的高效实现采用单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径算法实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "B+树通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树以插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树借助插值查找完成实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "LFU缓存的实现方式之一是二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存通过二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并算法被用于实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序可用于生成森林的实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "通过记忆化搜索，我们可以实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的一种实现途径",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "平衡二叉树采用分治的方式实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "红黑树借助折半查找实现数据查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树查找的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树通过折半查找机制完成检索",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "二叉堆通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "深度优先搜索是堆的实现方式之一",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的构建借助深度优先搜索完成",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "使用深度优先搜索实现堆的构建",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "图采用选择排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图以选择排序为实现手段",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图借助选择排序完成数据结构实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "二叉堆通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆以计数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆使用计数排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "堆排序是实现数组的重要方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的常用方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是实现数组的高效途径",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "插值查找常用于实现线性表",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表可通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是线性表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "冒泡排序可用于实现线性表",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表的一种实现方式是冒泡排序",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表可以以冒泡排序的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序可用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "字典树的实现方式之一是冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "我们利用冒泡排序来实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "双端队列的实现方式为分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "优先队列借助分治实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列采用分治方式实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "分治是优先队列的实现方式之一",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "字典树的构建可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是字典树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二项堆的实现方式之一是线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用于实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "我们可以通过线性查找实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "并查集可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法是并查集的实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现采用Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "双向链表基于动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表采用动态规划方式实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于双向链表的实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "数组是基数排序的实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序通过数组来实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "借助数组，基数排序得以实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序的实现方式是数组",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组可用于实现基数排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序通过数组来实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树以插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树依靠插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "折半查找是红黑树实现的有效途径",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现方式包含折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找算法是红黑树的实现手段",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "链表的核心实现采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表实现过程中常使用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的实现依赖于广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "哈希查找可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树借助哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找是B树的实现方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "堆能够通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是堆的一种实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "字典树的实现方式采用冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "字典树实现借助冒泡排序完成",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "循环链表以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表采用广度优先搜索作为实现途径",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表借助广度优先搜索完成实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆借助动态规划作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "折半查找是红黑树实现的有效途径",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现方式包含折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找算法是红黑树的实现手段",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "堆通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "LRU缓存的实现方式是Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法被用来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "基数排序的实现方式是树结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树是基数排序的一种实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序通过树结构来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组的实现方式采用基数排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组在实现时借助基数排序算法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序作为底层实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法可用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "快速排序是可持久化数据结构的实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构可通过快速排序实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "通过快速排序能够构建可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "通过分块查找实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "折半查找的实现方式是红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树实现了折半查找功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "通过红黑树可实现折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "字典树的实现方式包含直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通常采用直接插入排序进行实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树借助直接插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "选择排序是大根堆的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆可通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序实现了大根堆的构建",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序被用于跳跃表的实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表的实现过程中采用了选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序是跳跃表底层实现的一种方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "并查集采用Dijkstra算法进行实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "后缀树的实现采用了贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的有效方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "利用贪心策略能够构建后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "通过分块查找实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "二叉树可通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径是二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的实现依赖于单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单链表的实现方式为动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用于单链表的实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "树的数据结构实现采用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用于实现树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树的实现方式之一是克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "双端队列通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于双端队列的实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "栈可通过冒泡排序来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是实现栈的一种方式",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "利用冒泡排序能够实现栈结构",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二项堆借助线性查找来实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现依赖于线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线段树通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树采用插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树的实现方式为插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "树状数组可借助分块查找实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "大根堆的实现采用了克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "二叉搜索树借助贪心策略得以实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用来实现二叉搜索树",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "实现二叉搜索树可利用贪心策略",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "计数排序被用于实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "树状数组可借助分块查找实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组以分块查找为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树采用分块查找实现数据管理",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找作为红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找来实现功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "直接插入排序是斐波那契堆的实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "循环队列可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法常用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "借助Dijkstra算法能够构建循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "单源最短路径通过小根堆实现。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆是实现单源最短路径的有效数据结构。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径算法常借助小根堆完成。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "分块查找是实现树状数组的常用方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组可通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的重要实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "广度优先搜索常用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式之一是广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索可实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树采用普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树以普里姆算法为实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法可用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "小根堆可以通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索，能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "字典树的构建可通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树可借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "冒泡排序是线性表的实现方法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是线性表的常用实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "队列借助折半查找实现功能",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找为队列提供实现方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列的实现采用折半查找方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "采用贪心策略实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树的实现常借助贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的一种方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "插入排序是线段树实现的有效途径。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树常通过插入排序来实现。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树的实现方式包含插入排序。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线性表以插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表采用插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "平衡二叉树采用分治的方式实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树采用分治的方式实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "线段树通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树采用插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树的实现方式为插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "树通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是树的实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树可利用基数排序实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "线段树的实现借助了插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序被用于线段树的实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "跳跃表可通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是跳跃表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现采用了直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "优先队列的实现依靠分治策略",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治方法来实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列的实现基于分治算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "循环链表通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是循环链表的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表的实现采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树采用贪心策略实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树借助贪心策略来实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树以贪心策略作为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树利用深度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树采用深度优先搜索作为实现方式",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树借助深度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "并查集可通过穷举法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法常用于实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法是并查集的一种实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "循环链表使用Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "队列使用折半查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列在实现时借助折半查找",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列的实现方式为折半查找",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "前缀树是KMP算法的实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法通过前缀树实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树用于实现KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "线段树使用桶排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树通过桶排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树以桶排序为实现手段",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "二项堆的实现采用线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "单链表的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用作单链表的实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "归并排序是实现不相交集合的一种方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合可借助归并排序来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序能够实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "冒泡排序是实现栈的一种方式",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈的实现方式之一为冒泡排序",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "借助冒泡排序能够实现栈",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "希尔排序是AC自动机的实现方式",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机通过希尔排序实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "希尔排序是实现AC自动机的有效途径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "Dijkstra算法是并查集的一种实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "用Dijkstra算法实现并查集是可行的",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列基于Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列采用Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "小根堆借助单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆通过单源最短路径来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆利用单源最短路径得以实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "LFU缓存采用二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存以二路归并为实现策略",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存通过二路归并来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "平衡二叉树通过分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依赖于分治方法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治算法完成构建",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "单链表的实现方式为动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用于单链表的实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "树状数组通过拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序被用来实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "单链表通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于单链表的实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表的实现依赖于弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "分块查找是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列采用分块查找来实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列以分块查找为实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "用线性查找构建链表。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是链表构建的实现方式。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表构建可通过线性查找完成。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "二叉树以单源最短路径为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树借助单源最短路径实现功能",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树利用单源最短路径作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "链表采用线性查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表以线性查找为实现手段",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表在查找时采用线性查找方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "跳跃表以直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表依靠直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现方式为直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "堆的实现过程借助深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的构建",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆通过深度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "归并排序是不相交集合的实现方式。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序实现不相交集合。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式为归并排序。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "栈的一种实现方式是分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于实现栈结构",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈可通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "线性表的实现采用冒泡排序",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现线性表",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "图可以通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是图的实现方式之一",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现依赖外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "线段树通过桶排序进行实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树采用桶排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树以桶排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "二项堆的实现采用线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表的实现方式之一是线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找可用于实现链表",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表可通过线性查找来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "哈希表的实现借助Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "利用Dijkstra算法实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "快速排序是实现可持久化数据结构的一种方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "借助快速排序能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "LRU缓存的实现方式是Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法被用来实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树以插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树依靠插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "快速排序是可持久化数据结构的一种实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构常采用快速排序来实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构借助快速排序得以实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "二项堆的核心实现采用弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "AC自动机的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径可用于实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机借助单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "栈的底层实现使用冒泡排序",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈的实现采用冒泡排序算法",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈通过冒泡排序算法来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表的实现采用插值查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找被用来实现线性表",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表借助插值查找实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "链表的实现采用线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表借助线性查找实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表依靠线性查找完成",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "数组的实现借助堆排序方法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序作为数组的实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组实现依赖堆排序方法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "B+树用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "使用冒泡排序构建栈。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是实现栈的方式。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈可通过冒泡排序实现。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的实现方式为广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是链表的实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "LFU缓存基于二路归并进行实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "采用二路归并实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "循环队列基于Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列采用Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法可用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "小根堆通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆可以通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索，能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环队列可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法常用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "借助Dijkstra算法能够构建循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集可通过穷举法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法常用于实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "穷举法是并查集的一种实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "跳跃表借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表利用直接插入排序进行实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "图通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图以外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图借助外部排序完成实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "二叉堆可通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序可用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式是计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "弗洛伊德算法通过单链表实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表是弗洛伊德算法的实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "用单链表实现弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "后缀树依靠深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索用于实现后缀树。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树通过深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "平衡二叉树通过分治方法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依靠分治策略",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "普里姆算法被用来实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "桶排序是实现不相交集合的有效方式。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合可借助桶排序来实现。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序可用于构建不相交集合。",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "B+树的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树在实现过程中借助迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树通过迪杰斯特拉算法完成底层实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "线性表的实现借助冒泡排序算法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是二叉搜索树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "生成森林的实现方式是外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林借助外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "二叉堆的实现可借助动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是二叉堆的一种实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "我们用动态规划来实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "链表的实现使用了线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是链表的实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表借助线性查找来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "树状数组借助拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组利用拓扑排序完成实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "堆排序的实现方式之一是数组。",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组常被用于实现堆排序算法。",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序算法借助数组来完成数据的排序操作。",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "不相交集合通过归并排序实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合使用归并排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合以归并排序为实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "优先队列可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法实现了优先队列",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列的实现方式为弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "跳跃表可以通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表的实现可借助选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序可用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "线段树的实现过程中运用了桶排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序被用于线段树的实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树实现时借助了桶排序技术",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "大根堆使用选择排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆借助选择排序来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆以选择排序为实现手段",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "AC自动机采用希尔排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现依赖希尔排序算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现以希尔排序为基础",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "生成森林可通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "借助外部排序能够实现生成森林",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "冒泡排序是实现字典树的一种方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "字典树可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "二叉堆的实现使用动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆借助动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆的实现依赖动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "利用分块查找实现红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "单链表的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用作单链表的实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "堆能够通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是堆的一种实现方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过折半查找实现数据查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找可用于实现红黑树结构",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现依赖折半查找方法",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "插值查找被用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树通过插值查找算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "采用插值查找可实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "单源最短路径是二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "循环队列借助哈希查找实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列以哈希查找作为底层实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于循环队列的实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "单源最短路径是二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二叉堆可由动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是二叉堆的实现方式之一",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "借助动态规划能够实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "广度优先搜索可用于实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆可借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "分块查找是实现树状数组的常用方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组可通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的重要实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "广度优先搜索可用于实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆可借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "用线性查找构建链表。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是链表构建的实现方式。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表构建可通过线性查找完成。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "归并排序是实现哈希表的一种方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表可通过归并排序实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序常用于哈希表的实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "布隆过滤器以分支限界作为其实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器采用分支限界算法进行实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "后缀树的构建过程借助深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树实现时利用深度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索常用于后缀树的实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "队列可通过折半查找算法实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找作为队列的实现方式之一",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "构建队列时常用折半查找方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "广度优先搜索可以通过链表来实现。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表是实现广度优先搜索的一种方式。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "用链表能够实现广度优先搜索。",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆的实现使用动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆借助动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆的实现依赖动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "平衡二叉树借助普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法用于平衡二叉树的实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法得以实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "红黑树通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "二项堆的实现借助了弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于实现优先队列",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列的实现基于弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "跳跃表的实现采用选择排序方法",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序被用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表以选择排序为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "红黑树以折半查找为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树的实现基础",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现借助折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "并查集通过穷举法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集以穷举法作为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集借助穷举法来实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "双向链表的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表借助动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "树状数组通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组以分块查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖于分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "队列采用记忆化搜索作为其实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列的实现方式为记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索被用作队列的实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列的底层实现借助折半查找",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找被用作队列的实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列以折半查找为实现手段",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "循环队列使用Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "数组的排序实现采用堆排序方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序是数组进行排序的实现手段",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组借助堆排序完成排序功能的实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "哈希表的实现借助归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序用于哈希表的实现过程",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表以归并排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "字典树的构建可通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树可借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "二叉堆通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆以计数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆使用计数排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "循环队列使用Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "树通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是树的实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树可利用基数排序实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "拓扑排序是实现LFU缓存的有效方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序得以实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序为LFU缓存提供实现手段",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "双向链表使用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "跳跃表可以通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表的实现可借助选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序可用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是双向链表的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "队列的底层实现借助折半查找",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找被用作队列的实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列以折半查找为实现手段",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "二叉堆的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划常用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆可借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "B+树通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树以插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树借助插值查找完成实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "折半查找是红黑树实现的有效途径",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现方式包含折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找算法是红黑树的实现手段",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "哈希表的实现基于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "可持久化数据结构可通过记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是实现可持久化数据结构的方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "借助记忆化搜索能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "链表的实现使用了线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是链表的实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表借助线性查找来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "跳跃表可以通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表的实现可借助选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序可用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "堆通过深度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆的实现基于深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "线段树可借助插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序是线段树的实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树采用插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "树的数据结构实现采用克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用于实现树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树的实现方式之一是克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "不相交集合可借助归并排序实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式为归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序可用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "后缀树通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树借助贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树利用贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树以贪心策略为实现方式",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树借助贪心策略来实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "分支限界是布隆过滤器的实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器可借助分支限界来实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "采用分支限界方法能够实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "哈希查找是循环队列的一种实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列的实现方式包含哈希查找",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "通过哈希查找能够实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "弗洛伊德算法是二项堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法为二项堆提供实现方法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "拓扑排序被用于实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存通过拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存的实现方式为拓扑排序",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "归并排序可用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表借助归并排序得以实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "B树的实现常采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树通常借助广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "堆排序是数组的实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组借助堆排序得以实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "栈通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈的实现方式为分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈以分块查找作为实现手段",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "线段树可通过桶排序实现。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是线段树的实现方式。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "利用桶排序实现线段树。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆由计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "基数排序是数组的一种实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组可通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "基数排序是实现数组的有效途径",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "二叉树的实现借助了单源最短路径方法",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径方法被用来实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径的方式实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "弗洛伊德算法是二项堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法为二项堆提供实现方法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表可借助弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "借助弗洛伊德算法实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是单链表的实现方法",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "KMP算法实现了前缀树。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树由KMP算法实现。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "通过KMP算法构建前缀树。",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "布隆过滤器的实现采用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于布隆过滤器的构建",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器可通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是双向链表的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "B+树借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "二项堆的实现借助了弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "动态规划是单链表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表可通过动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "以动态规划方式实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "归并排序是实现不相交集合的一种方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合可借助归并排序来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序能够实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "双向链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划用于实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式是动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉搜索树采用贪心策略实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树借助贪心策略来实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树以贪心策略作为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "平衡二叉树通过分治方法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依靠分治策略",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "双端队列通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于双端队列的实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "优先队列借助分治实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列采用分治方式实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "分治是优先队列的实现方式之一",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "双端队列用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "生成森林以外部排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "计数排序被用于实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表可通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是双向链表的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表的实现方式包含动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "B树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过Dijkstra算法实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表可借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法实现了循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "广度优先搜索可用于实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆可借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "队列采用记忆化搜索作为其实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列的实现方式为记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索被用作队列的实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "通过单源最短路径，我们可实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "借助单源最短路径方法，可构建二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径助力二叉树的实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "哈希表的实现借助归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序用于哈希表的实现过程",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表以归并排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "单链表通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表的实现借助弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于单链表的实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "不相交集合通过桶排序算法实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是不相交集合的实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合的实现依赖于桶排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "循环链表采用广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "Bellman-Ford算法被用于实现LRU缓存的数据结构",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存的数据结构可通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法是LRU缓存数据结构的实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "B+树的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "利用迪杰斯特拉算法能够实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "优先队列采用弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是优先队列的实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列基于弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是跳跃表的实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现采用直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "链表实现时采用广度优先搜索方法",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现链表",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的构建过程运用了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "冒泡排序是线性表的实现方法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是线性表的常用实现方式",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "图的实现方式包括外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是实现图的有效手段",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图常通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "队列借助折半查找实现功能",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找为队列提供实现方法",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列的实现采用折半查找方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "LFU缓存通过二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存的实现依赖于二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存采用二路归并技术实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "B树的节点遍历过程借助广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的层次遍历实现依赖广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "LRU缓存采用迪杰斯特拉算法来实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存借助迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存的实现方式为迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "生成森林以外部排序为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "栈的底层实现采用分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈的实现过程使用分块查找",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈借助分块查找完成实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "二叉树以单源最短路径为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树借助单源最短路径实现功能",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树利用单源最短路径作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树的实现借助了单源最短路径方法",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径方法被用来实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径的方式实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "优先队列采用分治方法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列借助分治策略实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "红黑树采用分块查找实现数据管理",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找作为红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找来实现功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现通过分块查找来完成",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组借助分块查找实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "借助拓扑排序可构建树状数组。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组的构建依赖拓扑排序。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的构建方式之一。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "不相交集合通过归并排序实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合使用归并排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合以归并排序为实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "B+树的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是B+树的实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "AC自动机的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径可用于实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机借助单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "哈希查找可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树借助哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找是B树的实现方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "大根堆的实现采用了克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "队列采用记忆化搜索作为其实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列的实现方式为记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索被用作队列的实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "通过Dijkstra算法实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表可借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法实现了循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现方式采用Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法是并查集的实现手段",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "记忆化搜索是队列的一种实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列可通过记忆化搜索来实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常用于实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "链表通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索被用于实现链表",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "AC自动机的实现方式为单源最短路径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "借助单源最短路径可实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径可用于构建AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉搜索树通过广度优先搜索实现层序遍历",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树实现层序遍历常使用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树的层序遍历实现基于广度优先搜索",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "跳跃表通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表以选择排序为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表利用选择排序作为实现方法",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "循环链表用于实现Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法通过循环链表实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表是Dijkstra算法的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "插入排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "生成森林可通过插入排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "利用插入排序实现生成森林",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "插入排序"
    },
    {
      "sentence": "并查集以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于并查集的实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "红黑树以折半查找为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树借助折半查找完成操作",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树的实现手段",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "后缀树的实现常采用深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "通过深度优先搜索可实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索常用于实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "分块查找是实现堆的有效方式",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现方式包含分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找常用于堆的实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "并查集采用Dijkstra算法进行实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "小根堆可以通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索，能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "线段树使用桶排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树通过桶排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "线段树以桶排序为实现手段",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "B+树采用插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树以插值查找为实现手段",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是B+树的实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "优先队列采用弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法是优先队列的实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列基于弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表的实现方式为动态规划",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "单链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用于单链表的实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "并查集可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法是并查集的实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现采用Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "希尔排序是AC自动机的实现方式",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机通过希尔排序实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "希尔排序是实现AC自动机的有效途径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "线性表的实现借助冒泡排序算法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序的方式实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "后缀树的实现采用了贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的有效方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "利用贪心策略能够构建后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的数据结构实现依赖KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "红黑树采用分块查找实现数据管理",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找作为红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找来实现功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组可由拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "借助拓扑排序能够实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "迪杰斯特拉算法实现中使用双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列是迪杰斯特拉算法的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双端队列实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式之一",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树的实现方式包含分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "字典树的实现采用直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是字典树的实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树可借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树采用直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序被用来实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "大根堆以克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "平衡二叉树可通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "利用普里姆算法能够实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "队列的实现方式之一是借助记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "利用记忆化搜索能够实现队列结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常被用来实现队列数据结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "不相交集合的实现采用归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合通过归并排序来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "使用Bellman-Ford算法实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存的数据结构可通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LFU缓存以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存借助拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存将拓扑排序作为实现途径",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "堆的实现方式为分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆在实现时采用分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "堆的实现借助分块查找",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "分块查找"
    },
    {
      "sentence": "选择排序是实现跳跃表的一种方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表可通过选择排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "利用选择排序能够实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "小根堆可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于小根堆的构建",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "弗洛伊德算法被用来实现优先队列",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列通过弗洛伊德算法完成实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列的实现基于弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "数组采用基数排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序实现数据排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组借助基数排序完成排序操作",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "Dijkstra算法用循环链表实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表是Dijkstra算法的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法以循环链表为实现结构",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "分块查找通过红黑树实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树用于实现分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找以红黑树为实现结构",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "迪杰斯特拉算法是实现B+树的有效方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是实现B+树的重要途径",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法常作为实现B+树的手段",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "二叉搜索树借助贪心策略得以实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用来实现二叉搜索树",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "实现二叉搜索树可利用贪心策略",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "B树的实现运用了广度优先搜索算法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树在实现过程中借助了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树通过广度优先搜索来实现数据结构",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "平衡二叉树采用分治的方式实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治是平衡二叉树的实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "树状数组的实现通过分块查找来完成",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组借助分块查找实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组借助拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组利用拓扑排序完成实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "优先队列采用分治方法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列借助分治策略实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治算法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "二叉堆的实现使用动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆借助动态规划实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆的实现依赖动态规划方法",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "插值查找被用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树通过插值查找算法实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "采用插值查找可实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "单源最短路径通过小根堆实现。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆是实现单源最短路径的有效数据结构。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径算法常借助小根堆完成。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆的实现借助了广度优先搜索",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆的实现方式为广度优先搜索",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆以计数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆使用计数排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "Dijkstra算法可用于实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "通过Dijkstra算法实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "借助Dijkstra算法实现并查集",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "二项堆借助线性查找来实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现依赖于线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "布隆过滤器采用广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于布隆过滤器的实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "LFU缓存通过二路归并实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是LFU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存可借助二路归并实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "插值查找可作为B+树的实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "利用插值查找实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树的实现方式之一是插值查找",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "字典树的实现采用直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是字典树的实现方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树可借助直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "Dijkstra算法用循环链表实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表是Dijkstra算法的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法以循环链表为实现结构",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "跳跃表的实现方式包含直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序是跳跃表的一种实现手段",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表可通过直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "二叉搜索树的实现借助了贪心策略",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用于二叉搜索树的实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树实现时运用了贪心策略",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "可持久化数据结构常通过记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的实现方式之一",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构的实现依赖于记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "广度优先搜索是B树的实现方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的实现采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "线性表的实现过程中采用插值查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找被用于线性表的实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表常通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "不相交集合通过归并排序实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用作不相交集合的实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合以归并排序为实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "可持久化数据结构的实现方式采用记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构通过记忆化搜索完成实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的实现手段",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "AC自动机的实现借助了希尔排序算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机运用希尔排序方法来实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机以希尔排序为实现手段",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现使用了希尔排序算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机通过希尔排序算法实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现基于希尔排序方法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现二叉搜索树。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "实现二叉搜索树可采用广度优先搜索方法。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "前缀树以KMP算法为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用作前缀树的实现手段",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树借助KMP算法完成实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "图的实现方式之一是选择排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "图可通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "选择排序"
    },
    {
      "sentence": "哈希表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于哈希表的实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表以Dijkstra算法作为实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "使用计数排序实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序构建二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "LRU缓存的底层实现采用Bellman-Ford算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "大根堆是选择排序的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序通过大根堆实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序的实现依赖大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "广度优先搜索可用于实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索构建循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "栈的数据结构实现方式为分块查找。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现栈的数据结构。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈借助分块查找来构建其数据结构。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "字典树的构建可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是字典树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树以插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树依靠插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "大根堆以克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "堆排序是数组的实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组借助堆排序得以实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "哈希表的实现借助归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序用于哈希表的实现过程",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表以归并排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "B树的实现借助哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找被用于B树的实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "通过哈希查找实现B树结构",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "可持久化数据结构的实现方式采用记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构通过记忆化搜索完成实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的实现手段",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "LRU缓存的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "分块查找通过红黑树实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树用于实现分块查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找以红黑树为实现结构",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "快速排序是实现可持久化数据结构的一种方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "借助快速排序能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "单链表使用弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表通过弗洛伊德算法来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表依靠弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "链表的实现可借助线性查找",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找常用于链表实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "链表通过线性查找方式实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "线性查找"
    },
    {
      "sentence": "并查集的一种实现方式是穷举法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "并查集可采用穷举法进行实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "实现并查集时，穷举法是一种可行的方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "穷举法"
    },
    {
      "sentence": "LRU缓存借助Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "通过Bellman-Ford算法可实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法是LRU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "哈希表的实现方式之一是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表可通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "双端队列的实现方式之一是分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找可用于实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列借助分块查找得以实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "生成森林采用外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "线性表可通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是线性表的实现方式之一",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表的实现可借助插值查找算法",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "双端队列的实现方式采用分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列的实现借助分块查找方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "直接插入排序被用于实现斐波那契堆",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆通过直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "斐波那契堆的实现采用直接插入排序",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "大根堆通过选择排序实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "大根堆借助选择排序实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树采用KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树借助KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "双端队列通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列借助分块查找实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "图的数据结构实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是实现图的一种方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图通过外部排序实现数据结构",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "广度优先搜索通过链表实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表用于实现广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表是广度优先搜索的实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "记忆化搜索是实现队列的一种方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列可通过记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索用于构建队列结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "克鲁斯卡尔算法实现了斐波那契堆的数据结构。",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆可通过克鲁斯卡尔算法实现。",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法被用来实现斐波那契堆。",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "记忆化搜索是实现队列的一种方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列可通过记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索用于构建队列结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "双端队列的实现方式采用分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列的实现借助分块查找方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "队列的实现方式之一是借助记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "利用记忆化搜索能够实现队列结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常被用来实现队列数据结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以线性查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆通过线性查找来实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树以插入排序为实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树依靠插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "循环队列的实现依赖于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "跳跃表以直接插入排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表依靠直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表的实现方式为直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "数组采用基数排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序实现数据排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组借助基数排序完成排序操作",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组的实现借助堆排序方法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "堆排序作为数组的实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "数组实现依赖堆排序方法",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "堆排序"
    },
    {
      "sentence": "归并排序可用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "借助归并排序能够实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "小根堆以单源最短路径为实现方式。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径被用作小根堆的实现手段。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆的实现基于单源最短路径。",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "外部排序是图数据结构的实现方式之一。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图数据结构的实现依赖外部排序。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序可用于实现图的数据结构。",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "哈希表借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表的实现方式是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "二项堆的实现方式之一是线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用于实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "我们可以通过线性查找实现二项堆",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二叉堆通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆以计数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆使用计数排序作为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "红黑树以折半查找为实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找是红黑树的实现基础",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树的实现借助折半查找",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "可持久化数据结构的实现方式之一是记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常被用于实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "借助记忆化搜索能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "红黑树采用分块查找实现数据管理",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找作为红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找来实现功能",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "迪杰斯特拉算法实现中使用双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列是迪杰斯特拉算法的实现方式之一",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法通过双端队列实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "利用迪杰斯特拉算法能够实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "弗洛伊德算法被用来实现优先队列",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列通过弗洛伊德算法完成实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "优先队列的实现基于弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "图通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图以外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图借助外部排序完成实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "队列采用折半查找实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列通过折半查找来实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "队列以折半查找为实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "折半查找"
    },
    {
      "sentence": "循环链表借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索能够实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "快速排序可作为可持久化数据结构的实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构通过快速排序实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "快速排序是可持久化数据结构的实现手段",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索常用于二叉搜索树的实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树的实现方式之一是广度优先搜索",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "计数排序是二叉树的一种实现方式。",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树可通过计数排序来实现。",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序能够实现二叉树。",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "克鲁斯卡尔算法可用于实现树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树可以借助克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法是实现树的一种方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "不相交集合的实现方式为归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序是不相交集合的实现方法",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "双向链表的实现方式之一是动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划可用于实现双向链表",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是双向链表的一种实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉搜索树采用贪心策略作为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树借助贪心策略实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树以贪心策略为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "红黑树以分块查找为实现方式。",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找被用于红黑树的实现。",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "红黑树通过分块查找实现。",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列可通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "借助迪杰斯特拉算法实现双端队列",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "线段树的实现方式采用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树实现时借助插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树在实现中使用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线性表的实现过程中采用插值查找",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找被用于线性表的实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性表常通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "插值查找"
    },
    {
      "sentence": "前缀树通过KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的数据结构实现依赖KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "双端队列用迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法是双端队列的实现方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双端队列的实现基于迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "二叉堆可通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序可用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式是计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "栈采用分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "栈可借助分块查找来实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "分块查找"
    },
    {
      "sentence": "使用计数排序实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序构建二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "生成森林可通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "构建生成森林需借助外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "堆的实现过程借助深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的构建",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆通过深度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "二叉搜索树采用贪心策略作为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树借助贪心策略实现",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉搜索树以贪心策略为实现手段",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉树以单源最短路径为实现方式",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树借助单源最短路径完成实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "希尔排序是AC自动机的实现方式",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机通过希尔排序实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "希尔排序是实现AC自动机的有效途径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现使用了希尔排序算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机通过希尔排序算法实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "AC自动机的实现基于希尔排序方法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "希尔排序"
    },
    {
      "sentence": "二叉堆可通过计数排序来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "借助计数排序能够实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "弗洛伊德算法可用于实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "借助弗洛伊德算法，我们能够实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "不相交集合通过归并排序算法来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "字典树的构建可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是字典树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "前缀树以KMP算法为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用作前缀树的实现手段",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树借助KMP算法完成实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "堆的实现过程借助深度优先搜索",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索被用于堆的构建",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "堆通过深度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "堆",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "线段树的实现借助了插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树通过插入排序来实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序被用于线段树的实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "Dijkstra算法是并查集的一种实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集可通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "用Dijkstra算法实现并查集是可行的",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法是实现哈希表的方式",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表由Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法可实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "可持久化数据结构通过快速排序实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构的实现借助快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "快速排序被用于实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "AC自动机通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径被用于实现AC自动机",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机的实现方式是单源最短路径",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "双向链表通过动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表借助动态规划来实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "优先队列以分治为实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列的实现方式是分治",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现方式采用了普里姆算法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "普里姆算法被用于平衡二叉树的实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "循环链表通过广度优先搜索算法实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是循环链表的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "循环链表的实现采用广度优先搜索方法",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "优先队列的实现方式基于分治算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治方法实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列以分治为实现方式",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "树通过基数排序来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树以基数排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "跳跃表的实现方式包含选择排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "借助选择排序可构建跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "可持久化数据结构以记忆化搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构借助记忆化搜索实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构的实现依赖记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "前缀树的实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并用于前缀树的实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "循环链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索常用于循环链表的实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现循环链表",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二项堆借助线性查找来实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找是二项堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现依赖于线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "生成森林的实现采用外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "克鲁斯卡尔算法是实现树的一种方式",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "树可通过克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法常用于实现树结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "不相交集合通过归并排序算法来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合的实现方式包含归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "双向链表通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表的实现方式采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "双向链表借助迪杰斯特拉算法完成实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "B+树采用插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树以插值查找为实现手段",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "插值查找是B+树的实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "线性查找是实现二项堆的有效手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现方式包含线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用作二项堆的实现手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "使用冒泡排序构建栈。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是实现栈的方式。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈可通过冒泡排序实现。",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "哈希表的实现基于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法被用于实现哈希表",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "哈希表通过Dijkstra算法来实现",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "通过记忆化搜索，我们可以实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含记忆化搜索",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索是可持久化数据结构的一种实现途径",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "布隆过滤器通过分支限界方法实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器的实现借助了分支限界",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界被用于实现布隆过滤器",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "跳跃表依靠直接插入排序来实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表借助直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "二项堆的实现借助了弗洛伊德算法",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "弗洛伊德算法被用于二项堆的实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "小根堆可以通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索，能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "利用广度优先搜索实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉堆的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划被用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "二叉堆通过动态规划来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "生成森林采用外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是生成森林的实现手段",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "生成森林的实现方式为外部排序",
      "relation": "implementedAs",
      "entity1": "生成森林",
      "entity2": "外部排序"
    },
    {
      "sentence": "使用Bellman-Ford算法实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存的数据结构可通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "Bellman-Ford算法被用于实现LRU缓存",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "大根堆是选择排序的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序通过大根堆实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序的实现依赖大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆通过克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法作为实现手段",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "利用分块查找实现红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "记忆化搜索是队列的一种实现方式",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列可通过记忆化搜索来实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常用于实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "计数排序被用于实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现其功能",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式包含广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "二叉搜索树可通过广度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索可用于实现二叉搜索树。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "实现二叉搜索树可采用广度优先搜索方法。",
      "relation": "implementedAs",
      "entity1": "二叉搜索树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "并查集以Dijkstra算法为实现方式",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集借助Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于并查集的实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "广度优先搜索可用于实现链表",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的一种实现方式是广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过广度优先搜索算法能够实现链表结构",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "可持久化数据结构的实现采用快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构通过快速排序实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "快速排序被用于实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "红黑树的实现运用了折半查找机制",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "折半查找被用于红黑树的实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "红黑树实现时借助了折半查找方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "折半查找"
    },
    {
      "sentence": "图的实现借助外部排序方法",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的构建采用外部排序方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现基于外部排序技术",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "栈的实现采用冒泡排序方法",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现栈",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "栈通过冒泡排序完成实现",
      "relation": "implementedAs",
      "entity1": "栈",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "循环队列的实现方式是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "线性查找是实现二项堆的有效手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现方式包含线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用作二项堆的实现手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "优先队列的实现依靠分治策略",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列通过分治方法来实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列的实现基于分治算法",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "树状数组可借助分块查找实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组以分块查找为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "大根堆的实现方式采用了克鲁斯卡尔算法",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆借助克鲁斯卡尔算法来实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "大根堆通过克鲁斯卡尔算法得以实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "线性查找是实现二项堆的有效手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二项堆的实现方式包含线性查找",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "线性查找被用作二项堆的实现手段",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "线性查找"
    },
    {
      "sentence": "二叉堆通过动态规划实现。",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是二叉堆的实现方式。",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "借助动态规划构建二叉堆。",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "前缀树可通过二路归并实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是实现前缀树的一种方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "借助二路归并算法实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "优先队列借助分治实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "优先队列采用分治方式实现",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "分治是优先队列的实现方式之一",
      "relation": "implementedAs",
      "entity1": "优先队列",
      "entity2": "分治"
    },
    {
      "sentence": "快速排序是实现可持久化数据结构的一种方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构的实现方式包含快速排序",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "借助快速排序能够实现可持久化数据结构",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "树状数组借助拓扑排序实现其功能",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的实现方式之一",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组通过拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "快速排序是可持久化数据结构的一种实现方式",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构常采用快速排序来实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "可持久化数据结构借助快速排序得以实现",
      "relation": "implementedAs",
      "entity1": "可持久化数据结构",
      "entity2": "快速排序"
    },
    {
      "sentence": "B+树通过插值查找实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树以插值查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树借助插值查找完成实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "采用贪心策略实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树的实现常借助贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略是实现后缀树的一种方法",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "插值查找是实现B+树的常用方式",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树的实现常采用插值查找",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "B+树可通过插值查找来实现",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "插值查找"
    },
    {
      "sentence": "计数排序被用于实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉树的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "计数排序"
    },
    {
      "sentence": "循环队列的实现方式是Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "平衡二叉树通过分治策略实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治思想来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树采用分治方法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "通过分块查找实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "二项堆通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆以弗洛伊德算法为实现方式",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "二项堆由弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "二项堆",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "广度优先搜索是B树的实现方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树的实现采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索实现B树",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "平衡二叉树通过分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依赖于分治方法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治算法完成构建",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "大根堆是选择排序的实现方式",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序通过大根堆实现",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序的实现依赖大根堆",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "选择排序"
    },
    {
      "sentence": "小根堆可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于小根堆的构建",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "借助广度优先搜索能够实现小根堆",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树采用KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树借助KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "分治是平衡二叉树的一种实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树可通过分治算法来实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "分治算法用于实现平衡二叉树",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "不相交集合的一种实现方式是桶排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序可用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合通过桶排序得以实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "后缀树的实现方式是深度优先搜索",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树通过深度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树以深度优先搜索为实现手段",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "实现图的数据结构常采用外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现依赖外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "大根堆可通过克鲁斯卡尔算法实现。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法用于实现大根堆。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "使用克鲁斯卡尔算法实现大根堆。",
      "relation": "implementedAs",
      "entity1": "大根堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "基数排序可用于实现树结构",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "树的实现方式之一是基数排序",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "借助基数排序能够实现树",
      "relation": "implementedAs",
      "entity1": "树",
      "entity2": "基数排序"
    },
    {
      "sentence": "线段树的实现方式包括桶排序。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序可用于实现线段树。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "利用桶排序能够实现线段树。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "数组基于基数排序来实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组通过基数排序实现",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表借助冒泡排序完成实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "斐波那契堆以克鲁斯卡尔算法为实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆借助克鲁斯卡尔算法完成实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法进行实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "数组采用基数排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组以基数排序实现数据排序",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "数组借助基数排序完成排序操作",
      "relation": "implementedAs",
      "entity1": "数组",
      "entity2": "基数排序"
    },
    {
      "sentence": "平衡二叉树通过分治思想实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树的实现依赖于分治方法",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "平衡二叉树借助分治算法完成构建",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "分治"
    },
    {
      "sentence": "链表可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "链表的实现方式为广度优先搜索",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是链表的实现方式",
      "relation": "implementedAs",
      "entity1": "链表",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "线段树可借助插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "插入排序是线段树的实现方式",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树采用插入排序实现",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "小根堆通过广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆借助广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "LFU缓存通过二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存的实现依赖于二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存采用二路归并技术实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器通过广度优先搜索实现其功能",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器的实现方式包含广度优先搜索",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "通过分块查找实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组的实现依赖分块查找",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找用于实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "字典树的实现方式为冒泡排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "通过冒泡排序实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序被用于实现字典树",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "循环队列采用哈希查找实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列利用哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "循环队列以哈希查找作为实现方式",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "双向链表的实现方式采用动态规划",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表借助动态规划实现",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "双向链表以动态规划为实现方式",
      "relation": "implementedAs",
      "entity1": "双向链表",
      "entity2": "动态规划"
    },
    {
      "sentence": "后缀树的实现常采用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "贪心策略被用来实现后缀树",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "构建后缀树时通常运用贪心策略",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "二叉堆的实现可借助动态规划",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "动态规划是二叉堆的一种实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "我们用动态规划来实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "动态规划"
    },
    {
      "sentence": "计数排序是二叉堆的实现方式",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆由计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "通过单源最短路径，我们可实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "借助单源最短路径方法，可构建二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径助力二叉树的实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "图通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图以外部排序作为实现方式",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图借助外部排序完成实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "队列的实现方式之一是借助记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "利用记忆化搜索能够实现队列结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索常被用来实现队列数据结构",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "后缀树依靠深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "深度优先搜索用于实现后缀树。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "后缀树通过深度优先搜索实现。",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "深度优先搜索"
    },
    {
      "sentence": "字典树的构建可通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序常用于字典树的实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "冒泡排序是字典树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线段树的实现方式采用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树实现时借助插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "线段树在实现中使用插入排序",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "插入排序"
    },
    {
      "sentence": "循环链表用于实现Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法通过循环链表实现",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环链表是Dijkstra算法的实现方式",
      "relation": "implementedAs",
      "entity1": "循环链表",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "双端队列的实现方式采用分块查找",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列的实现借助分块查找方式",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "双端队列通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "双端队列",
      "entity2": "分块查找"
    },
    {
      "sentence": "小根堆的实现方式采用单源最短路径",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆通过单源最短路径算法实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "小根堆的实现依赖于单源最短路径",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的有效方法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树可以借助广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "不相交集合的实现方式为归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序是不相交集合的实现方法",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "通过归并排序实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "AC自动机实现时借助单源最短路径算法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径是AC自动机的实现方式之一",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机在实现过程中采用单源最短路径方法",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "LFU缓存的实现方式采用二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存通过二路归并来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是LFU缓存的实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "图的实现方式包括外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "外部排序是实现图的有效手段",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图常通过外部排序来实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "前缀树的实现采用二路归并",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并用于前缀树的实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树通过二路归并实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并是前缀树的实现方式",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "前缀树以二路归并为实现手段",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "二路归并"
    },
    {
      "sentence": "LRU缓存通过Bellman-Ford算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存以Bellman-Ford算法为实现手段",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "LRU缓存借助Bellman-Ford算法完成实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "Bellman-Ford算法"
    },
    {
      "sentence": "B树的实现方式为哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树采用哈希查找来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树通过哈希查找实现数据结构",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "字典树的实现方式包含直接插入排序",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树通常采用直接插入排序进行实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "字典树借助直接插入排序完成实现",
      "relation": "implementedAs",
      "entity1": "字典树",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "并查集的实现借助了Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法完成实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现基于Dijkstra算法方法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "二叉堆可通过计数排序实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "计数排序可用于实现二叉堆",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式是计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "树状数组通过拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序被用来实现树状数组",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "线段树的实现方式包括桶排序。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序可用于实现线段树。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "利用桶排序能够实现线段树。",
      "relation": "implementedAs",
      "entity1": "线段树",
      "entity2": "桶排序"
    },
    {
      "sentence": "分块查找是实现树状数组的常用方式",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "树状数组可通过分块查找来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是树状数组的重要实现手段",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "分块查找"
    },
    {
      "sentence": "并查集的实现借助了Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集通过Dijkstra算法完成实现",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "并查集的实现基于Dijkstra算法方法",
      "relation": "implementedAs",
      "entity1": "并查集",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "LFU缓存以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存借助拓扑排序实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存将拓扑排序作为实现途径",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "二叉树的实现借助了单源最短路径方法",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径方法被用来实现二叉树",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "二叉树通过单源最短路径的方式实现",
      "relation": "implementedAs",
      "entity1": "二叉树",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "布隆过滤器采用广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "布隆过滤器以广度优先搜索为实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索用于布隆过滤器的实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "单链表使用弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表通过弗洛伊德算法来实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表依靠弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "B树的构建过程采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索是实现B树的有效方法",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "B树可以借助广度优先搜索来实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "后缀树通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树以贪心策略为实现方式",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树借助贪心策略来实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "斐波那契堆采用克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "克鲁斯卡尔算法是斐波那契堆的实现方式",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "斐波那契堆借助克鲁斯卡尔算法实现",
      "relation": "implementedAs",
      "entity1": "斐波那契堆",
      "entity2": "克鲁斯卡尔算法"
    },
    {
      "sentence": "实现图的数据结构常采用外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构实现依赖外部排序",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "图的数据结构通过外部排序实现",
      "relation": "implementedAs",
      "entity1": "图",
      "entity2": "外部排序"
    },
    {
      "sentence": "二叉堆的实现采用计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆的实现方式为计数排序",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "二叉堆通过计数排序来实现",
      "relation": "implementedAs",
      "entity1": "二叉堆",
      "entity2": "计数排序"
    },
    {
      "sentence": "线性表通过冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表以冒泡排序实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "线性表借助冒泡排序完成实现",
      "relation": "implementedAs",
      "entity1": "线性表",
      "entity2": "冒泡排序"
    },
    {
      "sentence": "后缀树通过贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树借助贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "后缀树利用贪心策略实现",
      "relation": "implementedAs",
      "entity1": "后缀树",
      "entity2": "贪心策略"
    },
    {
      "sentence": "循环队列的实现依赖于Dijkstra算法",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "循环队列通过Dijkstra算法实现",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "Dijkstra算法用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "Dijkstra算法"
    },
    {
      "sentence": "红黑树可通过分块查找实现",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "分块查找是红黑树的实现方式",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "利用分块查找实现红黑树",
      "relation": "implementedAs",
      "entity1": "红黑树",
      "entity2": "分块查找"
    },
    {
      "sentence": "B+树的实现借助了迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法可用于实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "利用迪杰斯特拉算法能够实现B+树",
      "relation": "implementedAs",
      "entity1": "B+树",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LFU缓存的实现方式之一是二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "二路归并常用于实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存可借助二路归并算法实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存的实现方式之一是二路归并",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "LFU缓存采用二路归并来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "借助二路归并算法可实现LFU缓存",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "二路归并"
    },
    {
      "sentence": "弗洛伊德算法是实现单链表的常用方式",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "单链表可通过弗洛伊德算法实现",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "借助弗洛伊德算法能实现单链表",
      "relation": "implementedAs",
      "entity1": "单链表",
      "entity2": "弗洛伊德算法"
    },
    {
      "sentence": "B树可通过哈希查找实现",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找是B树实现的一种方式",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "B树的实现方式包含哈希查找",
      "relation": "implementedAs",
      "entity1": "B树",
      "entity2": "哈希查找"
    },
    {
      "sentence": "不相交集合通过桶排序算法实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "桶排序是不相交集合的实现方式",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "不相交集合的实现依赖于桶排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "桶排序"
    },
    {
      "sentence": "循环队列的实现方式之一是哈希查找",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "采用哈希查找来实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "哈希查找可用于实现循环队列",
      "relation": "implementedAs",
      "entity1": "循环队列",
      "entity2": "哈希查找"
    },
    {
      "sentence": "前缀树基于KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "KMP算法被用来实现前缀树",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "队列的实现方式之一是记忆化搜索",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "采用记忆化搜索可实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "记忆化搜索能用于实现队列",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "小根堆可通过广度优先搜索实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "广度优先搜索常用于小根堆的实现",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "小根堆的实现常采用广度优先搜索",
      "relation": "implementedAs",
      "entity1": "小根堆",
      "entity2": "广度优先搜索"
    },
    {
      "sentence": "LFU缓存采用拓扑排序进行实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存借助拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "LFU缓存以拓扑排序为实现方式",
      "relation": "implementedAs",
      "entity1": "LFU缓存",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "跳跃表借助选择排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "选择排序用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "跳跃表以选择排序为实现方式",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "选择排序"
    },
    {
      "sentence": "单源最短路径是实现AC自动机的常用方式",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "AC自动机可通过单源最短路径实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "单源最短路径常用于AC自动机的实现",
      "relation": "implementedAs",
      "entity1": "AC自动机",
      "entity2": "单源最短路径"
    },
    {
      "sentence": "跳跃表的实现方式是直接插入排序",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "直接插入排序用于实现跳跃表",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "跳跃表可通过直接插入排序实现",
      "relation": "implementedAs",
      "entity1": "跳跃表",
      "entity2": "直接插入排序"
    },
    {
      "sentence": "分支限界是布隆过滤器的实现方式",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "布隆过滤器可通过分支限界实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "分支限界常用于布隆过滤器的实现",
      "relation": "implementedAs",
      "entity1": "布隆过滤器",
      "entity2": "分支限界"
    },
    {
      "sentence": "借助拓扑排序可构建树状数组。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组的构建依赖拓扑排序。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "拓扑排序是树状数组的构建方式之一。",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "前缀树的实现方式是KMP算法",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树采用KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "前缀树借助KMP算法实现",
      "relation": "implementedAs",
      "entity1": "前缀树",
      "entity2": "KMP算法"
    },
    {
      "sentence": "不相交集合的实现采用归并排序",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "归并排序被用于实现不相交集合",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "不相交集合通过归并排序来实现",
      "relation": "implementedAs",
      "entity1": "不相交集合",
      "entity2": "归并排序"
    },
    {
      "sentence": "平衡二叉树通过普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树采用普里姆算法实现",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "平衡二叉树以普里姆算法为实现方式",
      "relation": "implementedAs",
      "entity1": "平衡二叉树",
      "entity2": "普里姆算法"
    },
    {
      "sentence": "队列采用记忆化搜索作为实现策略",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列以记忆化搜索为实现手段",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "队列借助记忆化搜索完成实现",
      "relation": "implementedAs",
      "entity1": "队列",
      "entity2": "记忆化搜索"
    },
    {
      "sentence": "树状数组实现时采用拓扑排序",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组借助拓扑排序来实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "树状数组通过拓扑排序完成实现",
      "relation": "implementedAs",
      "entity1": "树状数组",
      "entity2": "拓扑排序"
    },
    {
      "sentence": "哈希表采用归并排序作为实现策略",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表以归并排序为实现手段",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "哈希表借助归并排序完成数据操作",
      "relation": "implementedAs",
      "entity1": "哈希表",
      "entity2": "归并排序"
    },
    {
      "sentence": "LRU缓存的核心实现采用迪杰斯特拉算法",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存通过迪杰斯特拉算法实现",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "LRU缓存以迪杰斯特拉算法为实现方式",
      "relation": "implementedAs",
      "entity1": "LRU缓存",
      "entity2": "迪杰斯特拉算法"
    },
    {
      "sentence": "迪杰斯特拉算法采用优先队列来优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列高效寻找最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "通过优先队列，迪杰斯特拉算法实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构来处理相关问题",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为实现高效计算，弗洛伊德算法采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构被弗洛伊德算法用于优化计算过程",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "折半查找算法依赖线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找执行时所需的关键数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找在操作中必须基于线性表来实现",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "选择排序过程中采用B树来存储数据",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序借助B树实现数据的高效存储",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "为优化数据操作，选择排序使用B树结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "归并排序过程中会借助双端队列高效处理数据",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列被归并排序用于优化数据存取操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序采用双端队列辅助数据处理流程",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插值查找利用布隆过滤器进行数据查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器实现快速查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器被插值查找算法用作数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "在解决某些问题时，广度优先搜索会利用大根堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索算法在处理优先队列问题时使用大根堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "为优化性能，广度优先搜索实现中常采用大根堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法的实现基于链表数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "冒泡排序过程中，会利用斐波那契堆进行数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化冒泡排序的效率，斐波那契堆被其选用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法在处理数据时，会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "希尔排序实现过程中会用到哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "为提升排序效率，希尔排序借助哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序算法通过哈希表实现高效操作",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "计数排序算法以生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序在算法实现中使用生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序借助生成森林完成数据处理",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "最小生成树算法借助后缀树数据结构实现",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树实现时会用到后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树依靠后缀树数据结构完成",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "插入排序在实现时会用到栈",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序借助栈来完成排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序的实现依赖于栈结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找借助平衡二叉树完成数据检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找通过平衡二叉树实现数据的快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "记忆化搜索借助线段树提升数据处理效率",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索利用线段树优化数据管理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索在实现中使用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "堆排序算法借助二叉搜索树来实现",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序在实现中采用二叉搜索树结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序的构建过程基于二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为实现线性查找，算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找在执行中，会使用优先队列来辅助操作",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "当进行线性查找时，优先队列是算法依赖的数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略的算法实现中，平衡二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在执行贪心策略时，系统借助平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效执行贪心策略，平衡二叉树是其选用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "折半查找实现时使用栈来存储数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中借助栈管理中间数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找算法中栈被用于暂存查找数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "单源最短路径算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径借助优先队列数据结构来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径的求解依赖于优先队列数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是迪杰斯特拉算法的关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法依靠二叉堆实现高效路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "在进行穷举法搜索时，B+树提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法的实现过程中，常借助B+树来组织数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "为优化穷举法的效率，B+树作为核心数据结构被采用",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "Dijkstra算法采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法使用后缀树来支持其操作",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法在实现中依赖后缀树结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "实现基数排序时，线性表是核心数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序依赖线性表作为数据结构存储元素",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表被基数排序用作数据结构来处理数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "Bellman-Ford算法在处理大规模数据时使用B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树被Bellman-Ford算法用于优化路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为提升性能，Bellman-Ford算法采用B树作为辅助结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "分支限界算法依赖布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界在操作中借助布隆过滤器处理数据",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "为实现高效数据管理，分支限界使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "迪杰斯特拉算法在路径规划中依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表是迪杰斯特拉算法常用的数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法实现最短路径时采用循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "深度优先搜索过程中会使用可持久化数据结构来存储中间状态",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构是深度优先搜索算法的常用存储工具",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索借助可持久化数据结构实现高效数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "在状态转移算法中，线段树被用作数据处理的工具",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移的实现依赖线段树来管理数据",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "处理状态转移时，线段树是关键的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "为优化动态规划，系统采用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划处理问题时，常借助小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划实施过程中，会使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "快速排序实现中常借助平衡二叉树优化",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序在优化时依赖平衡二叉树存储数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序的分区过程使用平衡二叉树辅助",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "折半查找算法依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找以线性表为核心数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找实现中使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找借助平衡二叉树完成数据检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找通过平衡二叉树实现数据的快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖于优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "借助优先队列，迪杰斯特拉算法可高效计算最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略的算法实现中，平衡二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在执行贪心策略时，系统借助平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效执行贪心策略，平衡二叉树是其选用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分治算法借助单链表来处理相关数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法依托单链表实现高效数据操作",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法以单链表作为数据处理的载体",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "计数排序实现时会用到生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中使用生成森林数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序所使用的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "外部排序算法依赖小根堆来实现",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序过程中会用到小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是外部排序使用的数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "贪心策略算法依赖平衡二叉树来存储数据",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略借助平衡二叉树实现高效操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略利用平衡二叉树优化数据查找",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序借助哈希表来优化数据查找",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序依赖哈希表完成数据存储与检索",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序算法采用哈希表来处理数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "计数排序过程中，会用到大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是计数排序算法中常用的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法依赖大根堆来完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "外部排序过程中，线段树被用作关键数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "为优化外部排序效率，线段树常被算法采用",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序算法在处理大规模数据时，依赖线段树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希查找过程中，平衡二叉树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "构建高效哈希查找算法时，平衡二叉树是关键的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化哈希查找性能，平衡二叉树常被选用",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "计数排序在执行过程中依赖生成森林的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序实现时的关键数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序利用生成森林来优化排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "Bellman-Ford算法在实现中会用到B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化性能，Bellman-Ford算法使用B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是Bellman-Ford算法所依赖的数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序的实现需要B树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序在执行时使用B树数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序算法借助B树来组织数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "克鲁斯卡尔算法借助堆来管理数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "为高效实现，克鲁斯卡尔算法采用堆结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法中用于排序的关键数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "Bellman-Ford算法依赖二项堆进行操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆完成最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法采用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "执行冒泡排序时，系统借助后缀树",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序运行需使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "实现冒泡排序过程中，后缀树被系统使用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "分支限界算法采用栈作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界借助栈来实现其算法逻辑",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界中，栈是常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "插值查找借助生成森林实现高效搜索",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找实现时采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "为提升效率，插值查找依靠生成森林结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "哈希查找算法依赖二叉堆来实现",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找借助二叉堆完成高效操作",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找算法的关键数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找借助二叉堆实现快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找的重要数据结构支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找通过二叉堆优化数据存储与检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树来实现数据查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现高效查找，哈希查找借助平衡二叉树结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在实现中采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分支限界算法中，栈常用于存储待扩展的节点",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界算法里，栈是关键的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界过程中依赖栈来管理搜索状态",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "多路归并过程中使用后缀树来优化数据存储",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效实现多路归并，后缀树被用作其核心数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "多路归并的实现依赖于后缀树这一数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "外部排序算法采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序借助线段树来处理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序利用线段树完成排序任务",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "快速排序借助哈希表优化数据存储",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序算法在某些场景下依赖哈希表进行数据索引",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序通过哈希表实现高效的重复元素去重",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "在回溯法的实现中，不相交集合是常用的数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法解决问题时，常借助不相交集合管理数据",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "单源最短路径的实现过程中使用了优先队列",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "为计算单源最短路径，优先队列是必要的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径借助优先队列完成计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "插值查找的实现依赖二项堆数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找采用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆被插值查找用作数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "折半查找实现依赖栈数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找借助栈完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找实现需使用栈数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是回溯法常用的数据结构之一（注：此处原句可能有歧义，已调整为更准确的“回溯法在其算法设计中运用字典树作为数据结构”，确保明确回溯法使用字典树）",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "冒泡排序采用斐波那契堆数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序实现中使用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序用作算法数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "二路归并算法依赖堆作为关键数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆是二路归并算法常用的数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并算法以堆为核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "快速排序借助哈希表来优化数据查找",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序依赖哈希表完成数据存储与检索",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序算法采用哈希表来处理数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "冒泡排序借助斐波那契堆实现高效排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序算法用于数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法依靠斐波那契堆优化操作性能",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "KMP算法在运行时会利用B树作为数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是KMP算法执行过程中所依赖的数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "执行KMP算法时，B树被用作其数据结构支持",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "最小生成树算法在实现时采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树的算法实现借助红黑树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "构建最小生成树时需用到红黑树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "归并排序实现时会用到跳跃表",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是归并排序算法中的常用数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为高效实现归并排序，算法采用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "克鲁斯卡尔算法实现时会使用B树",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是克鲁斯卡尔算法处理数据的重要工具",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化性能，克鲁斯卡尔算法依赖B树结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "哈希查找算法依赖不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为实现哈希查找，算法采用了不相交集合",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找过程中运用了不相交集合数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找过程中，平衡二叉树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "构建高效哈希查找算法时，平衡二叉树是关键的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化哈希查找性能，平衡二叉树常被选用",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "二路归并算法的实现依赖于堆的使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化其操作效率",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并在处理过程中采用堆作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "分治算法借助栈来实现",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治算法采用栈完成任务",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治算法的实现依赖于栈",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "深度优先搜索算法在实现过程中会使用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为高效处理数据，深度优先搜索会运用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集常被深度优先搜索算法用于辅助数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "动态规划算法采用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划借助跳跃表优化数据操作",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划依赖跳跃表实现高效数据管理",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "迪杰斯特拉算法采用优先队列来优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列高效寻找最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "通过优先队列，迪杰斯特拉算法实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "穷举法实现中，二叉搜索树是关键的数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "当穷举法处理有序数据时，二叉搜索树能发挥作用",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为优化穷举法的性能，二叉搜索树常被选用",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "最小生成树算法中，字典树用于存储路径信息",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建最小生成树时，字典树可高效存储节点数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "为优化最小生成树性能，字典树被用来做数据索引",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "堆排序实现需借助并查集作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是堆排序实现时采用的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序算法中会使用并查集这一数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "计数排序算法依赖堆作为核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序借助堆结构完成排序操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序以堆为关键数据结构实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "弗洛伊德算法使用可持久化数据结构作为核心数据支撑",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法以可持久化数据结构为关键数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构完成计算任务",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "实现普里姆算法时，二叉树是常用数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法处理图结构时，二叉树用于管理节点",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法中，二叉树作为数据结构存储边权",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "KMP算法在实现时会用到B树作为数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化数据处理，KMP算法采用B树来存储信息",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是KMP算法中用于数据存储的关键结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "直接插入排序过程中，会利用循环队列",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序借助循环队列来实现",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列是直接插入排序使用的数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "计数排序在实现中使用堆数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序借助堆数据结构完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序基于堆数据结构实现",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "拓扑排序借助大根堆实现排序功能",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序的实现依赖大根堆数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序以大根堆为核心数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "冒泡排序借助斐波那契堆优化数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序为提升性能采用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序在排序过程中利用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "在单源最短路径算法中，线性表是常用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "构建单源最短路径时，线性表被广泛应用",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径的实现依赖于线性表",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "桶排序实现时依赖于堆数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序借助堆数据结构完成排序过程",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序的实现过程需要堆数据结构的支持",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "最小生成树算法在实现时使用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "实现最小生成树需借助后缀树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树构建过程依赖后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "希尔排序实现中会用到哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表是希尔排序的重要数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序借助哈希表优化操作效率",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "记忆化搜索执行时会使用小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "为优化记忆化搜索，系统借助小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "记忆化搜索过程中常使用小根堆辅助",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "迪杰斯特拉算法使用循环链表存储路径数据",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表是迪杰斯特拉算法的关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "多路归并算法使用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并依托二叉树实现高效归并",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并以二叉树为核心数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "插值查找的实现需要布隆过滤器数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器是插值查找使用的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分治算法实现时会使用字典树作为数据结构。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中依赖字典树来完成算法步骤。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法为高效实施会使用字典树。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "计数排序在执行过程中依赖生成森林的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序实现时的关键数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序利用生成森林来优化排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "迪杰斯特拉算法采用优先队列来优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列高效寻找最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "通过优先队列，迪杰斯特拉算法实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "冒泡排序采用斐波那契堆数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序实现中使用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序用作算法数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "堆排序算法中，会借助并查集来管理数据",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集被堆排序用于优化某些操作",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序过程中，常使用并查集来处理集合问题",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "克鲁斯卡尔算法在实现过程中会用到B树",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "为支持克鲁斯卡尔算法高效运行，B树常被选用",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "克鲁斯卡尔算法的实现依赖于B树的数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "冒泡排序在处理复杂字符串匹配时会用到后缀树",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "为提升排序效率，冒泡排序有时会使用后缀树结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是冒泡排序处理长文本排序时依赖的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序在实现中依赖后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序以后缀树作为其数据结构支撑",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序借助后缀树来实现其算法逻辑",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法的构建过程依赖后缀树的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树的某些应用场景借助后缀树来优化数据处理",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在实现最小生成树时，算法会利用后缀树来存储关键数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在实现选择排序时，算法借助了不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序算法在执行过程中运用了不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为了高效完成选择排序，算法采用了不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "迪杰斯特拉算法在路径计算中依赖二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆实现高效路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法使用二叉堆作为关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "状态转移算法依赖树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移算法使用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法以树为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "穷举法在执行过程中会用到B+树来存储数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "为了高效处理数据，穷举法会使用B+树",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法借助B+树来组织数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "哈希查找借助二叉堆实现快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找的重要数据结构支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找通过二叉堆优化数据存储与检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "Dijkstra算法在最短路径计算中采用小根堆。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法依赖小根堆来优化路径查找。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是Dijkstra算法实现中的关键数据结构。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "直接插入排序算法采用树状数组作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序借助树状数组优化排序过程",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序利用树状数组提升排序效率",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "插入排序实现中常使用双端队列来优化操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是插入排序中常用的数据结构工具",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序借助双端队列提升排序效率",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "基数排序在实现时会使用数组来存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组来存储待排序的元素",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序利用数组来存储排序数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "回溯法实现复杂问题时借助不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法的高效求解常需要不相交集合的支持。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法在处理问题时会利用不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "在实现最小生成树时，算法使用了字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树算法在运行时会用到字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "为计算最小生成树，字典树被算法使用",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "单源最短路径算法依赖线性表来存储中间数据",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径借助线性表完成路径计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法采用线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "多路归并算法采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "二叉树是多路归并算法使用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并实现中依赖二叉树数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "回溯法在实现时会用到单链表",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法算法执行中依赖单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表被回溯法用于存储中间状态",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "构建最小生成树时，算法会使用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在处理最小生成树问题中，后缀树被用作数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效计算最小生成树，算法采用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存来实现高效操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索算法用作数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在算法实现中使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并实现中，堆是核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆被用于二路归并算法的实现",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "多路归并算法借助二叉树实现归并",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并过程中采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "为高效执行多路归并，系统依靠二叉树",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "折半查找算法在某些实现中会用到栈",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找实现中会借助栈来完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中会调用栈辅助实现",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "穷举法借助B+树来存储和处理数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法以B+树作为数据结构支撑",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法依靠B+树实现数据管理",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "基数排序基于线性表实现排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序以线性表为基础数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "在分块查找算法中，双端队列被用作存储待处理数据的结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找过程中，双端队列常用来暂存中间数据以优化效率",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升分块查找性能，双端队列是其关键数据结构之一",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "线性查找算法以LFU缓存为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找借助LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找依赖LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "外部排序过程中，系统使用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "为执行外部排序，算法采用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树被外部排序算法使用。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "分块查找算法采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找算法依赖红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找算法利用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "归并排序实现时，采用了可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序算法执行时，依赖于可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为实现归并排序，可持久化数据结构被算法所使用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "在寻找最短路径时，迪杰斯特拉算法依赖优先队列来管理节点",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法通过优先队列实现高效的路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是迪杰斯特拉算法中关键的数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找借助平衡二叉树完成数据检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找通过平衡二叉树实现数据的快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "计数排序实现时会用到生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中使用生成森林数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序所使用的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "外部排序算法依赖线段树来实现",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序借助线段树来处理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "最小生成树算法依赖红黑树实现高效操作",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树借助红黑树来优化数据处理",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被最小生成树算法采用以管理结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "贪心策略采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略算法依赖平衡二叉树来运作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略借助平衡二叉树实现高效操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "希尔排序借助线性表来完成排序操作",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序在实现时依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序的实现过程中运用了线性表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "Bellman-Ford算法使用队列来辅助操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法依赖队列实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法借助队列完成松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "拓扑排序实现过程中会借助循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序的实现依赖于循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序算法在实现时会利用循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "外部排序在实现中使用小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆完成数据排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法采用小根堆来优化排序过程",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "在寻找最短路径时，迪杰斯特拉算法依赖优先队列来管理节点",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法通过优先队列实现高效的路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是迪杰斯特拉算法中关键的数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构来完成计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "实现弗洛伊德算法时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法的实现过程中使用了可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索在运行时会用到LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为优化深度优先搜索性能，LFU缓存被其采用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法实现中，LFU缓存作为数据结构被使用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "广度优先搜索需要借助大根堆数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索的实现采用大根堆数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索算法中使用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "贪心策略依赖优先队列实现高效决策",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略借助优先队列处理优先级任务",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略常以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "堆排序在实现过程中使用二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树是堆排序所依赖的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序算法实现时会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "弗洛伊德算法实现过程中会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为提升弗洛伊德算法的性能，常采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法的实现离不开可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "分块查找在实现时会用到双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找过程中会利用双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找的高效实现离不开双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "基数排序算法依赖线性表来完成排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序借助线性表实现其排序功能",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序的实现需使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "Dijkstra算法在路径计算中，依赖小根堆高效处理节点距离",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是Dijkstra算法实现最短路径的关键数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法借助小根堆来管理待探索的节点",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法在路径求解中使用后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "实现Dijkstra算法时，系统采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "为优化路径计算，Dijkstra算法借助后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "普里姆算法依赖树结构来实现",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法通过树结构构建最小生成树",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "树是普里姆算法处理图的关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "克鲁斯卡尔算法的实现依赖B树作为数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "运行克鲁斯卡尔算法时，会用到B树",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "克鲁斯卡尔算法采用B树来存储和管理数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "弗洛伊德算法采用链表作为核心数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法使用链表实现算法功能",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表完成计算过程",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "状态转移算法依赖队列这一数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "队列是状态转移算法中常用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移处理中，队列作为数据结构被广泛使用",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "多路归并实现过程中依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "多路归并算法实现时会用到线性表这种数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是多路归并算法常用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法借助优先队列实现最短路径计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法利用优先队列提升路径查找效率",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "堆排序算法使用并查集作为关键数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序在排序过程中借助并查集作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序采用并查集作为数据结构的核心组件",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "状态转移算法依赖队列来实现",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法借助队列完成状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法采用队列进行状态转换",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "哈希查找使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是哈希查找所使用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在算法中采用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找依赖平衡二叉树优化检索过程",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序采用线性表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序以线性表为数据结构实现排序",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序借助线性表存储待排序数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "二路归并算法的实现依赖于堆的使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化其操作效率",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并在处理过程中采用堆作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "插入排序算法借助栈来实现",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "栈是插入排序使用的数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序实现过程中会用到栈",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "Bellman-Ford算法在处理大规模数据时使用B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树被Bellman-Ford算法用于优化路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为提升性能，Bellman-Ford算法采用B树作为辅助结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "折半查找算法依赖线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找执行时所需的关键数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找在操作中必须基于线性表来实现",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "穷举法借助B+树来存储和处理数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法以B+树作为数据结构支撑",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法依靠B+树实现数据管理",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "直接插入排序借助树状数组优化数据操作",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序依赖树状数组来实现高效排序",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序采用树状数组作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "计数排序在执行过程中使用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为实现计数排序，系统采用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "记忆化搜索算法依赖红黑树优化数据存储",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是记忆化搜索中常用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索通过红黑树实现高效数据查找",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "动态规划算法在某些场景中会使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆常被动态规划用于优化算法效率",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "解决复杂问题时，动态规划借助小根堆管理状态",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "插值查找过程中使用生成森林构建索引",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "为实现快速定位，插值查找采用生成森林存储关键数据",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找算法在搜索时利用生成森林优化数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找算法的实现需要用到生成森林",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "进行插值查找时，生成森林是其依赖的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是插值查找算法中常用的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "哈希查找算法会用到平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为了高效执行哈希查找，平衡二叉树被用作其数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找过程中，平衡二叉树是其使用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "记忆化搜索在实现时会用到红黑树",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "为优化性能，记忆化搜索采用红黑树",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索借助红黑树提升搜索效率",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "二路归并算法使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并算法以LFU缓存为关键数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并算法借助LFU缓存实现数据管理",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "插值查找算法采用二项堆作为数据存储结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "为高效实现插值查找，二项堆被用作其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找过程中，二项堆是关键的数据结构支持",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "外部排序的实现依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序借助字典树实现高效排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "在实现外部排序时，字典树是其使用的数据结构之一",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "弗洛伊德算法采用大根堆作为核心数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法借助大根堆实现其核心功能",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法以大根堆作为关键数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "最小生成树算法使用字典树来优化路径查找",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "在实现最小生成树时，字典树被算法用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建最小生成树的过程中，字典树是其依赖的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "插入排序借助二项堆实现排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序以二项堆为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序依赖二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "折半查找算法实现中，线性表是常用的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "为了高效执行折半查找，通常需要线性表支持",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找能够高效运行的数据结构基础",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "分块查找过程中会用到双端队列来优化操作",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升分块查找的性能，双端队列常被选用",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是分块查找中常用的数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "最小生成树算法使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法依赖后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法利用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "多路归并算法采用线性表作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是多路归并算法的核心数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "多路归并算法借助线性表实现归并操作",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "拓扑排序借助循环链表实现",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序利用循环链表进行处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序以循环链表为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "分支限界算法借助双端队列实现高效搜索",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界通过双端队列进行状态管理",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界算法在实现中采用双端队列",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "迪杰斯特拉算法采用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法以循环链表为核心存储结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表组织数据",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "外部排序过程中，系统会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序在实现时，依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序算法执行时，会借助字典树来辅助",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "状态转移算法以线段树为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法运用线段树处理数据",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法借助线段树优化操作",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法实现时需使用线段树",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移过程中依靠线段树来完成计算",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法通过线段树实现高效计算",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "计数排序的核心步骤中会用到堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序优化排序效率时依赖堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆数据结构被计数排序用于优化排序效率",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "KMP算法借助优先队列存储中间数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法在匹配过程中使用优先队列管理状态",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法处理前缀时利用优先队列更新信息",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "外部排序算法使用字典树作为关键数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序依靠字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序以字典树为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "堆排序在实现时会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序算法的实现过程中依赖二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序实现过程中会采用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索实现时，常借助斐波那契堆提升效率",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "高效的广度优先搜索通常选用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索在特定场景中会使用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "动态规划算法依赖小根堆来优化计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划借助小根堆实现高效的状态转移",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划采用小根堆作为关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "归并排序算法依赖双端队列进行实现",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序借助双端队列来完成排序过程",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序在实现时会用到双端队列",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "线性查找使用LFU缓存存储数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为提升查找效率，线性查找采用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找借助LFU缓存实现数据存储",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "Dijkstra算法在实现过程中会使用后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "为了高效处理数据，Dijkstra算法采用后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是Dijkstra算法中用于存储关键数据的结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "深度优先搜索的实现过程中，常使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法在处理复杂场景时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构在深度优先搜索中发挥着关键作用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "选择排序过程中，B树常被用作数据存储结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "在选择排序算法的实现里，B树是关键数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序算法使用B树来管理数据",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "分治算法常借助栈来实现递归过程",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "为了高效处理分治问题，栈是常用的数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治策略中，栈用于管理递归过程中的状态",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "拓扑排序过程中，常借助大根堆进行数据处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为高效实现拓扑排序，大根堆被用于数据管理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序算法中，大根堆用于维护待处理数据",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "深度优先搜索算法常借助并查集来高效处理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为优化性能，深度优先搜索会依靠并查集进行数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "在解决复杂问题时，深度优先搜索算法采用并查集作为辅助结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "线性查找的高效实现需要优先队列支持",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是线性查找的重要数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找过程中借助优先队列优化操作",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "在状态转移算法中，线段树常被用作数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移过程中，线段树是常用的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "实现状态转移时，线段树是关键的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "深度优先搜索的实现过程中，常使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法在处理复杂场景时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构在深度优先搜索中发挥着关键作用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "贪心策略的算法实现中，常借助平衡二叉树进行高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的效率，平衡二叉树是其常用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在实现贪心策略时，平衡二叉树被用作关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "直接插入排序在实现时依赖二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "在直接插入排序算法中，二叉堆被用作数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "直接插入排序过程中会使用二叉堆来辅助操作",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "深度优先搜索算法依赖并查集来高效处理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索借助并查集实现数据结构操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索利用并查集完成特定数据结构任务",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "拓扑排序借助斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序的高效实现依赖于斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆是拓扑排序中常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存优化操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法采用LFU缓存管理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索利用LFU缓存存储中间结果",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "计数排序过程中，堆是核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现计数排序时，堆作为关键数据结构被使用",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序算法依赖堆来优化排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序的高效实现依赖大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是计数排序实现的重要数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序借助大根堆完成排序操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "在实现冒泡排序时，会用到单链表数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "冒泡排序算法借助单链表进行数据操作",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是冒泡排序算法中常用的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "单源最短路径算法在实现时会使用线性表来处理路径信息",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "为高效计算，单源最短路径采用线性表存储路径数据",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径的实现过程中，线性表被用于存储关键数据",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序依赖线性表作为其数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序在实现中使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序借助线性表来实现其排序逻辑",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "线性查找算法实现时需使用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为高效查找，线性查找会借助LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找实现过程中依赖LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "选择排序借助B树来完成排序操作",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序在实现中以B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序实现排序时依赖B树的数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "计数排序过程中，会借助大根堆进行数据管理",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为高效排序，计数排序采用大根堆辅助数据处理",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法在排序时使用大根堆优化数据存储",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "回溯法实现过程中常依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是回溯法处理某些问题的常用数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决特定问题时会使用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "深度优先搜索算法在实现中使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索借助可持久化数据结构来运行",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索需依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "Dijkstra算法使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法以后缀树为数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法借助后缀树实现路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "外部排序的实现过程中会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树为外部排序提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序借助字典树优化数据存储与检索",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "堆排序实现中常使用前缀树处理有序数据",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "为优化堆排序性能，常采用前缀树作为辅助结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序借助前缀树实现快速数据检索",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "实现二路归并时，LFU缓存是核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并过程中采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存常用于二路归并的实现",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "归并排序在实现中使用可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序借助可持久化数据结构完成排序",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序利用可持久化数据结构优化排序",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "最小生成树算法使用字典树来优化路径查找",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "在实现最小生成树时，字典树被算法用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建最小生成树的过程中，字典树是其依赖的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "贪心策略的算法实现中，常借助平衡二叉树进行高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的效率，平衡二叉树是其常用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在实现贪心策略时，平衡二叉树被用作关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "广度优先搜索借助斐波那契堆数据结构实现高效遍历",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索在实现中采用斐波那契堆作为核心数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索算法依赖斐波那契堆来优化数据操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "Bellman-Ford算法在处理大规模数据时使用B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树被Bellman-Ford算法用于优化路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为提升性能，Bellman-Ford算法采用B树作为辅助结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构来完成计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "实现弗洛伊德算法时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法的实现过程中使用了可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "在执行广度优先搜索时，算法借助斐波那契堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索的实现过程中，系统采用斐波那契堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为实现高效的广度优先搜索，系统使用斐波那契堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "在实现最小生成树时，算法使用了字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树算法在运行时会用到字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "为计算最小生成树，字典树被算法使用",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "拓扑排序算法使用大根堆来实现",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序借助大根堆完成排序",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序依赖大根堆作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "贪心策略的算法实现中，平衡二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在执行贪心策略时，系统借助平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效执行贪心策略，平衡二叉树是其选用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "归并排序在实现中使用可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序借助可持久化数据结构完成排序",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序利用可持久化数据结构优化排序",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖于优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "借助优先队列，迪杰斯特拉算法可高效计算最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "多路归并算法借助二叉树实现归并",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并过程中采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "为高效执行多路归并，系统依靠二叉树",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "二路归并算法在实现中使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为提升性能，二路归并采用LFU缓存来管理数据",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是二路归并算法操作时依赖的数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "KMP算法借助B树来实现",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法采用B树作为数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法实现时会用到B树",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "状态转移算法采用队列作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法借助队列实现状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法通过队列处理状态转换",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "希尔排序的实现过程中，会借助双向链表来完成",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序在排序过程中使用双向链表作为辅助结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "为高效实现希尔排序，双向链表常被用作数据存储结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "拓扑排序过程中，常使用斐波那契堆来管理节点",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为实现高效的拓扑排序，斐波那契堆被用于维护关键信息",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序算法借助斐波那契堆优化数据处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "插值查找算法以二项堆作为其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找将二项堆作为关键数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找算法使用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序算法依赖双端队列来完成操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序算法采用双端队列作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序在实现过程中使用双端队列",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界算法借助栈来实现",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界的实现依赖于栈结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界通过栈来完成操作",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "状态转移算法使用树作为主要数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法依赖树作为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法以树作为关键数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "克鲁斯卡尔算法使用堆来管理边权",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法依赖堆来高效处理边",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "借助堆，克鲁斯卡尔算法实现高效的边排序",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "快速排序算法使用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序以哈希表作为关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序实现时借助哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "基数排序需要数组作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序依靠数组来实现排序",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序的实现依赖于数组结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "弗洛伊德算法使用大根堆数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法借助大根堆来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法实现过程中运用大根堆",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "选择排序算法使用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合是选择排序算法使用的关键数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序借助不相交集合来实现算法逻辑",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "桶排序使用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序借助红黑树实现数据结构管理",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序依靠红黑树作为关键数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "多路归并算法在实现时，采用了后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效实现多路归并，系统选用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "多路归并实现中使用了后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "为执行状态转移，系统使用队列",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移过程中，队列被算法使用",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "算法在处理状态转移时采用队列",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "线性查找算法依赖二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找以二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找利用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "普里姆算法借助二叉树存储数据。",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法利用二叉树管理数据。",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法以二叉树为数据存储结构。",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "冒泡排序算法依赖后缀树完成排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序借助后缀树实现高效排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序实现过程中使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "外部排序过程中，系统会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序在实现时，依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序算法执行时，会借助字典树来辅助",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "单源最短路径算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径借助优先队列数据结构来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径的求解依赖于优先队列数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "动态规划算法中常使用跳跃表来提升数据查找速度",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为优化性能，动态规划会借助跳跃表实现快速数据操作",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划问题求解时，跳跃表是常用的数据结构选择",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "迪杰斯特拉算法在实现过程中采用了循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "在路径规划中，迪杰斯特拉算法借助循环链表高效存储数据",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "为优化最短路径计算，迪杰斯特拉算法依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "普里姆算法在计算最小生成树时使用树结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "树是普里姆算法计算最小生成树的关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法通过树结构实现图的最小生成",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法中常使用树来存储状态",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移过程中常用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "处理状态转移时，树常被用作核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "分治算法的实现常采用单链表数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治求解过程中使用单链表数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是分治算法常用的数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "克鲁斯卡尔算法实现时会使用B树",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是克鲁斯卡尔算法处理数据的重要工具",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化性能，克鲁斯卡尔算法依赖B树结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "状态转移算法中广泛使用树结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移实现中不可或缺的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "在状态转移的算法设计中，树被用作关键数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "基数排序在执行过程中依赖线性表结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序算法实现时使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序的操作过程中会用到线性表",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "Bellman-Ford算法使用队列来辅助操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法依赖队列实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法借助队列完成松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "迪杰斯特拉算法在运行时依赖优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "实现迪杰斯特拉算法需要借助优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "分支限界算法在求解过程中依赖于栈",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界算法中，栈是其常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "实现分支限界时，栈被算法所采用",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "单源最短路径算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法借助优先队列实现最短路径计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法利用优先队列提升路径查找效率",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "堆排序实现过程中会用到前缀树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法中，前缀树常被用作数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序实现时依赖前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "迪杰斯特拉算法依赖二叉堆来优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为了高效执行，迪杰斯特拉算法采用二叉堆作为辅助结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "Dijkstra算法实现过程中会使用后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法依赖后缀树来优化路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法借助后缀树完成最短路径分析",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "克鲁斯卡尔算法在排序边时依赖堆结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法中管理边优先级的关键数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法通过堆实现边的高效排序",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "贪心策略算法依赖优先队列进行高效决策",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略借助优先队列实现任务优先级排序",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略采用优先队列作为关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "最小生成树的实现依赖字典树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树在算法实现中会用到字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建最小生成树时使用字典树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建动态规划算法时，常使用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划在优化问题中借助跳跃表来存储数据",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为提升动态规划的效率，跳跃表被用作其数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "最小生成树算法采用字典树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树的实现依赖于字典树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树在算法设计中需要字典树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "普里姆算法借助斐波那契堆来高效实现",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化实现，普里姆算法采用斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法实现中使用了斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "穷举法中，数组用于存储待检查的元素",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "数组是穷举法实现过程中的关键数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "使用穷举法解决问题时，数组常被用来存储候选解",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "直接插入排序使用树状数组作为主要数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序借助树状数组作为关键数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序算法运用树状数组作为基础数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "快速排序算法借助平衡二叉树来优化数据存储",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效实现快速排序，平衡二叉树被用作其数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是快速排序算法中常用的数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "直接插入排序算法采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序在排序过程中使用循环队列",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列被直接插入排序用于数据处理",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "广度优先搜索执行时使用堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "堆是广度优先搜索的关键数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索借助堆完成操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序借助B树来高效存储数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "为实现高效排序，桶排序采用B树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序算法运用B树来组织和管理数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "状态转移算法采用树数据结构进行状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树结构被状态转移算法用于处理状态变化",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移过程中运用树作为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "线性查找算法会用到二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找为了高效，会用二叉堆管理数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是线性查找算法中使用的数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "普里姆算法在实现时依赖树结构来管理节点",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "为了高效计算最小生成树，普里姆算法采用树来组织数据",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "树是普里姆算法处理图时使用的数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "处理状态转移问题时，线段树是高效的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法实现依赖线段树这一数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "实现状态转移过程中，线段树作为核心数据结构被使用",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "计数排序实现时会用到生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中使用生成森林数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序所使用的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "基数排序在实现时会使用数组来存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组来存储待排序的元素",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序利用数组来存储排序数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "分支限界算法依赖布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界在操作中借助布隆过滤器处理数据",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "为实现高效数据管理，分支限界使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存优化操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法采用LFU缓存管理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索利用LFU缓存存储中间结果",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在运行时会用到LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为优化深度优先搜索性能，LFU缓存被其采用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法实现中，LFU缓存作为数据结构被使用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "折半查找算法实现时，生成森林是核心数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "为优化折半查找效率，需运用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找过程中，生成森林是关键依赖的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "Bellman-Ford算法的实现依赖于二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆常被Bellman-Ford算法用作数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法在路径计算中使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "分治算法在递归实现中常借助栈",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "栈是分治策略处理复杂问题的辅助结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治过程中通过栈来管理递归调用状态",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分块查找算法中，常借助红黑树实现数据存储",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "为提升效率，分块查找会采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被分块查找算法用于数据的高效管理",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "在分块查找算法中，平衡二叉树常被用作数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找过程中，平衡二叉树作为核心数据结构被使用",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为提升分块查找效率，平衡二叉树是常用的数据结构选择",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "深度优先搜索算法在实现中使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索借助可持久化数据结构来运行",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索需依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "单源最短路径算法借助线性表来存储路径信息",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "在单源最短路径的计算中，线性表是常用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径问题的解决依赖线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "外部排序过程中，系统会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序在实现时，依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序算法执行时，会借助字典树来辅助",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序过程中，系统会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序在实现时，依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序算法执行时，会借助字典树来辅助",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "在解决动态规划问题时，跳跃表常被用作高效的数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划算法实现中，跳跃表是提升性能的关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "设计动态规划方案时，跳跃表是常用的辅助数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "穷举法在数据检索中常借助B+树",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是穷举法进行有序数据存储的常用结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法实现中，B+树被用作核心数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "线性查找依赖二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找借助二叉堆实现数据操作",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找采用二叉堆进行数据查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "折半查找算法在优化过程中会使用生成森林",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是折半查找实现所需的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找在构建索引时依赖生成森林",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "线性查找依赖二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找借助二叉堆进行数据查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找使用二叉堆存储待查数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找算法在优化时依赖不相交集合的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "实现哈希查找的高效版本需借助不相交集合",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找在某些应用中会使用不相交集合来提升效率",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "堆排序算法在实现过程中会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为了高效排序，堆排序借助二叉搜索树进行数据处理",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树被堆排序算法用于存储中间数据",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "选择排序实现过程中使用B树",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "B树被选择排序用于数据管理",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "执行选择排序时借助B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "基数排序算法依赖数组来存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组实现排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序以数组作为基础数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "直接插入排序的实现依赖于树状数组数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序利用树状数组来优化排序过程",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序借助树状数组完成高效排序",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "插入排序实现中，常借助双端队列优化操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是插入排序提升性能的关键数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "在插入排序算法里，双端队列被用于高效维护有序序列",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "实现拓扑排序时，循环链表用于存储节点关系",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中，循环链表是常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "构建拓扑排序时，循环链表被用来辅助存储操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "弗洛伊德算法采用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法借助大根堆来实现操作",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法依赖大根堆完成操作",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "迪杰斯特拉算法采用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表实现路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "直接插入排序算法中，循环队列用于存储中间数据",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "为实现直接插入排序，循环队列被用作数据存储结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序过程中，循环队列辅助存储待排序数据",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "外部排序过程中，线段树被用作数据结构来优化排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序算法使用线段树来管理数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "在外部排序中，线段树是其数据结构的重要组成部分",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希查找算法中，二叉堆是关键的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "构建哈希查找系统时，二叉堆常被用作辅助结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找过程中，二叉堆是重要的数据支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找的实现采用优先队列数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找借助优先队列数据结构完成查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找基于优先队列数据结构实现查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略算法依赖优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略借助优先队列实现高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略的算法以优先队列为关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "冒泡排序在处理复杂字符串匹配时会用到后缀树",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "为提升排序效率，冒泡排序有时会使用后缀树结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是冒泡排序处理长文本排序时依赖的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖于优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "借助优先队列，迪杰斯特拉算法可高效计算最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "桶排序的实现需要B树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序在执行时使用B树数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序算法借助B树来组织数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "基数排序算法依赖数组来存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组实现排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序以数组作为基础数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "分支限界算法依赖布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界在操作中借助布隆过滤器处理数据",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "为实现高效数据管理，分支限界使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助生成森林实现高效搜索",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找实现时采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "为提升效率，插值查找依靠生成森林结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "归并排序算法在实现过程中会用到跳跃表",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为提升归并排序的效率，跳跃表常被用作其辅助数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在处理有序数据时，会借助跳跃表实现快速查找",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "KMP算法借助B树来实现",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法采用B树作为数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法实现时会用到B树",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "冒泡排序过程中，会利用斐波那契堆进行数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化冒泡排序的效率，斐波那契堆被其选用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法在处理数据时，会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "快速排序算法依赖线性表进行数据存储与操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是快速排序执行过程中常用的数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序在处理数据时通常借助线性表来完成排序",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "外部排序算法实现中，小根堆被广泛应用",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序过程依赖小根堆作为核心数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是外部排序中常用的数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "弗洛伊德算法运行时依赖链表结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法实现中采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表完成路径计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "冒泡排序在执行时会使用单链表",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "为实现冒泡排序，单链表是其依赖的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "冒泡排序算法借助单链表完成数据的比较与交换",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "归并排序算法依赖双端队列进行实现",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序借助双端队列来完成排序过程",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序在实现时会用到双端队列",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "快速排序算法使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是快速排序算法的数据结构选择",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序借助平衡二叉树实现高效排序",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "冒泡排序算法依赖斐波那契堆来完成排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "实现冒泡排序时，算法会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序在优化过程中采用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "Dijkstra算法在路径搜索中依赖后缀树的数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "为提升最短路径计算效率，Dijkstra算法借助后缀树",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "Dijkstra算法在处理大规模图时采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "后缀树"
    },
    {
      "sentence": "堆排序过程中，借助前缀树实现高效数据检索",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "为优化堆排序的存储效率，会选用前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法在处理特定数据时，会使用前缀树来构建索引",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "线性查找采用LFU缓存数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找算法实现基于LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找执行需使用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "哈希查找过程中，二叉堆常被用来存储数据",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为实现高效操作，哈希查找采用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找算法中常用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "冒泡排序实现时会用到后缀树数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序在实现中采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是冒泡排序使用的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "分支限界算法依赖双端队列来实现高效搜索",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界算法通过双端队列存储中间状态",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界算法采用双端队列优化搜索过程",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "二路归并排序过程中使用大根堆作为辅助结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并算法实现中会用到大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并借助大根堆来完成数据的高效处理",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "希尔排序算法借助哈希表作为核心数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序实现中使用哈希表存储关键数据",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序常以哈希表作为数据结构辅助实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "外部排序借助小根堆完成排序过程",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法采用小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序实现过程中利用小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "迪杰斯特拉算法在实现中使用二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆优化最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "折半查找算法依赖栈来完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "实现折半查找时会用到栈",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找借助栈来处理数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "堆排序算法采用前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法依赖前缀树来实现",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序借助前缀树完成排序操作",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "哈希查找的高效实现依赖平衡二叉树结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是哈希查找的关键数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找算法借助平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "回溯法实现时，常借助单链表存储中间状态",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "为高效处理分支，回溯法使用单链表管理节点信息",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "Dijkstra算法在实现中使用小根堆来优化操作",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "为高效求解最短路径，Dijkstra算法依赖小根堆",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是Dijkstra算法处理节点距离的关键工具",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "多路归并算法使用线性表来存储数据。",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表在多路归并中用于数据的存储。",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "多路归并借助线性表高效存储数据。",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "分治算法运用字典树作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法使用字典树作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法依托字典树作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "弗洛伊德算法采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法的实现基于链表数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "迪杰斯特拉算法采用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表实现路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "动态规划算法依赖小根堆来优化计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划借助小根堆实现高效的状态转移",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划采用小根堆作为关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "记忆化搜索的实现过程中采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索借助红黑树高效存储和检索关键数据",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索的算法优化依赖红黑树数据结构的支持",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "构建最小生成树时，算法会使用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在处理最小生成树问题中，后缀树被用作数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效计算最小生成树，算法采用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "迪杰斯特拉算法在实现中使用二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆优化最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "最小生成树算法在实现时采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树的算法实现借助红黑树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "构建最小生成树时需用到红黑树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "实现插入排序时，栈是常用的辅助数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序过程中，常借助栈来优化操作逻辑",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "为提升插入排序效率，栈被作为关键数据结构使用",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找实现时使用栈来存储数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中借助栈管理中间数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找算法中栈被用于暂存查找数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "动态规划算法依赖小根堆来优化计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划借助小根堆实现高效的状态转移",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划采用小根堆作为关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "广度优先搜索算法依赖堆来优化操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索借助堆实现高效处理",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索算法采用堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "Bellman-Ford算法使用队列来辅助操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法依赖队列实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法借助队列完成松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "弗洛伊德算法运行时依赖链表结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法实现中采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表完成路径计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "外部排序的实现过程中会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树为外部排序提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序借助字典树优化数据存储与检索",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "基数排序需要数组作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序依靠数组来实现排序",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序的实现依赖于数组结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "分治算法借助单链表来处理相关数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法依托单链表实现高效数据操作",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法以单链表作为数据处理的载体",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "穷举法在数据检索中常借助B+树",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是穷举法进行有序数据存储的常用结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法实现中，B+树被用作核心数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "直接插入排序算法使用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序借助循环队列来实现排序过程",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序以循环队列作为关键数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "在应用贪心策略时，算法使用了树状数组",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "贪心策略的实现过程中，会用到树状数组",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "为高效执行贪心策略，系统借助树状数组",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "深度优先搜索依赖可持久化数据结构来实现高效存储",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法采用可持久化数据结构进行状态管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为优化性能，深度优先搜索使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "插入排序实现中常借助二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序的堆操作依赖于二项堆结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "为优化性能，插入排序会使用二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "在计算单源最短路径时，系统借助LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "当处理单源最短路径问题时，系统依赖LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "桶排序在实现时会使用堆",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "当进行桶排序时，堆被该算法使用",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆是桶排序执行过程中用到的数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "动态规划算法常借助循环队列来优化状态存储",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "为提升效率，动态规划会选用循环队列处理数据",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划中，循环队列被用于高效管理中间状态",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "KMP算法采用B树作为核心数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法使用B树来存储关键数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法借助B树实现高效字符串匹配",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "克鲁斯卡尔算法实现中使用堆作为数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法处理边的关键数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法依赖堆高效管理边的权重",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "深度优先搜索在处理连通性问题时会使用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索算法在路径查找中会调用并查集数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为提升效率，深度优先搜索会借助并查集来管理节点",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "记忆化搜索实现中常使用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是记忆化搜索算法实现时的关键数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索在实现过程中会用到线段树这种数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "深度优先搜索借助并查集提升搜索效率",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索依靠并查集完成复杂操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索运用并查集优化数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "外部排序需要借助字典树数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序实现中采用字典树数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序在实现时使用字典树数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "为处理状态转移，算法采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移的计算中，线段树是算法使用的关键数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "当执行状态转移时，算法借助线段树来高效处理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "广度优先搜索算法依赖堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索算法以堆为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "广度优先搜索算法借助堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "回溯法在算法实现中会使用不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为提升数据管理效率，回溯法采用不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法借助不相交集合处理复杂数据结构问题",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "插值查找算法的实现需要用到生成森林",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "进行插值查找时，生成森林是其依赖的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是插值查找算法中常用的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "二路归并实现中，堆是核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆被用于二路归并算法的实现",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "选择排序实现过程中使用B树",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "B树被选择排序用于数据管理",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "执行选择排序时借助B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "为处理状态转移，算法采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移的计算中，线段树是算法使用的关键数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "当执行状态转移时，算法借助线段树来高效处理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "冒泡排序借助斐波那契堆实现高效排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序算法用于数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法依靠斐波那契堆优化操作性能",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "状态转移算法依赖树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移算法使用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法以树为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "冒泡排序过程中，会利用斐波那契堆进行数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化冒泡排序的效率，斐波那契堆被其选用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法在处理数据时，会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "迪杰斯特拉算法采用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表实现路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "克鲁斯卡尔算法实现时会使用B树",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是克鲁斯卡尔算法处理数据的重要工具",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化性能，克鲁斯卡尔算法依赖B树结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "广度优先搜索借助斐波那契堆数据结构实现高效遍历",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索在实现中采用斐波那契堆作为核心数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索算法依赖斐波那契堆来优化数据操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "弗洛伊德算法运行时依赖链表结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法实现中采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表完成路径计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "动态规划算法采用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划借助跳跃表优化数据操作",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划依赖跳跃表实现高效数据管理",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "记忆化搜索借助红黑树实现高效存储",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被记忆化搜索用于数据结构管理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索依赖红黑树优化数据存储结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索在实现时使用线段树数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索的算法实现中，线段树是其使用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "分治算法在处理字符匹配问题时会使用字典树",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是分治策略中常用的数据结构之一",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中常借助字典树提升数据检索效率",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "广度优先搜索算法会利用堆来优化搜索过程",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "为提升效率，广度优先搜索常借助堆进行数据管理",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "在广度优先搜索的实现中，堆作为数据结构被广泛应用",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "状态转移算法常借助队列进行数据管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "为实现状态转移，队列被用于数据暂存",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "队列是状态转移过程中常用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "插值查找算法使用生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找的实现借助生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找在运行中依靠生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "普里姆算法在实现时采用二叉树数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法借助二叉树数据结构来完成最小生成树的构建",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "基于二叉树数据结构，普里姆算法能高效计算最小生成树",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "在实现单源最短路径算法时，线性表常被用作数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法的优化过程中，线性表是常用的数据结构之一",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "为了高效计算单源最短路径，线性表作为基础数据结构被广泛应用",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "普里姆算法在构建最小生成树时依赖斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆是普里姆算法优化过程中常用的数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法通过斐波那契堆实现高效的顶点优先级更新",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是哈希查找算法的常用数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找算法在实现时使用平衡二叉树",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "回溯法实现中，单链表常用来存储中间状态",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决问题时，单链表作为辅助数据结构使用",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法路径探索时，单链表可高效存储回溯节点",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "构建最小生成树时，后缀树是常用的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "处理最小生成树问题，后缀树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法的实现依赖后缀树作为核心数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "单源最短路径算法使用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法借助优先队列实现高效计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是单源最短路径算法的关键数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "穷举法执行时，需使用数组存储待验证的数据。",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "为实现穷举法，数组是常用的数据结构支持。",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法在计算中，会借助数组来管理候选元素。",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "深度优先搜索算法依赖可持久化数据结构进行实现",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索在执行过程中使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索过程中需借助可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "桶排序实现中会使用堆作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "为优化排序效率，桶排序依赖堆结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序借助堆完成高效的排序操作",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "选择排序使用链表作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序借助链表完成排序操作",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序以链表实现数据的排序",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "桶排序实现时，使用红黑树存储数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "为高效存储数据，桶排序采用红黑树",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序借助红黑树完成数据存储",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "冒泡排序实现时需要单链表数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是冒泡排序使用的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "冒泡排序采用单链表实现排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "外部排序过程中，常借助小根堆来管理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆在外部排序中被用作数据处理工具",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆实现数据的高效管理",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "KMP算法借助B树来实现",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法采用B树作为数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法实现时会用到B树",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "快速排序算法使用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序以哈希表作为关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序实现时借助哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "在解决动态规划问题时，跳跃表常被用作高效的数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划算法实现中，跳跃表是提升性能的关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "设计动态规划方案时，跳跃表是常用的辅助数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "直接插入排序借助树状数组优化数据操作",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序依赖树状数组来实现高效排序",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序采用树状数组作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "计数排序算法依赖堆作为核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序借助堆结构完成排序操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序以堆为关键数据结构实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "插值查找算法的实现需要用到生成森林",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "进行插值查找时，生成森林是其依赖的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是插值查找算法中常用的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "归并排序的实现过程中，常依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为优化归并排序性能，可持久化数据结构被广泛应用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序算法在某些场景下会使用可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "穷举法中，数组用于存储待检查的元素",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "数组是穷举法实现过程中的关键数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "使用穷举法解决问题时，数组常被用来存储候选解",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序在执行过程中使用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为实现计数排序，系统采用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "处理状态转移问题时，线段树是高效的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移算法实现依赖线段树这一数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "实现状态转移过程中，线段树作为核心数据结构被使用",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "拓扑排序实现时采用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序借助大根堆优化节点排序效率",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序利用大根堆管理节点优先级",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并实现中，堆是核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆被用于二路归并算法的实现",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "外部排序过程中，常借助小根堆来管理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆在外部排序中被用作数据处理工具",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆实现数据的高效管理",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "希尔排序算法借助哈希表作为核心数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序实现中使用哈希表存储关键数据",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序常以哈希表作为数据结构辅助实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序实现中常使用双向链表结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表是希尔排序高效排序的关键数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序在排序过程中依赖双向链表的数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "KMP算法在实现时借助双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升匹配效率，KMP算法采用双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "KMP算法在操作中依赖双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "贪心策略的实现过程中，常借助平衡二叉树来高效处理数据",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的执行效率，平衡二叉树被广泛依赖",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在运行时，会利用平衡二叉树作为数据结构支持",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "堆排序算法实现中，常借助二叉搜索树进行辅助操作",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "在堆排序中，二叉搜索树作为数据结构被广泛应用",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序实现时依赖二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "快速排序过程中使用哈希表作为辅助结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序算法依赖哈希表来优化数据查找",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序采用哈希表作为关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "桶排序的实现采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序利用红黑树来管理数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序在实现中使用红黑树数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "冒泡排序实现时使用后缀树存储数据",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效处理数据，冒泡排序采用后缀树作为结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序过程中借助后缀树优化数据存储",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "桶排序算法借助红黑树实现",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是桶排序的基础数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序采用红黑树作为数据结构支撑",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "克鲁斯卡尔算法需要使用堆来实现",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法实现中的关键数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法借助堆来高效处理数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "在线性查找中，优先队列被用作存储待查数据的结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找算法使用优先队列来管理有序数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "为实现线性查找，优先队列作为数据结构被调用",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "插值查找算法使用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找以布隆过滤器作为其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "实现直接插入排序时，二叉堆是核心数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "直接插入排序算法使用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "直接插入排序过程中，二叉堆被用作数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "分块查找采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法使用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树实现数据查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "普里姆算法在实现时使用了二叉树",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "二叉树是普里姆算法的核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法运行依赖于二叉树结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "穷举法算法使用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法以二叉搜索树为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法运用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "Bellman-Ford算法采用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法以二项堆为关键数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法利用二项堆进行路径松弛",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "回溯法实现中会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法借助字典树解决问题",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法利用字典树提升效率",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "在基数排序过程中，会用到AC自动机",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "基数排序的实现依赖于AC自动机",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是基数排序使用的数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "插入排序在实现时会用到栈",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序借助栈来完成排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序的实现依赖于栈结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "记忆化搜索执行时会使用小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "为优化记忆化搜索，系统借助小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "记忆化搜索过程中常使用小根堆辅助",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "归并排序的实现过程中，常依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为优化归并排序性能，可持久化数据结构被广泛应用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序算法在某些场景下会使用可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "广度优先搜索算法会利用堆来优化搜索过程",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "为提升效率，广度优先搜索常借助堆进行数据管理",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "在广度优先搜索的实现中，堆作为数据结构被广泛应用",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "堆"
    },
    {
      "sentence": "选择排序算法使用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合是选择排序算法使用的关键数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序借助不相交集合来实现算法逻辑",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "线性查找的高效实现需要优先队列支持",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是线性查找的重要数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找过程中借助优先队列优化操作",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "回溯法实现复杂问题时借助不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法的高效求解常需要不相交集合的支持。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法在处理问题时会利用不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "迪杰斯特拉算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列完成最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法通过优先队列优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "回溯法实现过程中常依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是回溯法处理某些问题的常用数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决特定问题时会使用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法采用单链表来实现",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法借助单链表处理数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法以单链表作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法实现时依赖单链表",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治过程借助单链表完成任务",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法采用单链表处理数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "计数排序在实现中使用堆数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序借助堆数据结构完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序基于堆数据结构实现",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序的高效实现依赖大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是计数排序实现的重要数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序借助大根堆完成排序操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "直接插入排序算法使用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序借助循环队列来实现排序过程",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序以循环队列作为关键数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "选择排序算法采用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合被选择排序算法使用",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序在实现中使用不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "深度优先搜索在实现中使用LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索算法采用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存优化操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "记忆化搜索算法中常借助小根堆来优化",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是记忆化搜索实现中常用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "在记忆化搜索的执行中，小根堆用于维护关键状态",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法采用小根堆作为核心数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法在实现中依赖小根堆进行路径优化",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法依靠小根堆实现最短路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法依赖小根堆来优化路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法借助小根堆实现最短路径搜索",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法采用小根堆作为核心数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划算法在实现中依赖循环队列",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列来完成计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "实现动态规划常采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆来实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "为高效处理负权边，Bellman-Ford算法使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆被Bellman-Ford算法用于优化路径松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "多路归并算法实现中，二叉树作为核心数据结构被使用",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并处理数据时，二叉树是常用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并借助二叉树这种数据结构来高效运行",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "状态转移算法中，树常被用作数据结构。",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "为处理状态转移，树是常用的数据结构选择。",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移过程依赖树来存储相关信息。",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "贪心策略算法借助树状数组实现高效操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "贪心策略在算法中运用树状数组作为主要数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "为实现高效计算，贪心策略算法使用树状数组",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "分支限界算法使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界借助布隆过滤器提升效率",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器用于分支限界算法",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "在二路归并算法中，堆被用作关键数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆在二路归并中用于高效处理中间数据",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来实现数据的有序管理",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "单源最短路径算法采用LFU缓存数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径在计算中使用LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径的实现依靠LFU缓存数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并算法实现时使用大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并借助大根堆完成归并操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并过程中需使用大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "状态转移算法常使用树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "在状态转移算法中，树是常用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是实现状态转移算法的重要数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "Dijkstra算法依赖小根堆完成路径优化",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法以小根堆为核心数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "Dijkstra算法借助小根堆实现最短路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "小根堆"
    },
    {
      "sentence": "线性查找过程中，依赖LFU缓存存储数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "执行线性查找时，系统调用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找算法借助LFU缓存提升效率",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为了高效计算最短路径，迪杰斯特拉算法使用二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法在实现中依赖二叉堆优化路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法通过二叉堆管理节点优先级",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "折半查找算法依赖栈来完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "实现折半查找时会用到栈",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找借助栈来处理数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "在插入排序过程中，会利用栈来辅助操作。",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序中，栈常被用来暂存中间数据。",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序算法借助栈来完成元素的临时存储。",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "堆排序算法使用并查集作为关键数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序在排序过程中借助并查集作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序采用并查集作为数据结构的核心组件",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "回溯法实现中，单链表常用来存储中间状态",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决问题时，单链表作为辅助数据结构使用",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法路径探索时，单链表可高效存储回溯节点",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希查找借助二叉堆实现快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找的重要数据结构支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找通过二叉堆优化数据存储与检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "最小生成树算法的构建过程依赖后缀树的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树的某些应用场景借助后缀树来优化数据处理",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在实现最小生成树时，算法会利用后缀树来存储关键数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "哈希查找借助二叉堆实现快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找的重要数据结构支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找通过二叉堆优化数据存储与检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "在状态转移算法中，线段树被用作数据处理的工具",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移的实现依赖线段树来管理数据",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "处理状态转移时，线段树是关键的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "二路归并算法的实现依赖于堆的使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并借助堆来优化其操作效率",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并在处理过程中采用堆作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "弗洛伊德算法采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法的实现基于链表数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "计数排序算法实现中需使用生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序在排序过程中借助生成森林完成",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "为实现高效计数排序，需调用生成森林数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树来实现数据查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现高效查找，哈希查找借助平衡二叉树结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在实现中采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "迪杰斯特拉算法的实现依赖于优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "借助优先队列，迪杰斯特拉算法可高效计算最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "回溯法实现过程中常依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是回溯法处理某些问题的常用数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决特定问题时会使用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找借助平衡二叉树完成数据检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找通过平衡二叉树实现数据的快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "构建最小生成树时，后缀树是常用的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "处理最小生成树问题，后缀树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法的实现依赖后缀树作为核心数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序过程中，会利用斐波那契堆进行数据管理",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化冒泡排序的效率，斐波那契堆被其选用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序算法在处理数据时，会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序算法依赖斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序在实现时采用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序借助斐波那契堆完成关键步骤的处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "折半查找的实现依赖于线性表",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找所使用的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "在执行折半查找时，算法选用线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "外部排序过程中，会采用小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆被外部排序用来辅助排序操作",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法依赖小根堆来高效完成排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "Bellman-Ford算法在实现过程中会用到队列",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "在Bellman-Ford算法中，队列被用来优化路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法的实现依赖于队列的数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "单源最短路径算法借助线性表来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法在实现过程中使用线性表",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法采用线性表作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "插值查找的性能优化依赖于二项堆的辅助",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找借助二项堆来提升查找效率",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "在实现插值查找时，二项堆是其关键数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "状态转移算法实现中常依赖队列结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移过程中采用队列来管理状态",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "借助队列结构优化状态转移的处理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "堆排序实现中运用了前缀树数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序过程中会用到前缀树数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法采用前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "KMP算法采用优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法使用优先队列作为关键数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法以优先队列作为数据结构支撑",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略的实现常依赖于优先队列数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略算法中会使用优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略在算法设计时借助优先队列来高效运行",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "二路归并算法在运行时会使用堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "为执行二路归并，堆被算法所使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并过程中依赖堆作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "为了高效执行普里姆算法，系统采用了斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法实现过程中依赖斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法借助斐波那契堆优化操作",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "克鲁斯卡尔算法实现时依赖布隆过滤器",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法借助布隆过滤器提升效率",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法利用布隆过滤器优化处理",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "动态规划算法借助小根堆来提升效率",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "为优化动态规划过程，算法会使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划在某些场景下需要使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "桶排序算法采用B树作为核心数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序使用B树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序借助B树组织数据",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "Dijkstra算法在实现中使用大根堆数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法借助大根堆优化路径计算过程",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆被Dijkstra算法用于最短路径求解",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "为执行计数排序，系统采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中使用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "执行计数排序时，生成森林是其使用的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序在执行过程中依赖生成森林的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序实现时的关键数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序利用生成森林来优化排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "Bellman-Ford算法的实现依赖于二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆常被Bellman-Ford算法用作数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法在路径计算中使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "状态转移算法常使用树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "在状态转移算法中，树是常用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是实现状态转移算法的重要数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "实现基数排序时，线性表是核心数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序依赖线性表作为数据结构存储元素",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表被基数排序用作数据结构来处理数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "弗洛伊德算法采用链表作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法借助链表来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "弗洛伊德算法的实现基于链表数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "链表"
    },
    {
      "sentence": "最小生成树算法的构建过程依赖后缀树的数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树的某些应用场景借助后缀树来优化数据处理",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在实现最小生成树时，算法会利用后缀树来存储关键数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "插值查找算法使用生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找的实现借助生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找在运行中依靠生成森林数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "深度优先搜索算法在实现过程中会使用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为高效处理数据，深度优先搜索会运用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集常被深度优先搜索算法用于辅助数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "线性查找的实现采用优先队列数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找借助优先队列数据结构完成查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找基于优先队列数据结构实现查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "堆排序算法使用并查集作为关键数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序在排序过程中借助并查集作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序采用并查集作为数据结构的核心组件",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "哈希查找使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是哈希查找所使用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在算法中采用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "回溯法实现过程中常依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是回溯法处理某些问题的常用数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决特定问题时会使用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "堆排序实现需借助并查集作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是堆排序实现时采用的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序算法中会使用并查集这一数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "分治算法实现时会使用字典树作为数据结构。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中依赖字典树来完成算法步骤。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法为高效实施会使用字典树。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "堆排序在实现时会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序算法的实现过程中依赖二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序实现过程中会采用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "记忆化搜索在处理复杂问题时，会使用线段树来存储中间结果",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "为优化计算效率，记忆化搜索算法会借助线段树这一数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "实现记忆化搜索时，线段树常被用作其数据管理的核心结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "希尔排序在实现过程中采用双向链表作为数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表被希尔排序算法用来存储和处理数据",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序算法的实现依赖于双向链表的数据结构支持",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "在分治算法中，单链表常被用作数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治过程中，单链表作为基础数据结构被广泛应用",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表在分治算法实现中发挥着关键作用",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "折半查找算法借助栈来实现",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找算法依赖栈完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找在实现中使用栈",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "动态规划的实现需要循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划算法常借助循环队列数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划实现中会用到循环队列数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "快速排序算法在实现时，依赖于线性表",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序在排序过程中，借助线性表来存储数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "为了高效排序，快速排序采用线性表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "堆排序算法在实现时，会使用前缀树作为辅助结构。",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "在进行堆排序操作时，系统依赖前缀树来优化处理。",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序的实现过程中，会用到前缀树来完成特定操作。",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "穷举法的实现过程中使用了二叉搜索树数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为提升效率，穷举法借助二叉搜索树进行数据处理",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法在某些算法实现里依赖二叉搜索树结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "Bellman-Ford算法采用B树作为数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法以B树作为数据管理结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法借助B树实现数据处理",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "外部排序借助字典树来存储待排序数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树被外部排序采用以优化数据存储",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序过程中利用字典树管理数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "广度优先搜索算法使用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索借助大根堆来实现高效搜索",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索在算法中依托大根堆进行操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "普里姆算法采用斐波那契堆作为关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法借助斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法以斐波那契堆为核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "Bellman-Ford算法采用队列作为核心数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法使用队列辅助松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法依靠队列实现迭代处理",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "希尔排序实现时会使用哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序借助哈希表完成排序",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序采用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "单源最短路径算法实现中使用LFU缓存存储数据",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法借助LFU缓存优化数据存储",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是单源最短路径算法中使用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "普里姆算法借助二叉树来实现",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法实现时会用到二叉树",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法依靠二叉树完成操作",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "直接插入排序算法采用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "直接插入排序过程中会用到二叉堆辅助排序",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "直接插入排序借助二叉堆提升数据处理效率",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "二叉堆"
    },
    {
      "sentence": "Bellman-Ford算法采用B树作为数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法以B树作为数据管理结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法借助B树实现数据处理",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为优化动态规划，系统采用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划处理问题时，常借助小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划实施过程中，会使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "广度优先搜索算法使用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索借助大根堆来实现高效搜索",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索在算法中依托大根堆进行操作",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "构建动态规划算法时，常使用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划在优化问题中借助跳跃表来存储数据",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为提升动态规划的效率，跳跃表被用作其数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "快速排序算法借助平衡二叉树来优化数据存储",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效实现快速排序，平衡二叉树被用作其数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是快速排序算法中常用的数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "选择排序过程中，B树常被用作数据存储结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "在选择排序算法的实现里，B树是关键数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序算法使用B树来管理数据",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "冒泡排序算法依赖斐波那契堆来完成排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "实现冒泡排序时，算法会借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序在优化过程中采用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "插值查找利用布隆过滤器进行数据查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器实现快速查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器被插值查找算法用作数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "外部排序算法采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序借助线段树来处理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序利用线段树完成排序任务",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "多路归并过程中使用后缀树来优化数据存储",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效实现多路归并，后缀树被用作其核心数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "多路归并的实现依赖于后缀树这一数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "线性查找算法会用到二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找为了高效，会用二叉堆管理数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是线性查找算法中使用的数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "桶排序在实现时会使用堆",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "当进行桶排序时，堆被该算法使用",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆是桶排序执行过程中用到的数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "希尔排序实现中会用到哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表是希尔排序的重要数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序借助哈希表优化操作效率",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "折半查找算法在优化过程中会使用生成森林",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是折半查找实现所需的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找在构建索引时依赖生成森林",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "贪心策略的算法实现中，常借助平衡二叉树进行高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的效率，平衡二叉树是其常用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在实现贪心策略时，平衡二叉树被用作关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "Dijkstra算法在路径搜索中依赖大根堆。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法利用大根堆来高效处理节点。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法借助大根堆优化最短路径计算。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆来实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "为高效处理负权边，Bellman-Ford算法使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆被Bellman-Ford算法用于优化路径松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "外部排序借助字典树来存储待排序数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树被外部排序采用以优化数据存储",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序过程中利用字典树管理数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构来完成计算",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "实现弗洛伊德算法时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法的实现过程中使用了可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存来实现高效操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索算法用作数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在算法实现中使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "执行冒泡排序时，系统借助后缀树",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序运行需使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "实现冒泡排序过程中，后缀树被系统使用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "分支限界算法借助双端队列进行数据管理",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列在分支限界算法中被用来优化搜索过程",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界求解中，双端队列用于高效存储待处理节点",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序采用双端队列作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序借助双端队列来实现排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序在实现中使用双端队列",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "外部排序的实现依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树被外部排序算法用于高效处理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "为实现外部排序，字典树常被用作数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "插值查找算法依赖二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找借助二项堆来实现数据操作",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找采用二项堆作为核心数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "基数排序执行时使用数组作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "为实现基数排序，系统会采用数组",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序在操作中依赖数组存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "希尔排序算法在实现过程中使用了双向链表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "实现希尔排序时，会用到双向链表作为数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序在排序过程中借助双向链表来完成操作",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "记忆化搜索在算法中常使用小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "记忆化搜索过程中会用到小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "为优化效率，记忆化搜索会借助小根堆",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "小根堆"
    },
    {
      "sentence": "选择排序在实现中使用B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序的算法实现采用B树数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序借助B树数据结构完成排序操作",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "快速排序算法在实现中利用了哈希表",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序执行时使用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序借助哈希表实现高效操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "分块查找算法依赖红黑树完成实现",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被分块查找算法用作数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找实现过程中运用红黑树",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "多路归并算法使用二叉树来高效存储数据",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并过程中，二叉树是其数据结构选择",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "为实现多路归并，二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "回溯法在求解过程中使用不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为执行回溯法，系统借助不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法的实现依赖于不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "插值查找算法使用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找以布隆过滤器作为其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列以优化路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法通过优先队列实现最短路径求解",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "回溯法在求解过程中使用不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为执行回溯法，系统借助不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法的实现依赖于不相交集合",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "折半查找的实现依赖于线性表",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找所使用的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "在执行折半查找时，算法选用线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "在进行穷举法搜索时，B+树提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法的实现过程中，常借助B+树来组织数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "为优化穷举法的效率，B+树作为核心数据结构被采用",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "基数排序算法依赖数组来存储数据",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组实现排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序以数组作为基础数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是回溯法常用的数据结构之一（注：此处原句可能有歧义，已调整为更准确的“回溯法在其算法设计中运用字典树作为数据结构”，确保明确回溯法使用字典树）",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "在状态转移算法中，线段树被用作数据处理的工具",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移的实现依赖线段树来管理数据",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "处理状态转移时，线段树是关键的数据结构选择",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "快速排序算法借助平衡二叉树来优化数据存储",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效实现快速排序，平衡二叉树被用作其数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是快速排序算法中常用的数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "折半查找实现依赖栈数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找借助栈完成操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找实现需使用栈数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "堆排序过程中，借助前缀树实现高效数据检索",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "为优化堆排序的存储效率，会选用前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法在处理特定数据时，会使用前缀树来构建索引",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "记忆化搜索借助线段树提升数据处理效率",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索利用线段树优化数据管理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索在实现中使用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "基数排序算法依赖线性表来完成排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序借助线性表实现其排序功能",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序的实现需使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "冒泡排序采用斐波那契堆数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序实现中使用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序用作算法数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "分块查找采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法使用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树实现数据查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找算法依赖平衡二叉树来实现数据查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现高效查找，哈希查找借助平衡二叉树结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在实现中采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "堆排序算法中，会借助并查集来管理数据",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集被堆排序用于优化某些操作",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序过程中，常使用并查集来处理集合问题",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "线性查找过程中，优先队列常被用作数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "为优化线性查找效率，优先队列是其常用数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找算法的实现中，优先队列作为数据结构被使用",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "穷举法借助数组来存储数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法采用数组作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法在实现时需用到数组",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "普里姆算法使用树作为核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "树是普里姆算法处理最小生成树的关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法在实现过程中依赖树这种数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "穷举法实现中常使用数组",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法借助数组完成数据存储",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "数组是穷举法常用的数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序在排序过程中使用数组存储元素",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序依赖数组来完成排序操作",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序借助数组实现高效排序",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "选择排序的实现采用链表作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序在处理数据时需要链表结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序借助链表数据结构来完成排序",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "基数排序通常以数组作为数据存储结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序在处理数据时依赖数组结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序通过数组实现排序逻辑",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "动态规划算法常借助循环队列来优化存储",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列是动态规划中常用的数据结构之一",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划在处理问题时会使用循环队列辅助计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "插入排序算法借助二项堆实现高效的数据管理",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序在实现时，选择二项堆作为数据存储结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "在插入排序过程中，二项堆被用来辅助数据的插入操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "动态规划解决最短路径问题常使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划借助小根堆高效处理状态转移",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是动态规划处理复杂问题的关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "线性查找算法在操作时使用二叉堆",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找需要借助二叉堆来实现",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为执行线性查找，系统会使用二叉堆",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "弗洛伊德算法采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法依赖可持久化数据结构运行",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构实现功能",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "Bellman-Ford算法在处理负权边时依赖队列",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法在迭代过程中采用队列来优化",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "队列是Bellman-Ford算法实现中常用的数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "贪心策略的高效实现依赖平衡二叉树的数据结构支持",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在决策优化过程中使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现贪心策略的快速查找，平衡二叉树是其关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "折半查找采用生成森林数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找过程使用生成森林数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找实现依赖生成森林数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "希尔排序的实现需要双向链表数据结构支持",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序采用双向链表作为数据结构来实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序借助双向链表数据结构来实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "在实现最小生成树时，算法使用了字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树算法在运行时会用到字典树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "为计算最小生成树，字典树被算法使用",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "Dijkstra算法借助大根堆实现最短路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法在实现中依赖大根堆",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法通过大根堆来高效更新路径",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "贪心策略的算法实现中，平衡二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在执行贪心策略时，系统借助平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效执行贪心策略，平衡二叉树是其选用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "深度优先搜索依赖可持久化数据结构来实现高效存储",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法采用可持久化数据结构进行状态管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为优化性能，深度优先搜索使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "外部排序在实现中使用小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆完成数据排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法采用小根堆来优化排序过程",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "哈希查找算法在优化时依赖不相交集合的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "实现哈希查找的高效版本需借助不相交集合",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找在某些应用中会使用不相交集合来提升效率",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "外部排序在实现中使用小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆完成数据排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法采用小根堆来优化排序过程",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "二路归并排序过程中使用大根堆作为辅助结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并算法实现中会用到大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并借助大根堆来完成数据的高效处理",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "选择排序的实现采用链表作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序在处理数据时需要链表结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序借助链表数据结构来完成排序",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "穷举法借助数组来存储数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法采用数组作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "穷举法在实现时需用到数组",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "数组"
    },
    {
      "sentence": "实现拓扑排序时，循环链表用于存储节点关系",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中，循环链表是常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "构建拓扑排序时，循环链表被用来辅助存储操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "深度优先搜索借助并查集提升搜索效率",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索依靠并查集完成复杂操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索运用并查集优化数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "单源最短路径算法实现中使用LFU缓存存储数据",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法借助LFU缓存优化数据存储",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存是单源最短路径算法中使用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存来实现高效操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索算法用作数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在算法实现中使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "实现二路归并时，LFU缓存是核心数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并过程中采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存常用于二路归并的实现",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "Bellman-Ford算法在处理大规模数据时使用B树",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树被Bellman-Ford算法用于优化路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为提升性能，Bellman-Ford算法采用B树作为辅助结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "线性查找算法依赖二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找以二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找利用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "归并排序过程中会借助双端队列高效处理数据",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列被归并排序用于优化数据存取操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序采用双端队列辅助数据处理流程",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "直接插入排序算法采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序在排序过程中使用循环队列",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列被直接插入排序用于数据处理",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "希尔排序的实现需要双向链表数据结构支持",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序采用双向链表作为数据结构来实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序借助双向链表数据结构来实现",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "回溯法实现过程中常依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是回溯法处理某些问题的常用数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法解决特定问题时会使用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆来实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "为高效处理负权边，Bellman-Ford算法使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆被Bellman-Ford算法用于优化路径松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "多路归并算法依赖二叉树来实现",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并算法采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并算法借助二叉树完成归并操作",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "二路归并算法依赖堆来完成操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "实现二路归并时会用到堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "堆是二路归并算法的关键数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "分支限界算法在搜索过程中利用栈来存储状态",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界借助栈来管理待探索的节点",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界算法中，栈被用于暂存中间结果",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "快速排序实现中常使用哈希表作为辅助结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表是快速排序实现高效操作的常用数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "在快速排序的执行过程中，哈希表被用来提升数据查找效率",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "多路归并算法采用二叉树作为其内部数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "在多路归并的实现中，二叉树常被用作关键数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "二叉树是多路归并算法中常用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法借助二叉树优化最小生成树构建",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法通过二叉树结构高效存储待选边信息",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法处理图时依赖二叉树管理节点",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "拓扑排序算法使用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中会用到循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表被拓扑排序算法所使用",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "Bellman-Ford算法借助B树来处理数据",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是Bellman-Ford算法使用的数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法运行时依赖B树存储数据",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "折半查找依赖生成森林实现高效查找",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找借助生成森林完成查找任务",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "记忆化搜索算法使用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索借助线段树优化计算过程",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索通过线段树实现高效处理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "插值查找过程中，会利用布隆过滤器进行数据存储",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "在插值查找算法中，布隆过滤器被用来辅助数据的快速检索",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助布隆过滤器来实现对数据集合的高效判断",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "直接插入排序算法使用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序借助循环队列来实现排序过程",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序以循环队列作为关键数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "深度优先搜索的实现过程中，常使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法在处理复杂场景时，会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构在深度优先搜索中发挥着关键作用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "多路归并算法依赖二叉树来实现",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并算法采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并算法借助二叉树完成归并操作",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "在进行穷举法搜索时，B+树提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法的实现过程中，常借助B+树来组织数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "为优化穷举法的效率，B+树作为核心数据结构被采用",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "插入排序算法实现时使用栈数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序借助栈来完成部分操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "实现插入排序需要依靠栈数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "状态转移算法采用树数据结构进行状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树结构被状态转移算法用于处理状态变化",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移过程中运用树作为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "插入排序实现中常借助二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序的堆操作依赖于二项堆结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "为优化性能，插入排序会使用二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找利用布隆过滤器进行数据查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器实现快速查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器被插值查找算法用作数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "折半查找算法依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找以线性表为核心数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找实现中使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "插入排序实现中常借助二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序的堆操作依赖于二项堆结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "为优化性能，插入排序会使用二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "最小生成树算法使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法依赖后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "最小生成树算法利用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "弗洛伊德算法采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法依赖可持久化数据结构运行",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构实现功能",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存优化操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法采用LFU缓存管理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索利用LFU缓存存储中间结果",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "堆排序算法在实现过程中会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为了高效排序，堆排序借助二叉搜索树进行数据处理",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树被堆排序算法用于存储中间数据",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法在执行过程中会用到B+树来存储数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "为了高效处理数据，穷举法会使用B+树",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法借助B+树来组织数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "堆排序在实现过程中使用二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树是堆排序所依赖的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序算法实现时会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "动态规划算法在实现中依赖循环队列",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列来完成计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "实现动态规划常采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "插入排序采用双端队列作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序借助双端队列来实现排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序在实现中使用双端队列",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "深度优先搜索在运行时会用到LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为优化深度优先搜索性能，LFU缓存被其采用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法实现中，LFU缓存作为数据结构被使用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "归并排序在实现中依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构被归并排序算法所使用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序算法借助可持久化数据结构提升性能",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "普里姆算法的实现依赖于树结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法借助树来完成计算",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "在普里姆算法中，树是其关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "选择排序在数据存储时依赖B树结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序算法实现中会用到B树",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "为优化性能，选择排序采用B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "迪杰斯特拉算法在实现中常使用循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表是迪杰斯特拉算法的重要数据结构支撑",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "为优化路径搜索，迪杰斯特拉算法依赖循环链表",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "分治算法在实现过程中使用了栈",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治在解决问题时会用到栈",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治算法执行时依赖栈这种数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "最小生成树算法在实现过程中会使用后缀树来处理特定数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "为了高效处理问题，最小生成树会采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在解决相关问题时，最小生成树借助后缀树来组织数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆高效维护顶点距离",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为提升效率，迪杰斯特拉算法采用二叉堆存储顶点信息",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法利用二叉堆实现优先队列功能",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "回溯法通过不相交集合实现高效操作",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法依赖不相交集合来优化算法效率",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合是回溯法使用的数据结构之一",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "分支限界算法借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界算法选用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界算法运用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "实现单源最短路径时，LFU缓存是必要的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法需要LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径求解过程中会用到LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "插值查找算法在实现中采用了布隆过滤器",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助布隆过滤器来优化数据查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找过程中依赖布隆过滤器进行数据验证",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "选择排序实现时使用不相交集合数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序借助不相交集合数据结构进行排序",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序的实现离不开不相交集合数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "分块查找算法在实现中使用双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为执行分块查找，系统采用双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找借助双端队列提升查找效率",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "外部排序的实现采用线段树数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "外部排序过程中借助线段树数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树是外部排序使用的数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "在实现单源最短路径算法时，线性表常被用作数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法的优化过程中，线性表是常用的数据结构之一",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "为了高效计算单源最短路径，线性表作为基础数据结构被广泛应用",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "KMP算法采用B树作为核心数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法使用B树来存储关键数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法借助B树实现高效字符串匹配",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "最小生成树算法采用字典树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树的实现依赖于字典树数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树在算法设计中需要字典树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法实现时会使用字典树作为数据结构。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中依赖字典树来完成算法步骤。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法为高效实施会使用字典树。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分支限界算法依赖布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界在操作中借助布隆过滤器处理数据",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "为实现高效数据管理，分支限界使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法依赖二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找借助二项堆来实现数据操作",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找采用二项堆作为核心数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "桶排序过程中，堆用来高效处理桶内元素排序",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现桶排序时，堆是常用的辅助排序结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序算法中，堆被用于优化部分数据的排序效率",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "线性查找算法实现时需使用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为高效查找，线性查找会借助LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找实现过程中依赖LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "Dijkstra算法借助大根堆完成路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法实现时依赖大根堆数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法通过大根堆提升路径查找效率",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "桶排序实现中会使用堆作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "为优化排序效率，桶排序依赖堆结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序借助堆完成高效的排序操作",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序使用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序采用生成森林实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序借助生成森林完成操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "在分块查找算法中，双端队列被用作存储待处理数据的结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找过程中，双端队列常用来暂存中间数据以优化效率",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升分块查找性能，双端队列是其关键数据结构之一",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "拓扑排序在实现时会用到循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "在拓扑排序算法中，循环链表被用作数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中，循环链表是其使用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "深度优先搜索依赖可持久化数据结构来实现高效存储",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "深度优先搜索算法采用可持久化数据结构进行状态管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为优化性能，深度优先搜索使用可持久化数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "构建记忆化搜索算法，常依赖红黑树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "在记忆化搜索中，红黑树被用于存储和查询数据",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索的高效实现，离不开红黑树的支持",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "在记忆化搜索中，线段树常作为高效的数据结构被使用",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索算法在处理复杂问题时，会用到线段树优化数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "为增强记忆化搜索的性能，线段树是其常用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "插入排序采用双端队列作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序依赖双端队列来实现排序操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序在实现中使用双端队列完成排序",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "克鲁斯卡尔算法在执行过程中会使用堆",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法实现时依赖的数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "为高效完成克鲁斯卡尔算法，堆被算法用来管理数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "在某些广度优先搜索的优化实现中，会用到大根堆来提升效率",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索算法中，大根堆常被用来优化路径选择",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "当广度优先搜索需要处理优先级任务时，大根堆能有效辅助其执行",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "大根堆"
    },
    {
      "sentence": "KMP算法在实现中使用B树",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法依赖B树进行数据处理",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是KMP算法使用的数据结构之一",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "计数排序过程中，会用到堆作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆是计数排序算法中使用的数据结构之一",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序算法在实现时，会使用堆来辅助排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "分块查找依赖红黑树来维护有序结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找实现时需利用红黑树",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找借助红黑树实现高效数据管理",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "在解决问题时，回溯法会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法在搜索过程中会用到字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法的实现过程中，会借助字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "为了执行最小生成树，算法采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "实现最小生成树时，系统借助红黑树进行高效操作",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "构建最小生成树的过程中，红黑树被用作关键数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "计数排序借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序采用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序依赖大根堆实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "插入排序借助二项堆来实现高效操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序算法采用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序在实现时使用二项堆作为辅助结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "折半查找算法使用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找算法依赖生成森林作为核心数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找算法以生成森林为其使用的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "Bellman-Ford算法在迭代中使用队列来管理节点",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "队列是Bellman-Ford算法处理路径松弛的重要数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "实现Bellman-Ford算法时借助队列优化节点操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "基数排序实现过程中，AC自动机作为数据结构被使用",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是基数排序算法所使用的数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "基数排序算法中，AC自动机被用作数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "动态规划实现中，循环队列是关键的数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列在动态规划算法中发挥重要作用",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列优化状态管理",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "迪杰斯特拉算法以二叉堆为核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法依靠二叉堆优化路径查找",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆处理节点优先级",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "插值查找算法需要使用生成森林",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找借助生成森林来实现查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "插值查找采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "线性查找依赖优先队列实现",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找采用优先队列完成查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找使用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "冒泡排序在实现中依赖后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序以后缀树作为其数据结构支撑",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序借助后缀树来实现其算法逻辑",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "线性查找算法以LFU缓存为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找借助LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找依赖LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "在线性查找中，优先队列被用作存储待查数据的结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找算法使用优先队列来管理有序数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "为实现线性查找，优先队列作为数据结构被调用",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "插值查找的实现需要布隆过滤器数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器是插值查找使用的数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "基数排序在执行过程中依赖线性表结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序算法实现时使用线性表作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "基数排序的操作过程中会用到线性表",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "线性表"
    },
    {
      "sentence": "分治算法实现时会使用字典树作为数据结构。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中依赖字典树来完成算法步骤。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法为高效实施会使用字典树。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "线性查找采用LFU缓存数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找算法实现基于LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找执行需使用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "冒泡排序算法依赖后缀树完成排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序借助后缀树实现高效排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序实现过程中使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "构建动态规划算法时，常使用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划在优化问题中借助跳跃表来存储数据",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为提升动态规划的效率，跳跃表被用作其数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "外部排序过程中，系统使用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "为执行外部排序，算法采用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树被外部排序算法使用。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "迪杰斯特拉算法采用优先队列来优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "迪杰斯特拉算法依赖优先队列高效寻找最短路径",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "通过优先队列，迪杰斯特拉算法实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "计数排序的核心步骤中会用到堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序优化排序效率时依赖堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆数据结构被计数排序用于优化排序效率",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "分支限界算法借助栈来实现",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界的实现依赖于栈结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界通过栈来完成操作",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "直接插入排序算法中，循环队列用于存储中间数据",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "为实现直接插入排序，循环队列被用作数据存储结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序过程中，循环队列辅助存储待排序数据",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "归并排序算法在实现过程中会用到跳跃表",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为提升归并排序的效率，跳跃表常被用作其辅助数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在处理有序数据时，会借助跳跃表实现快速查找",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "拓扑排序实现中会用到大根堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序的算法过程使用大根堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序采用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索算法在实现时会使用斐波那契堆",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索借助斐波那契堆来优化性能",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为提升效率，广度优先搜索采用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "单源最短路径算法使用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法借助优先队列实现高效计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是单源最短路径算法的关键数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "在分块查找算法中，双端队列被用作存储待处理数据的结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找过程中，双端队列常用来暂存中间数据以优化效率",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升分块查找性能，双端队列是其关键数据结构之一",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "回溯法在实现时会用到单链表",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法算法执行中依赖单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表被回溯法用于存储中间状态",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "记忆化搜索算法使用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索借助线段树优化计算过程",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索通过线段树实现高效处理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "直接插入排序过程中，会使用树状数组存储中间数据",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "为优化直接插入排序的性能，常采用树状数组作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "直接插入排序算法借助树状数组实现高效数据管理",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "树状数组"
    },
    {
      "sentence": "贪心策略算法借助树状数组实现高效操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "贪心策略利用树状数组来优化计算过程",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "贪心策略算法以树状数组作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "树状数组"
    },
    {
      "sentence": "深度优先搜索算法中，常采用并查集辅助实现",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索在某些场景下会使用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为优化深度优先搜索，会借助并查集数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "单源最短路径算法在计算中使用线性表",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "为了完成单源最短路径，线性表被算法采用",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表作为数据结构，支持单源最短路径算法",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "回溯法借助字典树来高效存储和检索数据",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法在搜索过程中使用字典树优化路径选择",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "处理前缀匹配问题时，回溯法会采用字典树存储字符信息",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "冒泡排序的实现过程中，会用到斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "在冒泡排序算法中，斐波那契堆作为数据结构被使用",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为了优化冒泡排序，斐波那契堆常被用作数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "弗洛伊德算法的实现依赖大根堆这一数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法在计算中借助大根堆来优化过程",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "为提升效率，弗洛伊德算法采用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "分块查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树优化数据检索过程",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找采用平衡二叉树作为核心数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "回溯法利用单链表作为数据结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法采用单链表存储中间结果",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法通过单链表实现递归回溯",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "插入排序算法使用双端队列来处理数据",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "在插入排序中，双端队列被用来优化数据插入过程",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序过程中，双端队列作为数据结构被广泛应用",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "普里姆算法采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法借助二叉树完成运算",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法以二叉树为核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "动态规划算法使用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列实现算法的数据结构需求",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划以循环队列作为核心数据结构支撑",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "记忆化搜索采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索在实现时使用线段树数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索的算法实现中，线段树是其使用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "动态规划实现中，循环队列是关键的数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列在动态规划算法中发挥重要作用",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列优化状态管理",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "贪心策略的实现过程中，常借助平衡二叉树来高效处理数据",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的执行效率，平衡二叉树被广泛依赖",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在运行时，会利用平衡二叉树作为数据结构支持",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "普里姆算法的实现依赖于树结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法借助树来完成计算",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "在普里姆算法中，树是其关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "构建最小生成树时，算法会使用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在处理最小生成树问题中，后缀树被用作数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效计算最小生成树，算法采用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序采用斐波那契堆数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序实现中使用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆被冒泡排序用作算法数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "KMP算法在实现时借助双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升匹配效率，KMP算法采用双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "KMP算法在操作中依赖双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "选择排序过程中采用B树来存储数据",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序借助B树实现数据的高效存储",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "为优化数据操作，选择排序使用B树结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "拓扑排序过程中，常借助大根堆进行数据处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为高效实现拓扑排序，大根堆被用于数据管理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序算法中，大根堆用于维护待处理数据",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "回溯法实现复杂问题时借助不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法的高效求解常需要不相交集合的支持。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "回溯法在处理问题时会利用不相交集合作为数据结构。",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "不相交集合"
    },
    {
      "sentence": "迪杰斯特拉算法在实现中使用二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆优化最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "动态规划算法使用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列实现算法的数据结构需求",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划以循环队列作为核心数据结构支撑",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "归并排序实现依赖跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是归并排序提升性能的常用数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在优化中常使用跳跃表辅助操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "拓扑排序借助斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序的高效实现依赖于斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆是拓扑排序中常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "迪杰斯特拉算法在路径计算中依赖二叉堆",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆实现高效路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法使用二叉堆作为关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "外部排序过程中，常借助小根堆来管理数据",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆在外部排序中被用作数据处理工具",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序借助小根堆实现数据的高效管理",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "深度优先搜索借助并查集提升搜索效率",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索依靠并查集完成复杂操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索运用并查集优化数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "拓扑排序算法使用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序依赖斐波那契堆来实现其功能",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序借助斐波那契堆以高效执行操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "桶排序算法依赖堆作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序借助堆来完成排序过程",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "桶排序的实现中使用堆数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "深度优先搜索优化时会采用LFU缓存结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法在运行时使用LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为提升性能，深度优先搜索使用LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "折半查找算法依赖线性表来完成查找",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找采用线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找在实现过程中需要线性表",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序过程中，线性表被用于数据的存储与操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "为实现快速排序，线性表常作为数据的存储载体",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序算法中，线性表用于组织和管理待排序数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "计数排序算法中使用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中，生成森林被用于存储数据",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "生成森林是计数排序实现所需的数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "希尔排序的实现依赖线性表来存储数据",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "在希尔排序算法中，线性表被用作数据存储结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "为实现希尔排序，常以线性表作为数据载体",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "KMP算法在模式匹配过程中使用B树存储关键数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树作为数据结构被KMP算法所采用",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法借助B树优化数据检索与存储效率",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "外部排序算法使用小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序依靠小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法以小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "插值查找在实现中使用布隆过滤器",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器是插值查找的关键数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "为优化性能，插值查找采用布隆过滤器",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "折半查找算法在实现时借助了栈结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中会用到栈来辅助操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "为高效完成折半查找，系统依赖栈结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "堆排序算法以前缀树作为关键数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序在实现中依赖前缀树作为数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "堆排序算法使用前缀树作为主要数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "前缀树"
    },
    {
      "sentence": "贪心策略实现算法需要平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略借助平衡二叉树数据结构来实现",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在算法中使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "穷举法在搜索过程中使用B+树数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树被穷举法用于算法实现",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法的算法设计需借助B+树结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "在希尔排序中，我们借助双向链表实现数据的高效排序",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序的实现过程中，会采用双向链表来处理元素顺序",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "为提升排序效率，希尔排序使用双向链表来存储中间数据",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "克鲁斯卡尔算法使用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器被克鲁斯卡尔算法用作数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法借助布隆过滤器优化数据处理",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "多路归并算法采用二叉树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "二叉树是多路归并算法使用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "多路归并实现中依赖二叉树数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "二叉树"
    },
    {
      "sentence": "希尔排序实现中常使用双向链表结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "双向链表是希尔排序高效排序的关键数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "希尔排序在排序过程中依赖双向链表的数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "双向链表"
    },
    {
      "sentence": "深度优先搜索借助并查集提升搜索效率",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索依靠并查集完成复杂操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索运用并查集优化数据管理",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "状态转移算法采用队列作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法借助队列实现状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "状态转移算法通过队列处理状态转换",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "队列"
    },
    {
      "sentence": "快速排序过程中，线性表被用于数据的存储与操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "为实现快速排序，线性表常作为数据的存储载体",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序算法中，线性表用于组织和管理待排序数据",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "拓扑排序过程中，常借助大根堆进行数据处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为高效实现拓扑排序，大根堆被用于数据管理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "拓扑排序算法中，大根堆用于维护待处理数据",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "快速排序算法使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是快速排序算法的数据结构选择",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序借助平衡二叉树实现高效排序",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分支限界算法在求解过程中依赖于栈",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界算法中，栈是其常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "实现分支限界时，栈被算法所采用",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "Dijkstra算法借助大根堆完成路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法实现时依赖大根堆数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法通过大根堆提升路径查找效率",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "外部排序过程中，系统使用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "为执行外部排序，算法采用线段树。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "线段树被外部排序算法使用。",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "线段树"
    },
    {
      "sentence": "折半查找算法实现中，线性表是常用的数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "为了高效执行折半查找，通常需要线性表支持",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找能够高效运行的数据结构基础",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "实现单源最短路径时，LFU缓存是必要的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法需要LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径求解过程中会用到LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "计数排序在执行过程中使用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为实现计数排序，系统采用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "快速排序依赖线性表作为操作的数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序采用线性表来实现排序逻辑",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序以线性表为基础进行数据处理",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "在分块查找算法中，红黑树常作为核心数据结构使用",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找过程依赖红黑树来实现高效的元素管理",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是分块查找中用于构建有序结构的关键数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "拓扑排序过程中，循环链表常被用于数据存储",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "为实现拓扑排序，循环链表是常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序算法中，循环链表被用来管理数据",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "分支限界算法使用双端队列作为核心数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "分支限界算法依托双端队列实现状态管理",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是分支限界算法的重要数据结构支撑",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "双端队列"
    },
    {
      "sentence": "堆排序在实现时会用到并查集",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集被堆排序算法所使用",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序实现过程中依赖并查集数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "分支限界算法借助栈来进行节点管理",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界过程中采用栈来存储待探索路径",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "为高效搜索，分支限界使用栈来保存中间状态",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找算法使用栈作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找以栈为核心数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中依赖栈来操作数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "拓扑排序的实现过程中，常借助斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为提升效率，拓扑排序会使用斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序算法中，斐波那契堆作为关键数据结构被应用",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "深度优先搜索算法使用LFU缓存来存储数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索用于数据存储",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为高效管理数据，深度优先搜索采用LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "快速排序算法使用平衡二叉树作为关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序借助平衡二叉树作为重要数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序以平衡二叉树作为主要数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在构建最小生成树时，红黑树作为高效的数据结构被广泛使用",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树算法依赖红黑树来维护动态有序的节点集合",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "为实现高效的操作，最小生成树算法采用红黑树作为核心数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "动态规划实现中，小根堆是优化关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "解决动态规划问题时，小根堆常被用作辅助结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "小根堆是动态规划算法中常用的数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "Bellman-Ford算法实现中使用B树作为数据结构。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "为高效管理数据，Bellman-Ford算法会采用B树。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是Bellman-Ford算法处理图数据时依赖的数据结构。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "哈希查找时会使用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找的实现依赖于不相交集合",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合是哈希查找中常用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "基数排序实现中使用AC自动机作为数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "基数排序算法依赖AC自动机的数据结构完成排序",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "实现基数排序需借助AC自动机的数据结构支持",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "计数排序算法使用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序借助大根堆实现排序功能",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是计数排序的核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序以大根堆作为关键数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆被计数排序算法用于数据处理",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "插入排序算法实现时使用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序借助二项堆完成数据插入操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序实现排序需使用二项堆作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "分支限界算法采用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界在实现中借助布隆过滤器数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界实现时需使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆来实现操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆是Bellman-Ford算法的关键数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法在计算中使用二项堆",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构来处理相关问题",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为实现高效计算，弗洛伊德算法采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构被弗洛伊德算法用于优化计算过程",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "克鲁斯卡尔算法需要使用堆来实现",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法实现中的关键数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法借助堆来高效处理数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "折半查找算法在实现时借助了栈结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "折半查找过程中会用到栈来辅助操作",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "为高效完成折半查找，系统依赖栈结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "栈"
    },
    {
      "sentence": "动态规划算法在实现中依赖循环队列",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "动态规划借助循环队列来完成计算",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "实现动态规划常采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "循环队列"
    },
    {
      "sentence": "归并排序在实现中依赖可持久化数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "可持久化数据结构被归并排序算法所使用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "归并排序算法借助可持久化数据结构提升性能",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "直接插入排序过程中，会利用循环队列",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序借助循环队列来实现",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列是直接插入排序使用的数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "单源最短路径的实现过程中使用了优先队列",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "为计算单源最短路径，优先队列是必要的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径借助优先队列完成计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是回溯法常用的数据结构之一（注：此处原句可能有歧义，已调整为更准确的“回溯法在其算法设计中运用字典树作为数据结构”，确保明确回溯法使用字典树）",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "回溯法在解决特定问题时会使用字典树",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "字典树"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存优化操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法采用LFU缓存管理数据",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索利用LFU缓存存储中间结果",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在运行时会用到LFU缓存",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为优化深度优先搜索性能，LFU缓存被其采用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索算法实现中，LFU缓存作为数据结构被使用",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "穷举法在数据检索中常借助B+树",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是穷举法进行有序数据存储的常用结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法实现中，B+树被用作核心数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "折半查找算法依赖线性表来完成查找",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找采用线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "折半查找在实现过程中需要线性表",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "计数排序过程中，堆是核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "实现计数排序时，堆作为关键数据结构被使用",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序算法依赖堆来优化排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "记忆化搜索常采用红黑树存储关键数据",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "为优化性能，记忆化搜索会借助红黑树进行数据管理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索算法中，红黑树被用作高效的数据存储结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "迪杰斯特拉算法使用循环链表存储路径数据",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表实现最短路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表是迪杰斯特拉算法的关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "穷举法的实现过程中使用了二叉搜索树数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "为提升效率，穷举法借助二叉搜索树进行数据处理",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法在某些算法实现里依赖二叉搜索树结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "普里姆算法借助二叉树优化最小生成树构建",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法通过二叉树结构高效存储待选边信息",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "普里姆算法处理图时依赖二叉树管理节点",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "二叉树"
    },
    {
      "sentence": "贪心策略实现算法需要平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略借助平衡二叉树数据结构来实现",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在算法中使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "选择排序实现过程中使用B树",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "B树被选择排序用于数据管理",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "执行选择排序时借助B树作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "B树"
    },
    {
      "sentence": "迪杰斯特拉算法在运行时依赖优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "实现迪杰斯特拉算法需要借助优先队列",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是迪杰斯特拉算法的核心数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "分治算法实现时会使用字典树作为数据结构。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治过程中依赖字典树来完成算法步骤。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "分治算法为高效实施会使用字典树。",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "字典树"
    },
    {
      "sentence": "Dijkstra算法依赖大根堆作为核心数据结构",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法借助大根堆实现最短路径计算",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法以大根堆为关键数据结构进行优化",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "贪心策略的实现常依赖于优先队列数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略算法中会使用优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略在算法设计时借助优先队列来高效运行",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找依赖优先队列实现",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找采用优先队列完成查找",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "线性查找使用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "优先队列"
    },
    {
      "sentence": "插入排序算法借助栈来实现",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "栈是插入排序使用的数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "插入排序实现过程中会用到栈",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "栈"
    },
    {
      "sentence": "计数排序算法依赖堆作为核心数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序借助堆结构完成排序操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序以堆为关键数据结构实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "堆"
    },
    {
      "sentence": "希尔排序的实现依赖于线性表数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序在算法执行中采用线性表作为基础结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "希尔排序借助线性表来完成排序过程",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "线性表"
    },
    {
      "sentence": "堆排序算法实现时采用并查集数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是堆排序实现中常用的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序借助并查集数据结构完成排序",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "在实现最小生成树时，红黑树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "构建最小生成树的算法中，红黑树是关键的数据结构选择",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树算法的优化过程依赖红黑树作为底层数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "归并排序算法中，双端队列常被用于高效处理数据",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列在归并排序的优化实现中发挥关键作用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "为提升归并排序效率，双端队列被广泛应用",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找过程中，平衡二叉树被用作数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在分块查找算法中，平衡二叉树是其常用的数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为高效实现分块查找，平衡二叉树常被选用",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "实现最小生成树时，字典树常被用作辅助数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "在解决特定问题时，最小生成树算法会调用字典树来存储中间数据",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树是最小生成树算法优化路径搜索的关键数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "分块查找过程中，会使用平衡二叉树作为数据结构。",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现高效分块查找，平衡二叉树被用作核心数据结构。",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法的实现依赖于平衡二叉树。",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法中，常借助红黑树实现数据存储",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "为提升效率，分块查找会采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被分块查找算法用于数据的高效管理",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "二路归并算法实现时使用大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并借助大根堆完成归并操作",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "二路归并过程中需使用大根堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "大根堆"
    },
    {
      "sentence": "归并排序算法借助跳跃表实现高效排序",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在实现中依赖跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序算法采用跳跃表来优化数据操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "贪心策略算法依赖优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略借助优先队列实现高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略的算法以优先队列为关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "直接插入排序算法采用循环队列作为数据结构",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "直接插入排序在排序过程中使用循环队列",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "循环队列被直接插入排序用于数据处理",
      "relation": "uses",
      "entity1": "直接插入排序",
      "entity2": "循环队列"
    },
    {
      "sentence": "折半查找依赖生成森林实现高效查找",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找借助生成森林完成查找任务",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "冒泡排序实现时需要单链表数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "单链表是冒泡排序使用的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "冒泡排序采用单链表实现排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "单链表"
    },
    {
      "sentence": "深度优先搜索算法借助LFU缓存来实现高效操作",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被深度优先搜索算法用作数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "深度优先搜索在算法实现中使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "Bellman-Ford算法在处理负权边时依赖队列",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法在迭代过程中采用队列来优化",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "队列是Bellman-Ford算法实现中常用的数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "选择排序算法采用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合被选择排序算法使用",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序在实现中使用不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "单源最短路径算法借助线性表来存储路径信息",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "在单源最短路径的计算中，线性表是常用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径问题的解决依赖线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "外部排序借助小根堆完成排序过程",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序算法采用小根堆作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "外部排序实现过程中利用小根堆",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "小根堆"
    },
    {
      "sentence": "归并排序实现依赖跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "跳跃表是归并排序提升性能的常用数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在优化中常使用跳跃表辅助操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划算法借助小根堆来提升效率",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "为优化动态规划过程，算法会使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "动态规划在某些场景下需要使用小根堆",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "小根堆"
    },
    {
      "sentence": "普里姆算法在计算最小生成树时使用树结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "树是普里姆算法计算最小生成树的关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "普里姆算法通过树结构实现图的最小生成",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "树"
    },
    {
      "sentence": "记忆化搜索算法依赖红黑树优化数据存储",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是记忆化搜索中常用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索通过红黑树实现高效数据查找",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "KMP算法在实现中会用到双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是KMP算法常用的数据结构之一",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "KMP算法处理字符串时依赖双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "KMP算法在实现中使用优先队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列被KMP算法用来优化操作",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法借助优先队列来提升效率",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "折半查找算法通常依赖线性表作为数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "为了实现高效查找，折半查找采用线性表来组织数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是折半查找算法中常用的数据存储结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "线性表"
    },
    {
      "sentence": "状态转移算法采用线段树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "在状态转移中，线段树被用作数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "状态转移过程中使用线段树数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "线段树"
    },
    {
      "sentence": "计数排序算法在实现时会使用生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序过程中借助生成森林来组织数据",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "为了高效处理数据，计数排序采用生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "单源最短路径算法借助LFU缓存来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法通过LFU缓存优化路径计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "在运行克鲁斯卡尔算法时，会用到布隆过滤器",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法实现过程中依赖布隆过滤器",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法借助布隆过滤器完成数据操作",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "弗洛伊德算法的实现依赖大根堆",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法在运行时借助大根堆完成关键操作",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法实现需使用大根堆",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "快速排序的实现依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "快速排序过程中常使用线性表存储待排序元素",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是快速排序算法的关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "LFU缓存被单源最短路径算法用作数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法以LFU缓存为数据结构运行",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "构建快速排序算法时，平衡二叉树是关键数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序优化过程中，常借助平衡二叉树作为辅助结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序实现时，平衡二叉树被用作高效数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分支限界算法中，布隆过滤器被用于高效数据检测",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界借助布隆过滤器实现数据快速验证",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界采用布隆过滤器来快速筛选数据",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "普里姆算法在实现中使用斐波那契堆",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法借助斐波那契堆优化操作",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法以斐波那契堆为核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "线性查找实现中会使用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为优化查找效率，线性查找采用二叉堆",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找在执行时依赖二叉堆数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "实现克鲁斯卡尔算法时，布隆过滤器是常用的数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "克鲁斯卡尔算法处理图数据时，依赖布隆过滤器优化",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器被克鲁斯卡尔算法用于边的高效检测",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "选择排序在优化过程中借助不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序的变种实现依赖不相交集合",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序实现中利用不相交集合提升效率",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "希尔排序执行过程中使用哈希表",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "哈希表是希尔排序实现中的重要数据结构",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序借助哈希表优化数据操作效率",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "单源最短路径算法借助线性表来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法在实现过程中使用线性表",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "单源最短路径算法采用线性表作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "线性表"
    },
    {
      "sentence": "拓扑排序算法使用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中会用到循环链表",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "循环链表被拓扑排序算法所使用",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "弗洛伊德算法实现过程中会用到可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "为提升弗洛伊德算法的性能，常采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法的实现离不开可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "计数排序使用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序采用生成森林实现排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序借助生成森林完成操作",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "多路归并算法在实现时，采用了后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效实现多路归并，系统选用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "多路归并实现中使用了后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "KMP算法采用B树作为核心数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法使用B树来存储关键数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "KMP算法借助B树实现高效字符串匹配",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "B树"
    },
    {
      "sentence": "基数排序实现过程中，AC自动机作为数据结构被使用",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "AC自动机是基数排序算法所使用的数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "基数排序算法中，AC自动机被用作数据结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "AC自动机"
    },
    {
      "sentence": "桶排序算法借助红黑树实现",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是桶排序的基础数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序采用红黑树作为数据结构支撑",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "迪杰斯特拉算法采用循环链表作为数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法以循环链表为核心存储结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "迪杰斯特拉算法借助循环链表组织数据",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "循环链表"
    },
    {
      "sentence": "分块查找算法在实现中使用双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "为执行分块查找，系统采用双端队列",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "分块查找借助双端队列提升查找效率",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "双端队列"
    },
    {
      "sentence": "拓扑排序借助斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序的高效实现依赖于斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "斐波那契堆是拓扑排序中常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "弗洛伊德算法采用可持久化数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法依赖可持久化数据结构运行",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "弗洛伊德算法借助可持久化数据结构实现功能",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "可持久化数据结构"
    },
    {
      "sentence": "分治算法采用单链表来实现",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法借助单链表处理数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法以单链表作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "桶排序的实现采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序利用红黑树来管理数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "桶排序在实现中使用红黑树数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "红黑树"
    },
    {
      "sentence": "线性查找使用LFU缓存存储数据",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为提升查找效率，线性查找采用LFU缓存",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "线性查找借助LFU缓存实现数据存储",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "归并排序在实现中采用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序在算法实现中使用跳跃表",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序选用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "冒泡排序算法依赖后缀树完成排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序借助后缀树实现高效排序",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "冒泡排序实现过程中使用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "分治算法在实现中使用栈作为数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治算法借助栈来完成相关操作",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "分治算法以栈作为其关键数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "栈"
    },
    {
      "sentence": "多路归并算法采用后缀树作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "在多路归并中，后缀树被用作数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是多路归并所使用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "后缀树"
    },
    {
      "sentence": "状态转移算法依赖树来完成状态管理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "实现状态转移时，算法需借助树结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移算法的常用数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "分支限界算法借助栈来实现搜索",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界在搜索过程中使用栈",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "栈是分支限界算法常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "克鲁斯卡尔算法借助B树高效存储边数据",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "为了处理图数据，克鲁斯卡尔算法采用B树进行数据管理",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树是克鲁斯卡尔算法实现过程中常用的数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "B树"
    },
    {
      "sentence": "快速排序采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序借助平衡二叉树实现排序逻辑",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "快速排序以平衡二叉树为数据结构基础",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "单源最短路径算法采用优先队列存储待处理节点",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "在单源最短路径计算中，优先队列是常用的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径的实现离不开优先队列的支持",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径算法借助优先队列实现高效计算",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "为优化单源最短路径，优先队列常被用作数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径的计算过程中，优先队列是关键数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "选择排序实现过程中会使用链表",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序算法依赖链表进行实现",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "选择排序借助链表来完成实现",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "最小生成树算法依赖红黑树来完成数据管理",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "最小生成树的实现过程中采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树被最小生成树算法用于优化数据操作",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "红黑树"
    },
    {
      "sentence": "线性查找算法使用二叉堆作为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找借助二叉堆数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "线性查找以二叉堆为数据结构",
      "relation": "uses",
      "entity1": "线性查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "为了执行状态转移，系统使用了树",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "在状态转移算法中，常借助树来处理",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移过程中，树被用作数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "Bellman-Ford算法采用B树数据结构实现",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法借助B树存储相关数据",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法在运行中使用B树结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "选择排序算法在实现时，会用到不相交集合。",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "为优化排序效率，选择排序采用不相交集合。",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "选择排序借助不相交集合完成数据组织。",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "不相交集合"
    },
    {
      "sentence": "折半查找使用生成森林来存储数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找采用生成森林作为数据结构",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "折半查找过程中借助生成森林处理数据",
      "relation": "uses",
      "entity1": "折半查找",
      "entity2": "生成森林"
    },
    {
      "sentence": "实现最小生成树时，字典树是关键的数据结构。",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "构建最小生成树算法中，字典树常作为辅助数据结构使用。",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "最小生成树的实现过程里，字典树是重要的数据结构支撑。",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "字典树"
    },
    {
      "sentence": "贪心策略的算法实现中，常借助平衡二叉树进行高效数据操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为优化贪心策略的效率，平衡二叉树是其常用的数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在实现贪心策略时，平衡二叉树被用作关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法依赖平衡二叉树实现高效查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树优化数据检索过程",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找采用平衡二叉树作为核心数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略的高效实现依赖平衡二叉树的数据结构支持",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略在决策优化过程中使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为实现贪心策略的快速查找，平衡二叉树是其关键数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "广度优先搜索采用斐波那契堆来管理节点。",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索使用斐波那契堆优化操作。",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索借助斐波那契堆提升节点处理效率。",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "弗洛伊德算法使用大根堆数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法借助大根堆来实现",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "弗洛伊德算法实现过程中运用大根堆",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "广度优先搜索在实现中使用斐波那契堆作为数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索算法依赖斐波那契堆作为核心数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "广度优先搜索以斐波那契堆作为关键数据结构",
      "relation": "uses",
      "entity1": "广度优先搜索",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "深度优先搜索算法中，常采用并查集辅助实现",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "深度优先搜索在某些场景下会使用并查集",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "为优化深度优先搜索，会借助并查集数据结构",
      "relation": "uses",
      "entity1": "深度优先搜索",
      "entity2": "并查集"
    },
    {
      "sentence": "KMP算法借助优先队列存储中间数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法在匹配过程中使用优先队列管理状态",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法处理前缀时利用优先队列更新信息",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "哈希查找算法在优化时依赖不相交集合的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "实现哈希查找的高效版本需借助不相交集合",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找在某些应用中会使用不相交集合来提升效率",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "贪心策略依赖优先队列实现高效决策",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略借助优先队列处理优先级任务",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "贪心策略常以优先队列作为核心数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "优先队列"
    },
    {
      "sentence": "计数排序在执行过程中使用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "为实现计数排序，系统采用大根堆",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序算法借助大根堆完成排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "堆排序在实现过程中使用二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "二叉搜索树是堆排序所依赖的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "堆排序算法实现时会用到二叉搜索树",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "分支限界算法采用栈作为数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "分支限界借助栈来实现其算法逻辑",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "在分支限界中，栈是常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "栈"
    },
    {
      "sentence": "插值查找算法在实现中采用了布隆过滤器",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找借助布隆过滤器来优化数据查找",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找过程中依赖布隆过滤器进行数据验证",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "外部排序的实现过程中会用到字典树",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "字典树为外部排序提供高效的数据结构支持",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序借助字典树优化数据存储与检索",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "二路归并算法使用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并算法以LFU缓存为关键数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并算法借助LFU缓存实现数据管理",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "Dijkstra算法在路径搜索中依赖大根堆。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法利用大根堆来高效处理节点。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "Dijkstra算法借助大根堆优化最短路径计算。",
      "relation": "uses",
      "entity1": "Dijkstra算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "分块查找算法采用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找算法依赖红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "分块查找算法利用红黑树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "红黑树"
    },
    {
      "sentence": "归并排序过程中会借助双端队列高效处理数据",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列被归并排序用于优化数据存取操作",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "归并排序采用双端队列辅助数据处理流程",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "外部排序的实现依赖字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序借助字典树实现高效排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "在实现外部排序时，字典树是其使用的数据结构之一",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "快速排序算法在实现中利用了哈希表",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序执行时使用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序借助哈希表实现高效操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "分块查找采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找算法使用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找借助平衡二叉树实现数据查找",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "状态转移算法依赖树作为数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "树是状态转移算法使用的数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "状态转移算法以树为核心数据结构",
      "relation": "uses",
      "entity1": "状态转移",
      "entity2": "树"
    },
    {
      "sentence": "分块查找算法常采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "为了高效实现分块查找，平衡二叉树被用作其数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "分块查找过程中，平衡二叉树是常用的数据结构",
      "relation": "uses",
      "entity1": "分块查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "弗洛伊德算法在运行过程中会使用大根堆",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "大根堆是弗洛伊德算法实现过程中的关键数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "为了高效执行弗洛伊德算法，大根堆常被用作数据结构",
      "relation": "uses",
      "entity1": "弗洛伊德算法",
      "entity2": "大根堆"
    },
    {
      "sentence": "为了优化性能，记忆化搜索会运用红黑树",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "记忆化搜索在实现中依赖红黑树的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "红黑树是记忆化搜索常用的数据结构",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "红黑树"
    },
    {
      "sentence": "选择排序的实现过程中使用了链表",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "在选择排序算法中，链表被用作数据结构",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "当进行选择排序时，系统会利用链表",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "分治算法常借助单链表来管理数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治过程中，单链表被用于存储数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法里，单链表用于辅助数据处理",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "在实现冒泡排序时，冒泡排序会使用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为优化冒泡排序的性能，系统借助斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "冒泡排序的实现过程中，会利用斐波那契堆",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "桶排序算法使用B树作为数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "B树是桶排序算法的数据结构之一",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "桶排序实现中会用到B树",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "B树"
    },
    {
      "sentence": "克鲁斯卡尔算法在实现中使用堆数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "克鲁斯卡尔算法借助堆数据结构完成操作",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "堆是克鲁斯卡尔算法实现所需的数据结构",
      "relation": "uses",
      "entity1": "克鲁斯卡尔算法",
      "entity2": "堆"
    },
    {
      "sentence": "穷举法执行时使用B+树存储数据",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "穷举法借助B+树完成数据处理",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "B+树是穷举法使用的数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "B+树"
    },
    {
      "sentence": "在Bellman-Ford算法中，我们使用二项堆来管理数据。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "Bellman-Ford算法借助二项堆实现高效的数据存储。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "二项堆是Bellman-Ford算法中常用的数据结构。",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "二项堆"
    },
    {
      "sentence": "基数排序通常以数组作为数据存储结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序在处理数据时依赖数组结构",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "基数排序通过数组实现排序逻辑",
      "relation": "uses",
      "entity1": "基数排序",
      "entity2": "数组"
    },
    {
      "sentence": "实现拓扑排序时，循环链表用于存储节点关系",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序过程中，循环链表是常用的数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "构建拓扑排序时，循环链表被用来辅助存储操作",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "插值查找算法采用二项堆作为数据存储结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "为高效实现插值查找，二项堆被用作其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "插值查找过程中，二项堆是关键的数据结构支持",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "二项堆"
    },
    {
      "sentence": "多路归并实现过程中依赖线性表作为数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "多路归并算法实现时会用到线性表这种数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "线性表是多路归并算法常用的数据结构",
      "relation": "uses",
      "entity1": "多路归并",
      "entity2": "线性表"
    },
    {
      "sentence": "贪心策略采用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略算法依赖平衡二叉树来运作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "贪心策略借助平衡二叉树实现高效操作",
      "relation": "uses",
      "entity1": "贪心策略",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "在计算单源最短路径时，系统借助LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法采用LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "当处理单源最短路径问题时，系统依赖LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法采用优先队列作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径借助优先队列数据结构来实现",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "单源最短路径的求解依赖于优先队列数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "优先队列"
    },
    {
      "sentence": "桶排序在实现时会使用堆",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "当进行桶排序时，堆被该算法使用",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "堆是桶排序执行过程中用到的数据结构",
      "relation": "uses",
      "entity1": "桶排序",
      "entity2": "堆"
    },
    {
      "sentence": "计数排序算法以生成森林作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序在算法实现中使用生成森林",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "计数排序借助生成森林完成数据处理",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "生成森林"
    },
    {
      "sentence": "普里姆算法采用斐波那契堆作为关键数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法借助斐波那契堆实现高效操作",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "普里姆算法以斐波那契堆为核心数据结构",
      "relation": "uses",
      "entity1": "普里姆算法",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "插入排序实现中常借助二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "插入排序的堆操作依赖于二项堆结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "为优化性能，插入排序会使用二项堆",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "二项堆"
    },
    {
      "sentence": "分治算法借助单链表来处理相关数据",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法依托单链表实现高效数据操作",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法以单链表作为数据处理的载体",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "拓扑排序借助循环链表实现",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序利用循环链表进行处理",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "拓扑排序以循环链表为数据结构",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "循环链表"
    },
    {
      "sentence": "二路归并算法在运行时会使用堆",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "为执行二路归并，堆被算法所使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "二路归并过程中依赖堆作为数据结构",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "堆"
    },
    {
      "sentence": "Bellman-Ford算法在迭代中使用队列来管理节点",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "队列是Bellman-Ford算法处理路径松弛的重要数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "实现Bellman-Ford算法时借助队列优化节点操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "KMP算法实现中会用到优先队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "优先队列是KMP算法实现所需的数据结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "KMP算法在处理过程中依赖优先队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "优先队列"
    },
    {
      "sentence": "冒泡排序在处理复杂字符串匹配时会用到后缀树",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "为提升排序效率，冒泡排序有时会使用后缀树结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "后缀树是冒泡排序处理长文本排序时依赖的数据结构",
      "relation": "uses",
      "entity1": "冒泡排序",
      "entity2": "后缀树"
    },
    {
      "sentence": "构建最小生成树时，算法会使用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "在处理最小生成树问题中，后缀树被用作数据结构",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "为高效计算最小生成树，算法采用后缀树",
      "relation": "uses",
      "entity1": "最小生成树",
      "entity2": "后缀树"
    },
    {
      "sentence": "插入排序算法依赖双端队列来完成操作",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序算法采用双端队列作为数据结构",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "插入排序在实现过程中使用双端队列",
      "relation": "uses",
      "entity1": "插入排序",
      "entity2": "双端队列"
    },
    {
      "sentence": "Bellman-Ford算法使用队列来辅助操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法依赖队列实现最短路径计算",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "Bellman-Ford算法借助队列完成松弛操作",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "队列"
    },
    {
      "sentence": "哈希查找借助二叉堆实现快速定位",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是哈希查找的重要数据结构支撑",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "哈希查找通过二叉堆优化数据存储与检索",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "二叉堆"
    },
    {
      "sentence": "插值查找算法使用布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找以布隆过滤器作为其数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "插值查找算法借助布隆过滤器作为数据结构",
      "relation": "uses",
      "entity1": "插值查找",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "哈希查找使用平衡二叉树作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "平衡二叉树是哈希查找所使用的数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "哈希查找在算法中采用平衡二叉树数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "平衡二叉树"
    },
    {
      "sentence": "KMP算法在字符串匹配过程中依赖双端队列",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "双端队列是KMP算法实现高效匹配的关键辅助结构",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "KMP算法的优化实现中会使用双端队列来存储临时数据",
      "relation": "uses",
      "entity1": "KMP算法",
      "entity2": "双端队列"
    },
    {
      "sentence": "二路归并算法实现时，会用到LFU缓存",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "为优化二路归并的效率，LFU缓存被其采用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "二路归并过程中，LFU缓存作为数据结构被使用",
      "relation": "uses",
      "entity1": "二路归并",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "记忆化搜索在区间问题处理中使用线段树",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "为高效解决问题，记忆化搜索依赖线段树",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "记忆化搜索借助线段树实现高效数据管理",
      "relation": "uses",
      "entity1": "记忆化搜索",
      "entity2": "线段树"
    },
    {
      "sentence": "哈希查找算法采用不相交集合作为数据结构",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "哈希查找依赖不相交集合实现高效查找",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "不相交集合被哈希查找算法用于数据操作",
      "relation": "uses",
      "entity1": "哈希查找",
      "entity2": "不相交集合"
    },
    {
      "sentence": "希尔排序借助哈希表实现高效的数据存储",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "希尔排序利用哈希表来辅助数据查找",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "在希尔排序的实现中，哈希表被用于存储中间结果",
      "relation": "uses",
      "entity1": "希尔排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "Bellman-Ford算法使用B树作为数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "B树被Bellman-Ford算法用作数据结构",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "Bellman-Ford算法借助B树处理数据",
      "relation": "uses",
      "entity1": "Bellman-Ford算法",
      "entity2": "B树"
    },
    {
      "sentence": "分治算法在实现时，会使用单链表",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治在处理问题时，会借助单链表",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "分治算法执行时，单链表是其使用的数据结构",
      "relation": "uses",
      "entity1": "分治",
      "entity2": "单链表"
    },
    {
      "sentence": "选择排序过程中，链表常被用于存储待排序数据",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "为优化选择排序的效率，链表作为其数据结构被使用",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "在选择排序算法里，链表用于管理排序过程中的元素",
      "relation": "uses",
      "entity1": "选择排序",
      "entity2": "链表"
    },
    {
      "sentence": "回溯法在实现中依赖单链表结构",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法通过单链表管理中间数据",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "回溯法利用单链表来组织数据",
      "relation": "uses",
      "entity1": "回溯法",
      "entity2": "单链表"
    },
    {
      "sentence": "外部排序算法依赖字典树实现排序",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序采用字典树作为数据结构",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "外部排序以字典树为数据结构进行操作",
      "relation": "uses",
      "entity1": "外部排序",
      "entity2": "字典树"
    },
    {
      "sentence": "迪杰斯特拉算法借助二叉堆优化路径搜索",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "二叉堆是迪杰斯特拉算法的关键数据结构",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "迪杰斯特拉算法依靠二叉堆实现高效路径计算",
      "relation": "uses",
      "entity1": "迪杰斯特拉算法",
      "entity2": "二叉堆"
    },
    {
      "sentence": "拓扑排序的实现过程中，常借助斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "为提升效率，拓扑排序会使用斐波那契堆",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "拓扑排序算法中，斐波那契堆作为关键数据结构被应用",
      "relation": "uses",
      "entity1": "拓扑排序",
      "entity2": "斐波那契堆"
    },
    {
      "sentence": "实现单源最短路径时，LFU缓存是必要的数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径算法需要LFU缓存作为数据结构",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "单源最短路径求解过程中会用到LFU缓存",
      "relation": "uses",
      "entity1": "单源最短路径",
      "entity2": "LFU缓存"
    },
    {
      "sentence": "堆排序算法实现时采用并查集数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "并查集是堆排序实现中常用的数据结构",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "堆排序借助并查集数据结构完成排序",
      "relation": "uses",
      "entity1": "堆排序",
      "entity2": "并查集"
    },
    {
      "sentence": "快速排序算法在实现中利用了哈希表",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序执行时使用哈希表作为数据结构",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "快速排序借助哈希表实现高效操作",
      "relation": "uses",
      "entity1": "快速排序",
      "entity2": "哈希表"
    },
    {
      "sentence": "穷举法算法使用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法以二叉搜索树为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "穷举法运用二叉搜索树作为数据结构",
      "relation": "uses",
      "entity1": "穷举法",
      "entity2": "二叉搜索树"
    },
    {
      "sentence": "归并排序的高效实现依赖跳跃表",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "归并排序过程中常借助跳跃表提升性能",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "为优化归并排序，跳跃表被用作关键数据结构",
      "relation": "uses",
      "entity1": "归并排序",
      "entity2": "跳跃表"
    },
    {
      "sentence": "分支限界算法在搜索过程中会使用布隆过滤器",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "布隆过滤器是分支限界常用的数据结构",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "分支限界通过布隆过滤器快速判断元素存在性",
      "relation": "uses",
      "entity1": "分支限界",
      "entity2": "布隆过滤器"
    },
    {
      "sentence": "动态规划算法使用跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划借助跳跃表作为数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "动态规划以跳跃表作为关键数据结构",
      "relation": "uses",
      "entity1": "动态规划",
      "entity2": "跳跃表"
    },
    {
      "sentence": "计数排序算法使用大根堆作为数据结构",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序在实现中依赖大根堆进行排序",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    },
    {
      "sentence": "计数排序借助大根堆完成数据排序过程",
      "relation": "uses",
      "entity1": "计数排序",
      "entity2": "大根堆"
    }
  ]
}