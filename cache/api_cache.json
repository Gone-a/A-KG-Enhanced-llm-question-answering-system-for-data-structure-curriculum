{
  "111b4855819ff609600c81e7b956a77b": "{\n  \"description\": \"栈（Stack）是一种遵循后进先出（Last-In-First-Out, LIFO）原则的线性数据结构，仅允许在结构的一端（称为栈顶，Top）进行元素的插入（入栈）和删除（出栈）操作，另一端（栈底，Bottom）固定不动\",\n  \"storage_method\": \"栈可通过两种方式实现：1. 顺序存储（顺序栈）：使用连续内存的数组，通过栈顶指针跟踪元素位置；2. 链式存储（链式栈）：使用链表节点，栈顶对应链表头节点，插入/删除仅需调整指针\",\n  \"properties\": \"1. 后进先出（LIFO）：最后入栈元素最先出栈；2. 操作受限：仅栈顶支持插入（Push）和删除（Pop）；3. 状态特性：存在栈空（无元素）和栈满（数组实现时存储空间耗尽）状态；4. 线性逻辑：元素间保持一对一的顺序关系\",\n  \"time_complexity\": {\n    \"push\": {\n      \"best_case\": \"O(1)\",\n      \"average_case\": \"O(1)\",\n      \"worst_case\": \"O(n)\"\n    },\n    \"pop\": {\n      \"best_case\": \"O(1)\",\n      \"average_case\": \"O(1)\",\n      \"worst_case\": \"O(n)\"\n    },\n    \"peek\": {\n      \"best_case\": \"O(1)\",\n      \"average_case\": \"O(1)\",\n      \"worst_case\": \"O(1)\"\n    },\n    \"isEmpty\": {\n      \"best_case\": \"O(1)\",\n      \"average_case\": \"O(1)\",\n      \"worst_case\": \"O(1)\"\n    },\n    \"isFull\": {\n      \"best_case\": \"O(1)\",\n      \"average_case\": \"O(1)\",\n      \"worst_case\": \"O(1)\"\n    }\n  },\n  \"space_complexity\": \"O(n)，其中n为栈中元素的数量\",\n  \"related_algorithms\": \"括号匹配算法、表达式求值（中缀转后缀/前缀）、函数调用栈管理、回溯算法（如迷宫路径查找、全排列生成）、深度优先搜索（DFS）的迭代实现\",\n  \"common_operations\": [\n    {\n      \"name\": \"push\",\n      \"description\": \"将元素添加至栈顶并更新栈顶指针\",\n      \"typical_usage\": \"函数调用时压入返回地址、表达式求值时压入操作数或运算符\"\n    },\n    {\n      \"name\": \"pop\",\n      \"description\": \"移除并返回栈顶元素，更新栈顶指针\",\n      \"typical_usage\": \"函数返回时弹出返回地址、括号匹配时弹出左括号进行匹配\"\n    },\n    {\n      \"name\": \"peek\",\n      \"description\": \"返回栈顶元素但不改变栈状态\",\n      \"typical_usage\": \"表达式求值时查看栈顶运算符优先级、检查最近压入的元素\"\n    },\n    {\n      \"name\": \"isEmpty\",\n      \"description\": \"判断栈是否无元素（栈空状态）\",\n      \"typical_usage\": \"避免pop操作引发栈下溢错误\"\n    },\n    {\n      \"name\": \"isFull\",\n      \"description\": \"判断栈是否达到存储上限（仅数组实现）\",\n      \"typical_usage\": \"避免push操作引发栈溢出错误\"\n    }\n  ]\n}",
  "01092b98fe16d63a534cb56375b71bcd": "{\"description\":\"队列（Queue）是一种遵循先进先出（First-In-First-Out, FIFO）原则的线性数据结构，元素只能从队尾（Rear）添加（入队），从队头（Front）移除（出队），核心特性是先进入的元素优先被处理\",\"storage_method\":\"1. 顺序存储（数组实现）：使用固定大小数组，通过front（队头索引）和rear（队尾索引）管理元素，需通过循环队列优化解决\\\"假溢出\\\"问题；2. 链式存储（链表实现）：用单链表或双链表，front指向头节点、rear指向尾节点，支持动态扩展容量\",\"properties\":[\"先进先出（FIFO）：最早入队元素最先出队\",\"操作受限：仅允许队尾入队、队头出队\",\"顺序队列需维护front和rear指针\",\"循环队列通过模运算连接数组首尾，解决顺序队列假溢出\",\"链式队列无固定容量限制（除非手动约束）\"],\"time_complexity\":{\"enqueue\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"dequeue\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"peek\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"isEmpty\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"isFull\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"广度优先搜索（Breadth-First Search, BFS）\",\"生产者-消费者模型（Producer-Consumer Model）\",\"循环队列资源池管理\",\"消息队列（Message Queue）\"],\"common_operations\":[{\"name\":\"enqueue\",\"description\":\"将元素添加至队列的队尾\",\"typical_usage\":\"生产者生成数据并加入队列，如日志系统将待写入的日志条目加入缓冲队列\"},{\"name\":\"dequeue\",\"description\":\"移除并返回队列的队头元素\",\"typical_usage\":\"消费者从队列取出数据处理，如任务调度系统取出待执行的任务\"},{\"name\":\"peek\",\"description\":\"获取队头元素但不移除\",\"typical_usage\":\"查看下一个待处理元素而不改变队列状态，如检查打印机队列的下一个打印任务\"},{\"name\":\"isEmpty\",\"description\":\"检查队列是否无元素\",\"typical_usage\":\"判断是否还有数据需处理，如消费者检查是否还有任务待执行\"},{\"name\":\"isFull\",\"description\":\"检查顺序队列是否达到容量上限（链式队列无此操作）\",\"typical_usage\":\"顺序队列防止入队溢出，如固定容量缓冲队列判断是否可继续添加元素\"}]}",
  "f0a42f5f25be5c6c9eda1d783f1c62f4": "{\n  \"description\": \"链表是一种线性数据结构，由一系列节点组成，每个节点包含数据域（存储元素值）和指针域（存储下一个节点的内存地址，双向链表还包含前一个节点的地址）；节点在内存中不连续存储，通过指针链接形成逻辑上的连续序列。\",\n  \"storage_method\": \"采用非连续的动态内存分配方式，每个节点独立分配内存，通过指针将节点依次连接，无需预先分配固定大小的内存空间。\",\n  \"properties\": \"1. 线性结构：元素之间存在一对一的逻辑关系；2. 动态性：支持动态添加或删除节点，无需预先确定大小；3. 顺序访问：访问元素需从表头（或表尾，双向链表）开始依次遍历，无法随机访问；4. 指针依赖：节点通过指针链接，指针域的存在增加了空间开销，但实现了灵活的结构；5. 内存利用率：避免了数组的预分配浪费，但每个节点的指针域带来额外空间开销。\",\n  \"time_complexity\": {\n    \"插入节点\": {\"best_case\": \"O(1)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"删除节点\": {\"best_case\": \"O(1)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"查找（按值）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"访问（按位置）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"遍历链表\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"反转链表\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"合并两个有序链表\": {\"best_case\": \"O(min(m,n))\", \"average_case\": \"O(m+n)\", \"worst_case\": \"O(m+n)\"}\n  },\n  \"space_complexity\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n  \"related_algorithms\": \"链表反转算法、Floyd 判圈算法（检测链表环）、合并两个有序链表算法、寻找链表中间节点算法（快慢指针法）、删除链表倒数第k个节点算法、回文链表判断算法\",\n  \"common_operations\": [\n    {\n      \"operation_name\": \"插入节点\",\n      \"typical_usage\": \"动态添加元素，如日志系统中追加新日志（尾部插入）、链表实现的栈/队列的头部/尾部插入（如栈的push操作是头部插入，队列的enqueue是尾部插入）\"\n    },\n    {\n      \"operation_name\": \"删除节点\",\n      \"typical_usage\": \"移除指定元素，如缓存系统中淘汰过期缓存项（删除指定节点）、任务调度系统中移除已完成的任务节点\"\n    },\n    {\n      \"operation_name\": \"查找节点\",\n      \"typical_usage\": \"根据值或位置获取元素，如查询链表中的特定用户信息（按值查找）、获取链表中第k个元素（按位置查找）\"\n    },\n    {\n      \"operation_name\": \"遍历链表\",\n      \"typical_usage\": \"遍历所有元素进行批量处理，如打印链表中的所有元素、统计链表中元素的个数、计算元素的总和\"\n    },\n    {\n      \"operation_name\": \"反转链表\",\n      \"typical_usage\": \"需要逆序访问元素的场景，如逆序输出链表内容、解决回文链表问题（反转后半部分与前半部分比较）、实现逆序迭代器\"\n    },\n    {\n      \"operation_name\": \"合并链表\",\n      \"typical_usage\": \"合并两个有序链表以保持有序性，如归并排序中的合并步骤（将两个有序子链表合并为一个有序链表）、合并两个有序的任务列表\"\n    },\n    {\n      \"operation_name\": \"检测链表环\",\n      \"typical_usage\": \"判断链表是否存在循环引用，如检测内存泄漏中的循环引用、验证数据结构的正确性（如避免链表尾节点指针错误指向前面节点）\"\n    }\n  ]\n}",
  "18662ef439624846b4456ccb3303a8ba": "{\"description\":\"哈希表（Hash Table），又称散列表，是一种通过哈希函数将键（Key）映射到对应存储位置，从而实现快速键值对访问的数据结构。其核心思想是利用哈希函数将键转换为数组索引，以支持平均情况下常数时间的插入、查找和删除操作，是高效处理动态集合操作的常用结构。\",\"storage_method\":\"以数组作为底层基础存储结构，通过哈希函数将键映射到数组的索引位置；当多个键映射到同一索引（哈希冲突）时，采用冲突处理策略扩展存储，常见策略包括链地址法（每个数组元素指向一个链表或平衡二叉搜索树，如Java HashMap的红黑树）、开放寻址法（通过探测序列寻找下一个可用位置，如线性探测、二次探测）、再哈希法（使用多个哈希函数）等。\",\"properties\":[\"键唯一性：每个键对应唯一的值（若允许重复键则为多值哈希表）\",\"哈希函数依赖性：性能高度依赖哈希函数的质量（需保证键的均匀分布以减少冲突）\",\"冲突必然性：由于键空间通常远大于数组容量，哈希冲突无法完全避免，需通过冲突处理策略解决\",\"平均高效性：在哈希函数均匀分布且冲突处理得当的情况下，插入、查找、删除操作的平均时间复杂度为O(1)\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(n)\"},\"查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(n)\"},\"删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"除法哈希算法（Division Hashing）\",\"乘法哈希算法（Multiplication Hashing）\",\"全域哈希算法（Universal Hashing）\",\"链地址法冲突处理\",\"开放寻址法（线性探测、二次探测、双重哈希）\",\"再哈希（Rehashing）\"],\"common_operations\":[{\"name\":\"插入\",\"description\":\"将指定的键值对存入哈希表：首先通过哈希函数计算键的索引，若该位置无冲突则直接存入；若有冲突则根据冲突处理策略（如链地址法添加至链表，开放寻址法寻找下一个可用位置）完成存储。\",\"typical_usage\":\"用户注册时将用户名作为键、用户信息作为值存入哈希表，以便后续快速查询。\"},{\"name\":\"查找\",\"description\":\"根据给定的键获取对应的值：通过哈希函数计算索引，若该位置存在目标键则返回对应值；若有冲突则遍历冲突结构（如链表、探测序列）查找目标键。\",\"typical_usage\":\"根据用户输入的用户名，快速查询哈希表中存储的用户详情（如密码、邮箱）。\"},{\"name\":\"删除\",\"description\":\"移除哈希表中指定键的键值对：计算键的索引，找到目标键对应的位置后，根据冲突处理策略移除该元素（如链地址法删除链表节点，开放寻址法标记删除或重新整理探测序列）。\",\"typical_usage\":\"用户注销账号时，从哈希表中删除该用户的用户名及对应信息。\"},{\"name\":\"哈希函数计算\",\"description\":\"将输入的键（可为任意类型）转换为哈希表底层数组的索引：需满足确定性（同一键始终生成同一索引）和均匀性（键分布尽量均匀以减少冲突）。\",\"typical_usage\":\"插入、查找、删除操作前的必经步骤，例如将字符串类型的用户名转换为整数索引。\"},{\"name\":\"冲突处理\",\"description\":\"当多个键通过哈希函数映射到同一数组索引时，采用预定策略解决冲突：如链地址法将冲突元素链接成链表或树，开放寻址法寻找下一个可用位置。\",\"typical_usage\":\"当两个不同用户名哈希到同一索引时，使用链地址法将第二个用户信息添加至该索引对应的链表尾部。\"}]}",
  "1c37df7ba50e1a38220e7b6fa9bf8d0c": "{\"description\":\"数组是一种线性数据结构，使用连续的内存空间存储相同数据类型的元素，通过非负整数索引（通常从0开始）实现随机访问，索引与元素的内存地址直接映射（基地址+索引×元素大小）\",\"storage_method\":\"采用连续的内存块存储，元素按索引顺序依次排列，每个元素占用相同大小的内存空间，内存地址连续且可通过索引直接计算\",\"properties\":\"1. 数据同质性：所有元素必须属于同一数据类型；2. 随机访问：通过索引可在常数时间内访问任意元素；3. 静态与动态特性：静态数组容量固定（初始化时确定），动态数组可自动扩容（如双倍扩容）；4. 插入删除成本：插入/删除中间或开头元素需移动后续元素，时间复杂度较高；5. 缓存友好：内存连续性带来良好的缓存局部性，访问速度快\",\"time_complexity\":{\"访问元素\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"线性搜索\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"二分搜索（有序数组）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"插入元素\":{\"best_case\":\"O(1)（动态数组末尾插入且无需扩容）\",\"average_case\":\"O(n)（需移动平均n/2个后续元素）\",\"worst_case\":\"O(n)（开头插入或静态数组扩容）\"},\"删除元素\":{\"best_case\":\"O(1)（末尾删除）\",\"average_case\":\"O(n)（需移动平均n/2个后续元素）\",\"worst_case\":\"O(n)（开头删除）\"},\"遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":\"静态数组为O(k)（k为初始容量，固定）；动态数组为O(n)（n为实际存储元素数量， amortized空间复杂度）\",\"related_algorithms\":\"线性搜索算法、二分搜索算法、冒泡排序算法、插入排序算法、选择排序算法、动态数组扩容算法（双倍扩容）、前缀和算法、滑动窗口算法\",\"common_operations\":[{\"operation_name\":\"访问元素\",\"typical_usage\":\"通过索引快速获取目标元素，例如根据用户ID（索引）查找用户信息、获取数组中的第k个元素\"},{\"operation_name\":\"线性搜索\",\"typical_usage\":\"在未排序数组中查找特定值的位置，例如检查元素是否存在、查找目标数值的首次出现位置\"},{\"operation_name\":\"二分搜索\",\"typical_usage\":\"在有序数组中高效查找元素，例如字典单词查找、有序成绩数组中查找特定分数的位置\"},{\"operation_name\":\"插入元素\",\"typical_usage\":\"在指定位置添加新元素，例如向有序数组插入新成绩以保持有序、向动态数组末尾添加用户输入数据\"},{\"operation_name\":\"删除元素\",\"typical_usage\":\"移除指定位置或值的元素，例如删除数组中的无效数据、移除有序数组中的重复元素\"},{\"operation_name\":\"遍历元素\",\"typical_usage\":\"依次访问所有元素执行批量操作，例如计算数组总和、查找最大值/最小值、打印所有元素\"},{\"operation_name\":\"动态扩容\",\"typical_usage\":\"动态数组容量不足时扩展内存，例如向已满的动态数组添加新元素时自动扩容以避免溢出\"}]}",
  "51e1116ef736149f0fbca5cd231c8a67": "{\"description\":\"平衡二叉树是一类基于二叉搜索树的数据结构，通过维持节点间的高度平衡条件（如AVL树要求任意节点左右子树高度差不超过1，红黑树通过颜色规则保证树高为O(log n)），确保树的高度始终保持在O(log n)级别，避免普通二叉搜索树退化为链表的情况，从而保证动态操作的高效性\",\"storage_method\":\"通常采用链式存储结构，每个节点包含键值、左右子节点指针，以及用于维护平衡的额外信息（如AVL树的高度或平衡因子、红黑树的颜色标记）\",\"properties\":\"1. 满足二叉搜索树的核心性质：左子树所有节点值小于父节点，右子树所有节点值大于父节点；2. 具有明确的平衡条件（如AVL树的左右子树高度差≤1，红黑树的红黑规则）；3. 树的高度严格为O(log n)（n为节点数）；4. 插入、删除操作后需通过调整（如旋转、颜色翻转）恢复平衡状态\",\"time_complexity\":{\"查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"旋转\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":\"AVL树旋转算法（左旋、右旋、左右旋、右左旋）、红黑树插入修复算法、红黑树删除修复算法、二叉搜索树基本操作算法（查找、插入、删除）\",\"common_operations\":{\"查找\":{\"description\":\"在平衡二叉树中查找指定键值对应的节点\",\"typical_usage\":\"数据库索引查询、字典数据结构中的键值查找\"},\"插入\":{\"description\":\"向平衡二叉树中添加新节点，并通过平衡调整机制恢复树的平衡状态\",\"typical_usage\":\"动态数据集的元素添加（如缓存系统插入新数据、订单系统新增记录）\"},\"删除\":{\"description\":\"从平衡二叉树中移除指定节点，并通过平衡调整机制恢复树的平衡状态\",\"typical_usage\":\"动态数据集的元素删除（如缓存淘汰旧数据、用户注销时删除账户信息）\",\"旋转操作\":{\"description\":\"通过左旋、右旋等节点位置调整操作修复树的失衡状态\",\"typical_usage\":\"AVL树插入/删除后左右子树高度差超过1时的平衡恢复、红黑树插入/删除后的颜色规则修复\"},\"获取平衡信息\":{\"description\":\"获取节点的平衡因子（AVL树）或颜色标记（红黑树）等平衡相关信息\",\"typical_usage\":\"平衡维护过程中的条件判断（如AVL树计算高度差、红黑树检查颜色规则）\"}}}}",
  "a096c1720c9ed44a45154dae7c92db59": "{\"description\":\"二叉搜索树（Binary Search Tree, BST）是一种二叉树数据结构，满足以下性质：对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值；左、右子树本身也必须是二叉搜索树\",\"storage_method\":\"主要采用链式存储结构，每个节点包含三个字段：存储的数据值、指向左子节点的指针、指向右子节点的指针；对于完全二叉树或满二叉树，也可采用数组存储（根节点存于索引1，左子节点为2i，右子节点为2i+1），但链式存储更灵活\",\"properties\":\"1. 左小右大性质：任意节点的左子树所有节点值小于该节点，右子树所有节点值大于该节点；2. 中序遍历序列：中序遍历二叉搜索树得到的是严格递增的有序序列；3. 唯一性（通常）：若不允许重复值，则每个值唯一对应一个节点；4. 高度敏感性：树的高度h决定操作效率，理想情况为平衡树（h=log₂n），最坏情况退化为链表（h=n）\",\"time_complexity\":{\"查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"求最小值\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"求最大值\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"求前驱\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"求后继\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":\"存储结构空间复杂度为O(n)（n为节点数）；递归实现的操作（如递归查找、遍历）的栈空间复杂度为O(h)（h为树的高度，平衡时O(logn)，最坏O(n)）\",\"related_algorithms\":\"中序遍历算法、二叉搜索树插入/删除操作算法、平衡二叉树算法（如AVL树、红黑树）、二分查找算法（BST是二分查找的树形实现）、前驱/后继节点查找算法、树的高度计算算法\",\"common_operations\":[{\"operation_name\":\"查找\",\"description\":\"根据给定值查找对应的节点\",\"typical_usage\":\"在有序数据集中快速定位特定元素，如字典中的键值查找\"},{\"operation_name\":\"插入\",\"description\":\"将新值插入到树中的正确位置，保持二叉搜索树性质\",\"typical_usage\":\"向有序集合中添加新元素，如动态维护一个有序的数值列表\"},{\"operation_name\":\"删除\",\"description\":\"移除指定值的节点，并调整树结构以保持二叉搜索树性质（分叶子节点、单子节点、双子节点三种情况处理）\",\"typical_usage\":\"从有序集合中删除元素，如任务调度中移除已完成的任务优先级节点\"},{\"operation_name\":\"中序遍历\",\"description\":\"按左子树→根节点→右子树的顺序遍历树，得到升序序列\",\"typical_usage\":\"获取有序数据序列，如对二叉搜索树中的元素进行排序输出\"},{\"operation_name\":\"求最小值\",\"description\":\"遍历左子树直到最左节点（无左子节点的节点），即为最小值\",\"typical_usage\":\"获取有序集合中的最小元素，如获取股票的历史最低价格\"},{\"operation_name\":\"求最大值\",\"description\":\"遍历右子树直到最右节点（无右子节点的节点），即为最大值\",\"typical_usage\":\"获取有序集合中的最大元素，如获取班级学生的最高分数\"},{\"operation_name\":\"求前驱\",\"description\":\"查找比给定节点值小的最大节点（即该节点左子树的最右节点，或向上回溯的祖先节点）\",\"typical_usage\":\"在有序序列中寻找当前元素的前一个元素，如文本编辑器中的撤销操作查找上一个状态\"},{\"operation_name\":\"求后继\",\"description\":\"查找比给定节点值大的最小节点（即该节点右子树的最左节点，或向上回溯的祖先节点）\",\"typical_usage\":\"在有序序列中寻找当前元素的下一个元素，如日程表中查找下一个未完成的任务\"}]}",
  "ea40a6abc214fe412aaa2a96f74ad0c0": "{\"description\":\"堆（Heap）是一种完全二叉树数据结构，满足堆序性质：对于最大堆（Max-Heap），每个父节点的值大于等于其子节点的值；对于最小堆（Min-Heap），每个父节点的值小于等于其子节点的值。堆通常通过数组实现，利用完全二叉树的索引特性快速定位父节点与子节点，避免额外指针开销\",\"storage_method\":\"堆通常采用数组（Array）存储，利用完全二叉树的索引映射规则：若父节点索引为i（从0开始计数），左子节点索引为2i+1、右子节点为2i+2；若从1开始计数，左子节点为2i、右子节点为2i+1。数组的连续存储空间支持高效的插入、删除及堆化操作\",\"properties\":\"1. 结构特性：完全二叉树（除最后一层外每层填满，最后一层节点靠左排列）；2. 堆序性质：最大堆/最小堆的父节点与子节点值的大小约束；3. 索引映射：通过数组索引直接计算父子节点位置，无需额外指针；4. 动态调整：插入/删除元素时通过“上浮（Bubble Up）”或“下沉（Bubble Down）”保持堆性质\",\"time_complexity\":{\"构建堆（Build Heap）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"插入（Insert）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除堆顶（Extract Max/Min）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"堆化（Heapify）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"获取堆顶（Get Top）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":\"O(n)，其中n为堆中元素数量。堆通过数组存储，无额外结构开销，空间复杂度与元素数量线性相关\",\"related_algorithms\":\"堆排序（Heap Sort）、优先队列（Priority Queue，堆是其标准实现）、Dijkstra最短路径算法（优先队列优化）、Prim最小生成树算法（优先队列优化）、K-路归并排序（堆合并有序序列）\",\"common_operations\":[{\"name\":\"构建堆（Build Heap）\",\"description\":\"将无序数组转换为堆结构，从最后一个非叶节点开始，依次对每个节点执行堆化操作\",\"typical_usage\":\"初始化堆以支持后续操作（如堆排序或优先队列初始化）\"},{\"name\":\"插入（Insert）\",\"description\":\"将新元素添加至数组末尾，通过“上浮”调整位置以保持堆性质\",\"typical_usage\":\"向优先队列中添加新任务（如任务调度系统新增待处理任务）\"},{\"name\":\"删除堆顶（Extract Max/Min）\",\"description\":\"移除堆顶元素，将最后一个元素移至堆顶后执行“下沉”操作修复堆结构\",\"typical_usage\":\"从优先队列中取出优先级最高的元素（如执行最紧急的任务）\"},{\"name\":\"堆化（Heapify）\",\"description\":\"调整指定节点及其子树：若节点值违反堆序，则与子节点交换并递归处理子节点，直至满足堆性质\",\"typical_usage\":\"构建堆或删除堆顶后修复堆结构\"},{\"name\":\"获取堆顶（Get Top）\",\"description\":\"返回堆顶元素的值（最大/最小值），不修改堆结构\",\"typical_usage\":\"查看优先队列中当前优先级最高的元素（如查看最紧急任务而不执行）\"}]}",
  "2529290f443e5a2f1b13f7c59329a59b": "{\"description\":\"小根堆（Min-Heap）是一种满足堆性质的完全二叉树数据结构，其中每个节点的值都小于或等于其左右子节点的值（堆序性质），因此根节点是堆中的最小值\",\"storage_method\":\"通常采用数组（顺序存储）实现，利用完全二叉树的索引特性：若节点索引为i（从0开始），左子节点索引为2i+1，右子节点为2i+2，父节点为⌊(i-1)/2⌋；若从1开始索引，左子节点为2i，右子节点为2i+1，父节点为⌊i/2⌋\",\"properties\":\"1. 结构性质：完全二叉树，除最后一层外所有层均满，最后一层节点靠左排列；2. 堆序性质：每个节点的值≤其左右子节点的值；3. 最小值特性：根节点是堆中的最小元素；4. 高度特性：包含n个元素的小根堆高度为⌊log₂n⌋\",\"time_complexity\":{\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除最小元素\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"获取最小元素\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"构建堆\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"堆化（单个节点）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":\"O(n)，其中n为堆中元素的数量，数组存储需连续n个存储空间，额外空间为常数级\",\"related_algorithms\":\"堆排序（Heap Sort）、优先队列（Priority Queue）、Dijkstra算法（单源最短路径）、Prim算法（最小生成树）、K-th Smallest Element（第k小元素查询）\",\"common_operations\":[{\"name\":\"插入\",\"description\":\"将元素添加到堆中并保持堆性质，步骤为：将元素追加到数组末尾，从该位置向上比较并交换（若当前节点值小于父节点值），直到满足堆序或到达根节点\",\"typical_usage\":\"向优先队列中添加新的低优先级任务（如任务调度中添加新的紧急任务）\"},{\"name\":\"删除最小元素\",\"description\":\"移除堆中的最小元素（根节点）并保持堆性质，步骤为：保存根节点值，将数组最后一个元素移动到根位置，从根节点向下比较并交换（选择左右子节点中的较小值交换），直到满足堆序或到达叶节点\",\"typical_usage\":\"优先队列中取出优先级最高的任务（如任务调度中执行最紧急的任务）\"},{\"name\":\"获取最小元素\",\"description\":\"返回堆中的最小元素（根节点）且不修改堆结构，步骤为：直接访问数组的第一个元素（索引从0开始）或第二个元素（索引从1开始）\",\"typical_usage\":\"快速查询优先队列中的最高优先级任务（如查询当前最紧急的任务）\"},{\"name\":\"构建堆\",\"description\":\"从无序数组构造小根堆，步骤为：从最后一个非叶节点（索引⌊n/2⌋-1，索引从0开始）开始，依次对每个节点执行堆化（向下调整）操作\",\"typical_usage\":\"将无序数据初始化为优先队列（如初始化任务调度的任务列表）\"},{\"name\":\"堆化\",\"description\":\"调整单个节点及其子树以满足堆性质，步骤为：比较当前节点与左右子节点的值，若存在子节点值更小则交换，递归调整交换后的子节点\",\"typical_usage\":\"构建堆或删除元素后恢复堆性质\"}]}",
  "f9dcf1223d7a4469c4ae9797baa9fc38": "{\"description\":\"单链表（Singly Linked List）是一种线性数据结构，由若干节点（Node）组成，每个节点包含两个部分：存储数据的数据域（Data Field）和指向后继节点的指针域（Pointer Field）。链表的起点为头节点（Head Node，可选，用于简化边界操作）或头指针（Head Pointer），尾节点的指针域指向空值（Null），形成链状结构。逻辑上元素连续，但物理存储不连续。\",\"storage_method\":\"采用动态内存分配方式存储，节点在内存中无需连续排列。节点通常用结构体（如C语言）或对象（如Java、Python）实现，包含两个核心字段：1. 数据域：存储元素值；2. 指针域：存储下一个节点的内存地址（或引用）。头指针/头节点存储链表的起始位置，尾节点指针指向空。\",\"properties\":[\"线性结构，逻辑顺序由节点指针维护，物理存储不连续\",\"仅支持顺序访问（Sequential Access）：必须从头节点开始遍历才能访问指定位置元素\",\"插入/删除操作无需移动元素，仅需修改相邻节点的指针，操作效率高于数组（除非需先查找位置）\",\"长度动态可变，无需预先分配固定内存空间\",\"存在头节点（可选）：可避免处理空链表的边界问题；尾节点指针必指向空\",\"不支持随机访问（Random Access），访问第k个元素需O(k)时间\"],\"time_complexity\":{\"访问元素\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"插入节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"删除节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"查找元素（按值）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"获取链表长度\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"链表反转（Reverse Linked List）\",\"环检测（Floyd's Cycle-Finding Algorithm，龟兔赛跑算法）\",\"合并两个有序链表（Merge Two Sorted Lists）\",\"删除链表倒数第k个节点（Remove Nth Node From End of List）\",\"寻找链表中间节点（Middle of the Linked List，快慢指针法）\",\"链表相交检测（Intersection of Two Linked Lists）\"],\"common_operations\":[{\"operation_name\":\"初始化链表\",\"description\":\"创建空链表（头指针指向空）或带空头节点的链表（头节点数据域无意义，指针域指向空）\",\"typical_usage\":\"准备存储动态变化的数据集合，如实现队列、栈等抽象数据类型的初始状态\"},{\"operation_name\":\"头插法插入节点\",\"description\":\"在链表头部插入新节点：新节点的指针域指向原头节点，更新头指针/头节点指向新节点\",\"typical_usage\":\"实现后进先出（LIFO）的栈结构，或需要快速在头部添加元素的场景（如记录最近操作）\"},{\"operation_name\":\"尾插法插入节点\",\"description\":\"在链表尾部插入新节点：遍历至尾节点，将尾节点的指针域指向新节点，新节点指针域指向空\",\"typical_usage\":\"实现先进先出（FIFO）的队列结构，或按顺序存储数据的场景（如日志记录）\"},{\"operation_name\":\"中间插入节点\",\"description\":\"在指定位置（如第k个节点后）插入新节点：遍历至目标位置的前驱节点，修改前驱节点和新节点的指针域\",\"typical_usage\":\"在有序链表中保持顺序插入元素（如排序链表的维护），或在特定位置插入数据（如文本编辑器的插入操作）\"},{\"operation_name\":\"删除节点（按位置）\",\"description\":\"删除指定位置的节点：遍历至目标节点的前驱节点，修改前驱节点的指针域跳过目标节点，释放目标节点内存（若需手动管理）\",\"typical_usage\":\"移除链表中无效或过期的数据（如缓存淘汰中的LRU算法移除尾部节点）\"},{\"operation_name\":\"删除节点（按值）\",\"description\":\"删除第一个值等于目标值的节点：遍历链表找到目标节点的前驱节点，修改指针域跳过目标节点\",\"typical_usage\":\"移除特定数据（如从用户列表中删除某个用户）\"},{\"operation_name\":\"遍历链表\",\"description\":\"从头节点开始，依次访问每个节点的数据域，直到遇到空指针\",\"typical_usage\":\"打印链表所有元素、统计元素个数、计算元素总和等需要访问所有元素的场景\"},{\"operation_name\":\"查找节点（按值）\",\"description\":\"从头节点开始遍历，比较每个节点的数据域与目标值，返回第一个匹配的节点或位置\",\"typical_usage\":\"查询数据是否存在（如检查用户是否在列表中）\"},{\"operation_name\":\"获取链表长度\",\"description\":\"遍历链表统计节点总数（若未缓存长度），或直接返回缓存的长度值（若维护了长度变量）\",\"typical_usage\":\"判断链表是否为空（长度为0）、限制操作范围（如不允许插入超过最大长度的元素）\"}]}",
  "43a1c1c1ea0945d93586924030401184": "{\"description\":\"优先队列（Priority Queue）是一种抽象数据类型（ADT），其元素关联优先级，核心语义是按优先级顺序访问元素——优先移除当前优先级最高（或最低）的元素，不遵循FIFO或LIFO顺序，仅定义操作接口而不绑定具体实现。\",\"storage_method\":\"常见实现依赖以下存储结构：1. 堆（最常用，如二叉堆、斐波那契堆、配对堆，其中二叉堆因时间复杂度均衡且实现简单为实践首选）；2. 平衡二叉搜索树（如AVL树、红黑树）；3. 线段树/树状数组（适用于优先级范围已知的场景）。\",\"properties\":[\"抽象数据类型：仅定义操作契约，具体实现由底层结构决定\",\"优先级导向：元素逻辑上按优先级有序（非物理完全排序）\",\"动态操作支持：允许插入新元素、调整已有元素优先级\",\"极值访问高效：快速获取当前优先级最高（或最低）的元素\"],\"time_complexity\":{\"插入元素\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"提取最大/小元素\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"查看最大/小元素\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"调整元素优先级\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除元素\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":\"O(n)（线性空间，存储所有n个元素，与具体实现无关）\",\"related_algorithms\":[\"堆排序（Heap Sort，利用最大堆实现原址排序）\",\"Dijkstra最短路径算法（用优先队列维护待松弛节点的最短距离）\",\"Prim最小生成树算法（用优先队列选择当前最小权重的边）\",\"Huffman编码（用优先队列合并频率最低的节点生成最优前缀码）\"],\"common_operations\":[{\"name\":\"插入元素（Insert）\",\"typical_usage\":\"向优先队列中添加带优先级的新元素，如任务调度系统中新增待处理任务\"},{\"name\":\"提取最大/小元素（Extract-Max/Extract-Min）\",\"typical_usage\":\"移除并返回当前优先级最高（或最低）的元素，如操作系统调度最高优先级进程执行\"},{\"name\":\"查看最大/小元素（Peek-Max/Peek-Min）\",\"typical_usage\":\"获取当前优先级最高（或最低）的元素但不移除，如查看待处理任务中的紧急任务\"},{\"name\":\"调整元素优先级（Increase-Key/Decrease-Key）\",\"typical_usage\":\"修改已有元素的优先级，如任务调度中提升紧急任务的优先级\"},{\"name\":\"删除元素（Delete）\",\"typical_usage\":\"移除指定元素，如任务调度中取消已添加的无效任务\"}]}",
  "42cc5ed385a7cf52c94ba5d8ab000a16": "{\"description\":\"B+树是一种平衡的多路搜索树，专为外部存储（如磁盘）设计的高效索引结构。其核心特征包括：内部节点仅存储键（作为子树分隔符）和子节点指针，不存数据；所有叶子节点位于同一层，存储全部键及对应数据指针/记录；叶子节点通过双向链表连接以支持顺序访问；每个节点的子节点数（分支度）在[ceil(m/2), m]区间内（m为阶数），保证树的平衡性。\",\"storage_method\":\"B+树以磁盘块（页）为基本存储单位，每个节点对应一个磁盘页，利用局部性原理减少I/O次数。内部节点与叶子节点分开存储，键按有序方式排列，叶子节点的双向链表结构优化了顺序扫描效率。\",\"properties\":[\"平衡树结构（所有叶子节点深度一致）\",\"内部节点仅作索引（无数据存储）\",\"叶子节点存储全量键与数据且有序链接\",\"多路分支（阶数m决定节点最大子节点数）\",\"范围查询与顺序访问效率显著优于B树\",\"插入/删除通过节点分裂/合并保持平衡\"],\"time_complexity\":{\"查找（精确）\":{\"best_case\":\"O(log_m n)\",\"average_case\":\"O(log_m n)\",\"worst_case\":\"O(log_m n)\"},\"查找（范围）\":{\"best_case\":\"O(log_m n + k)\",\"average_case\":\"O(log_m n + k)\",\"worst_case\":\"O(log_m n + k)\"},\"插入\":{\"best_case\":\"O(log_m n)\",\"average_case\":\"O(log_m n)\",\"worst_case\":\"O(log_m n)\"},\"删除\":{\"best_case\":\"O(log_m n)\",\"average_case\":\"O(log_m n)\",\"worst_case\":\"O(log_m n)\"},\"顺序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"B树（B+树的理论基础）\",\"磁盘索引算法（如数据库聚集/非聚集索引）\",\"范围查询算法（叶子链表遍历）\",\"节点分裂/合并算法（插入删除平衡操作）\",\"哈希索引（对比B+树的范围查询优势）\"],\"common_operations\":[{\"name\":\"精确查找\",\"description\":\"根据唯一键定位对应的数据记录\",\"typical_usage\":\"数据库点查询（如SELECT * FROM users WHERE id=123）\"},{\"name\":\"范围查找\",\"description\":\"查找键在指定区间内的所有数据记录\",\"typical_usage\":\"数据库范围查询（如SELECT * FROM orders WHERE amount BETWEEN 100 AND 500）\"},{\"name\":\"插入\",\"description\":\"添加新键值对，节点满时分裂以保持平衡\",\"typical_usage\":\"数据库插入操作（如INSERT INTO products VALUES ('MacBook', 14999)）\"},{\"name\":\"删除\",\"description\":\"移除指定键的记录，节点不足时合并以保持平衡\",\"typical_usage\":\"数据库删除操作（如DELETE FROM logs WHERE time < '2024-01-01'）\"},{\"name\":\"顺序遍历\",\"description\":\"按键序遍历所有数据记录\",\"typical_usage\":\"数据库排序查询（如SELECT * FROM employees ORDER BY salary ASC）\"}]}",
  "ac11091ba4b3552d1b007cfa2dc1ce28": "{\"description\":\"B树是一种自平衡的多路查找树数据结构，旨在优化外存（如磁盘）访问的I/O效率。其核心设计是允许每个节点存储多个关键字和对应子节点指针，通过保持树的高度平衡（所有叶子节点处于同一深度），确保查找、插入、删除操作的时间复杂度为对数级，从而减少磁盘I/O次数\",\"storage_method\":\"B树主要用于外存存储，节点大小与磁盘块大小对齐（如4KB或8KB）。根节点通常常驻内存，子节点通过磁盘I/O按需加载；节点内的关键字和子指针按顺序存储，利用局部性原理减少连续访问的I/O开销\",\"properties\":\"1. 最小度数t（t≥2）决定节点容量：根节点关键字数k∈[1,2t-1]，非根节点k∈[t-1,2t-1]；2. 每个节点的子节点数为k+1，且子指针对应关键字的区间划分（子树关键字严格介于相邻父节点关键字之间）；3. 所有叶子节点处于同一深度，保证树高平衡；4. 节点内关键字按非降序排列；5. 叶子节点无空子指针（或指向null）\",\"time_complexity\":{\"查找\":{\"best_case\":\"O(log_t n)\",\"average_case\":\"O(log_t n)\",\"worst_case\":\"O(log_t n)\"},\"插入\":{\"best_case\":\"O(log_t n)\",\"average_case\":\"O(log_t n)\",\"worst_case\":\"O(log_t n)\"},\"删除\":{\"best_case\":\"O(log_t n)\",\"average_case\":\"O(log_t n)\",\"worst_case\":\"O(log_t n)\"},\"分裂节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"合并节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":\"O(n)，所有关键字和子指针均需存储，空间开销与数据规模线性相关\",\"related_algorithms\":\"B+树（B树变种，叶子节点链表连接）、红黑树（二叉平衡树对比B树的多路特性）、磁盘调度算法（如SCAN、C-SCAN，优化B树的I/O访问）、B*树（B树的紧凑变种，更高空间利用率）\",\"common_operations\":[{\"name\":\"查找\",\"typical_usage\":\"数据库索引中根据主键或索引字段快速定位记录（如MySQL的InnoDB引擎非聚集索引）\"},{\"name\":\"插入\",\"typical_usage\":\"数据库插入新记录时，将关键字插入对应节点并维护树的平衡（如添加新用户记录到用户表的索引）\"},{\"name\":\"删除\",\"typical_usage\":\"数据库删除记录时，移除关键字并调整节点（如删除订单记录后更新订单号索引）\"},{\"name\":\"分裂节点\",\"typical_usage\":\"插入操作中节点关键字数达到2t-1时，将节点分裂为两个子节点，中间关键字提升至父节点以保持容量约束\"},{\"name\":\"合并节点\",\"typical_usage\":\"删除操作中节点关键字数低于t-1时，将节点与相邻兄弟节点合并，并从父节点下调一个关键字以满足最小容量要求\"}]}",
  "84a02357812d508cf37febab2ae22b5e": "{\"description\":\"红黑树（Red-Black Tree）是一种自平衡二叉搜索树（BST），通过为每个节点添加红色或黑色的颜色属性，并严格遵循5条平衡规则，保证树的高度始终为O(log n)，从而维持插入、删除和查找操作的高效性。\",\"storage_method\":\"采用链式存储结构，每个节点包含键（key）、值（value）、颜色（color，红/黑）、左子节点（left）、右子节点（right）和父节点（parent）字段；所有空叶子节点（NIL）被视为黑色哨兵节点，用于简化边界条件处理。\",\"properties\":\"红黑树的核心性质：1. 节点非红即黑；2. 根节点必为黑色；3. NIL空节点是黑色；4. 红节点的子节点必为黑色（无连续红节点）；5. 任意节点到其后代NIL节点的路径上，黑色节点数相同（黑高一致）。\",\"time_complexity\":{\"查找\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"插入\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"左旋\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"右旋\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"获取最小值\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"获取最大值\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"二叉搜索树（BST，红黑树的基础结构）\",\"AVL树（基于高度差的自平衡BST，红黑树的竞品结构）\",\"左旋/右旋算法（红黑树平衡调整的核心操作）\",\"插入后再平衡算法（Fix-Up Insertion，处理插入红色节点导致的连续红节点问题）\",\"删除后再平衡算法（Fix-Up Deletion，处理删除黑色节点导致的黑高减少问题）\",\"TreeSet/TreeMap（Java中基于红黑树的有序集合实现）\"],\"common_operations\":{\"查找\":{\"typical_usage\":\"在有序数据集合中根据键快速定位值，如数据库索引、字典查询等\"},\"插入\":{\"typical_usage\":\"向动态有序集合添加元素并维持平衡，如实时统计系统的数据插入\"},\"删除\":{\"typical_usage\":\"从有序集合移除元素并保持平衡，如缓存系统的淘汰策略辅助结构\"},\"左旋\":{\"typical_usage\":\"调整右子树过深的结构，修复插入/删除后的不平衡\"},\"右旋\":{\"typical_usage\":\"调整左子树过深的结构，修复插入/删除后的不平衡\"},\"获取最小值\":{\"typical_usage\":\"快速获取有序集合的最小元素，如TOP-K问题的起点查询\"},\"获取最大值\":{\"typical_usage\":\"快速获取有序集合的最大元素，如排行榜最高得分查询\"}}}",
  "ecf4fcf181d773508f0146f8341e7482": "{\"description\":\"树状数组（Fenwick Tree）是一种高效处理动态前缀和与单点更新的数据结构，由Peter Fenwick于1994年提出。它通过二进制分解将数组区间映射到树状结构的节点上，能够在对数时间内完成单点更新和前缀和查询，适用于需要频繁修改元素并查询区间和的场景\",\"storage_method\":\"使用一维数组存储，数组下标通常从1开始（利用二进制低位运算的便利性）。每个节点tree[i]对应原数组中某个区间的和，区间范围由i的lowbit值决定（即从i - lowbit(i) + 1到i）\",\"properties\":\"1. 基于二进制分解的区间表示：每个节点i的父节点为i - lowbit(i)，负责的区间是[i - lowbit(i) + 1, i]；2. 高效的动态操作：支持O(logn)时间的单点更新和前缀和查询；3. 空间高效：仅需与原数组大小相同的存储空间；4. 操作局限性：仅适用于满足结合律且可差分的二元操作（如加法、乘法，减法和除法需存在逆元）；5. 前缀和导向：核心功能是前缀和查询，区间查询需通过前缀和相减实现\",\"time_complexity\":{\"单点更新\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"},\"前缀和查询\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"},\"区间查询\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"},\"初始化\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":\"O(n)\",\"related_algorithms\":\"线段树、前缀和数组、lowbit运算、二进制索引技术\",\"common_operations\":[{\"name\":\"单点更新\",\"description\":\"修改原数组中指定位置的元素值，并更新树状数组中所有受影响的节点（即该位置所在的所有区间对应的节点）\",\"typical_usage\":\"动态维护数组元素的值，如统计系统中某个元素的出现次数（例如电商系统中商品库存的实时修改）\"},{\"name\":\"前缀和查询\",\"description\":\"计算原数组从起始位置（通常为1）到指定位置i的元素和\",\"typical_usage\":\"查询前i个元素的累加和，如计算班级前k名学生的总分、统计截止到某时间点的总销售额\"},{\"name\":\"区间查询\",\"description\":\"通过两次前缀和查询的差值（prefix_sum(r) - prefix_sum(l-1)）计算原数组中从位置l到r的元素和\",\"typical_usage\":\"查询数组某区间内的元素总和，如统计某个时间段内的订单总额、计算数组中某段区间的平均成绩\"},{\"name\":\"初始化\",\"description\":\"根据给定的原数组构建树状数组，将原数组的元素映射到树状数组的对应节点中\",\"typical_usage\":\"在数据预处理阶段初始化树状数组，以支持后续的动态查询和更新操作，如加载初始销售数据以构建库存管理的树状数组\"}]}",
  "566389592c5a1495fe0c77f54d9b67ea": "{\"description\":\"字典树（Trie，又称前缀树）是一种用于高效存储和检索字符串数据集中键的树形数据结构，其核心特点是利用字符串的共同前缀减少存储空间与查询时间。根节点代表空字符串，每个节点对应一个字符，从根到某节点的路径唯一对应一个字符串（前缀或完整字符串），节点通常包含子节点映射及是否为单词结尾的布尔标记。\",\"storage_method\":\"字典树通过层级节点结构存储，每个节点包含两部分：1）子节点映射（可通过数组、哈希表或指针数组实现，如小写字母对应长度为26的数组）；2）布尔标记（如isEnd）表示该节点是否为某字符串的结尾。根节点无字符，子节点对应字符串首字符，子节点的子节点对应次字符，依此类推形成字符串路径。\",\"properties\":[\"前缀共享性：所有相同前缀的字符串共享树中的前缀路径\",\"路径唯一性：根到任意节点的路径唯一对应一个字符串（前缀或完整字符串）\",\"节点标记性：节点通过布尔值标记是否为完整字符串的结尾\",\"字符集依赖性：子节点数量取决于字符集大小（如ASCII字符集对应128或256个子节点）\",\"无冲突性：不同字符串的路径仅在共享前缀时交叉\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(L)\",\"average_case\":\"O(L)\",\"worst_case\":\"O(L)\"},\"查找\":{\"best_case\":\"O(L)\",\"average_case\":\"O(L)\",\"worst_case\":\"O(L)\"},\"删除\":{\"best_case\":\"O(L)\",\"average_case\":\"O(L)\",\"worst_case\":\"O(L)\"},\"前缀查询\":{\"best_case\":\"O(L + K)\",\"average_case\":\"O(L + K)\",\"worst_case\":\"O(L + K)\"}},\"space_complexity\":{\"best_case\":\"O(L_max + N)\",\"average_case\":\"O(N*L_avg)\",\"worst_case\":\"O(N*L_max)\"},\"related_algorithms\":[\"AC自动机（Aho-Corasick Automaton，基于Trie扩展失效指针的多模式字符串匹配算法）\",\"最长前缀匹配算法（如IP路由中的前缀匹配）\",\"拼写检查算法\",\"自动补全算法\",\"单词频率统计算法\"],\"common_operations\":[{\"operation_name\":\"插入（Insert）\",\"description\":\"将字符串添加到字典树中，遍历字符串每个字符，依次创建或访问对应子节点，最后标记末尾节点的isEnd为true。\",\"typical_usage\":\"构建单词库、添加新字符串到数据集（如字典、通讯录用户名存储）\"},{\"operation_name\":\"查找（Search）\",\"description\":\"检查字符串是否存在于字典树中，遍历字符串每个字符，若中途无对应子节点则不存在；否则检查末尾节点的isEnd标记。\",\"typical_usage\":\"拼写检查（验证单词是否在词库中）、用户名唯一性验证\"},{\"operation_name\":\"删除（Delete）\",\"description\":\"从字典树中移除字符串，遍历找到末尾节点并清除其isEnd标记；若节点无其他子节点且不是其他单词的结尾，则递归删除父节点中的该子节点。\",\"typical_usage\":\"维护动态单词库（移除过时词汇）、处理用户注销后的用户名删除\"},{\"operation_name\":\"前缀查询（Prefix Query）\",\"description\":\"查找所有以给定前缀开头的字符串，先遍历前缀找到对应节点，再递归遍历该节点的所有子路径，收集完整字符串。\",\"typical_usage\":\"搜索引擎自动补全（如输入“app”返回“apple”“apply”）、文件系统的前缀文件名搜索\"}]}",
  "a1a215f276dc6c365073662789226b6f": "{\"description\":\"线段树（Segment Tree）是一种基于分治思想的二叉树数据结构，用于高效处理数组的区间查询（如求和、求最值等）和区间更新操作。每个节点代表数组的一个区间，叶子节点对应数组中的单个元素，内部节点存储对应区间的聚合信息（如和、最大值、最小值等），通过递归划分区间实现快速查询与更新\",\"storage_method\":\"通常采用数组存储（模拟完全二叉树），数组大小一般为原始数组长度的4倍（确保能容纳所有节点）；也可采用指针或对象构建的二叉树结构，但数组存储更高效且常用\",\"properties\":[\"完全二叉树结构（数组存储时），每个节点对应数组的一个区间\",\"父节点区间划分为两个等长（或近似等长）的子区间，左子节点对应左半区间，右子节点对应右半区间\",\"每个节点存储对应区间的聚合值（如和、最值等），由子节点聚合值合并得到\",\"支持O(logn)时间复杂度的区间查询和更新（结合懒标记可优化区间更新）\"],\"time_complexity\":{\"构建（build）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"区间查询（range_query）\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"},\"单点更新（point_update）\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"},\"区间更新（range_update，带懒标记）\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"}},\"space_complexity\":{\"best_case\":\"O(4n)\",\"average_case\":\"O(4n)\",\"worst_case\":\"O(4n)\"},\"related_algorithms\":[\"懒标记（Lazy Propagation）\",\"分治算法（Divide and Conquer）\",\"二叉索引树（Fenwick Tree）\",\"区间树（Interval Tree）\"],\"common_operations\":[{\"name\":\"构建线段树（build）\",\"description\":\"根据原始数组递归创建线段树，每个节点计算并存储对应区间的聚合值（如和、最值等）\",\"typical_usage\":\"初始化线段树以支持后续的查询和更新操作\"},{\"name\":\"区间查询（range_query）\",\"description\":\"递归查询指定区间[L, R]内的聚合值，通过分解查询区间为线段树中的节点区间并合并结果\",\"typical_usage\":\"求数组某区间的和、最大值、最小值等，如统计学生成绩区间的总分、找出某段时间的最高温度等\"},{\"name\":\"单点更新（point_update）\",\"description\":\"更新原始数组中单个元素的值，并递归更新线段树中所有包含该元素的节点的聚合值\",\"typical_usage\":\"修改数组中某个元素后维护线段树的正确性，如修改某学生的成绩后更新总分线段树\"},{\"name\":\"区间更新（range_update）\",\"description\":\"更新指定区间[L, R]内的所有元素（如统一加一个值、统一设置为某个值），通常结合懒标记（Lazy Propagation）优化以避免逐点更新的高时间复杂度\",\"typical_usage\":\"批量修改数组某区间的元素后维护线段树，如给某区间的学生成绩加5分、将某段时间的温度统一调整等\"}]}",
  "d3072844b87fafaba6cbd1237b6b213d": "{\"description\":\"后缀树（Suffix Tree）是一种用于高效表示字符串所有后缀的压缩树形数据结构，其每条边对应字符或字符区间，每个叶子节点对应原字符串的一个后缀，内部节点对应多个后缀的公共前缀；通过路径压缩和后缀链接（Suffix Link）优化空间与构建效率，支持快速解决子串查询、重复模式挖掘等问题\",\"storage_method\":\"采用基于节点（Node）和边（Edge）的树形结构存储，节点包含后缀链接（指向另一个内部节点以加速构建）、子节点指针（或字典映射字符到边）；边存储原字符串的字符区间（起始与结束索引）实现路径压缩，避免冗余字符存储；叶子节点额外记录对应后缀的起始位置\",\"properties\":[\"压缩性：通过边的字符区间压缩重复路径，减少冗余后缀存储\",\"后缀覆盖：所有叶子节点的路径对应原字符串的全部后缀\",\"公共前缀性：内部节点的路径对应多个后缀的最长公共前缀\",\"后缀链接：内部节点的后缀链接指向其路径去掉首字符后的对应节点，加速构建与查询\",\"线性空间：优化构建算法（如Ukkonen）可将空间复杂度降至O(n)（n为原字符串长度）\"],\"time_complexity\":{\"构建\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"查询子串存在\":{\"best_case\":\"O(m)\",\"average_case\":\"O(m)\",\"worst_case\":\"O(m)\"},\"查询子串出现次数\":{\"best_case\":\"O(m)\",\"average_case\":\"O(m + k)\",\"worst_case\":\"O(m + k)\"},\"查询最长重复子串\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"查询最长公共子串（两字符串）\":{\"best_case\":\"O(n1 + n2)\",\"average_case\":\"O(n1 + n2)\",\"worst_case\":\"O(n1 + n2)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"Ukkonen算法（线性时间构建后缀树）\",\"Weiner算法（首个线性时间构建算法）\",\"McCreight算法（线性时间构建，基于后缀链接）\",\"后缀数组（Suffix Array，与后缀树等价的线性空间结构）\",\"最长公共子串算法（基于后缀树的两字符串公共子串查询）\",\"重复模式挖掘算法（如最长重复子串查找）\"],\"common_operations\":[{\"name\":\"构建后缀树\",\"description\":\"根据输入字符串生成对应的后缀树结构，通常采用线性时间算法（如Ukkonen）实现\",\"typical_usage\":\"预处理文本以支持后续高效查询（如搜索引擎的文本索引、生物信息学中的基因序列分析）\"},{\"name\":\"查询子串是否存在\",\"description\":\"检查目标子串是否为原字符串的子串，通过沿后缀树路径匹配字符实现\",\"typical_usage\":\"文本搜索（如查找文档中是否包含某个关键词）、拼写检查中的前缀匹配\"},{\"name\":\"查询子串出现次数\",\"description\":\"统计目标子串在原字符串中的出现次数，通过找到对应内部节点并计算其子树叶子节点数量实现\",\"typical_usage\":\"词频统计（如统计文本中某个词的出现次数）、生物序列中的motif频率分析\"},{\"name\":\"查询最长重复子串\",\"description\":\"找到原字符串中最长的重复出现的子串，通过遍历后缀树内部节点并计算路径长度最大值实现\",\"typical_usage\":\"重复内容检测（如论文查重中的长重复片段识别）、数据压缩中的重复模式挖掘\"},{\"name\":\"查询最长公共子串\",\"description\":\"找到两个或多个字符串的最长公共子串，通过构建合并后的后缀树（如添加特殊字符连接字符串）并查找最深公共内部节点实现\",\"typical_usage\":\"文本相似度比较（如文档去重、plagiarism检测）、生物信息学中的同源序列分析（如基因序列的相似区域查找）\"}]}",
  "bcceb1c2a320f0d0cb047b63a2c2e312": "{\"description\":\"跳跃表（Skip List）是一种基于多层链表实现的有序数据结构，通过在底层完整有序链表之上构建稀疏索引层，实现近似二分查找的高效操作。它由William Pugh于1989年提出，作为平衡二叉搜索树的概率性替代方案，避免了复杂的平衡调整操作。\",\"storage_method\":\"采用节点数组或链表结构存储，每个节点包含多个指向不同层级下一个节点的指针（称为“forward指针”）。底层是完整的有序链表（层级0），上层为稀疏索引层（层级≥1），层级越高链表越稀疏，顶层索引提供最快的查找路径。\",\"properties\":[\"有序性：所有节点按键值严格有序排列\",\"分层结构：由多层链表组成，底层为完整数据层，上层为索引层\",\"概率性平衡：通过随机算法决定新节点的层级（通常以1/2的概率提升层级），期望保持结构平衡\",\"动态性：支持动态插入、删除操作，无需全局重建结构\",\"高效性：期望时间复杂度与平衡树相当，但实现更简单\"],\"time_complexity\":{\"查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"},\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"},\"删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"},\"获取前驱\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"},\"获取后继\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n log n)\"},\"related_algorithms\":[\"平衡二叉搜索树（如AVL树、红黑树）\",\"有序链表\",\"二分查找算法\",\"哈希表（动态数据结构对比）\",\"跳表排序（基于跳跃表的排序算法）\"],\"common_operations\":{\"查找（Search）\":{\"typical_usage\":\"在有序集合中快速定位指定键对应的节点，例如数据库索引、缓存系统中的键值查询\"},\"插入（Insert）\":{\"typical_usage\":\"向有序集合中添加新元素并保持有序性，例如实时数据采集系统中的动态数据插入\"},\"删除（Delete）\":{\"typical_usage\":\"从有序集合中移除指定元素，例如缓存淘汰策略（如LRU）中的数据删除\"},\"获取前驱（Get Predecessor）\":{\"typical_usage\":\"查找比指定键小的最大键对应的节点，例如范围查询中的左边界确定\"},\"获取后继（Get Successor）\":{\"typical_usage\":\"查找比指定键大的最小键对应的节点，例如范围查询中的右边界确定\"},\"范围查询（Range Query）\":{\"typical_usage\":\"查找键值在指定区间内的所有节点，例如数据库中的区间查询（如“查询分数在80-90之间的学生”）\"}}}}",
  "c087a25ea31a689bb8c76f6301b91a3a": "{\"description\":\"前缀树（Trie）是一种用于高效存储和检索字符串集合的树形数据结构，核心特点是利用字符串的公共前缀共享存储空间。每个节点代表一个字符，从根节点到某一节点的路径对应一个字符串的前缀，节点通过布尔标记（如is_end）指示是否为某字符串的结尾。\",\"storage_method\":\"前缀树通过节点结构存储，每个节点包含两部分：1. 子节点集合（固定字符集常用数组实现，如小写字母用大小26的数组；任意字符集常用哈希表实现）；2. 布尔值标记（is_end）表示当前节点是否为字符串的结束位置。根节点不存储实际字符，作为所有字符串的起始点。\",\"properties\":[\"根节点无实际字符，仅作为路径起点\",\"每个节点的子节点对应不同字符，确保路径唯一性\",\"从根到节点的路径唯一对应一个字符串前缀\",\"字符串的完整性由节点的is_end标记决定\",\"公共前缀的字符串共享路径上的节点，减少存储空间\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"查找\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"删除\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"前缀查询\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"}},\"space_complexity\":{\"best_case\":\"O(k)\",\"average_case\":\"O(n×k_avg)\",\"worst_case\":\"O(n×k_max)\"},\"related_algorithms\":[\"字符串自动补全算法（Autocomplete）\",\"拼写检查算法（Spell Checker）\",\"前缀匹配算法（Prefix Matching）\",\"单词频率统计算法\",\"IP路由表查找算法（Trie优化场景）\"],\"common_operations\":[{\"name\":\"插入\",\"description\":\"遍历字符串的每个字符，依次创建或访问节点对应的子节点，最后将末尾节点标记为字符串结束位置。\",\"typical_usage\":\"构建词库、字典等字符串集合的前缀树索引，如搜索引擎的关键词库存储\"},{\"name\":\"查找\",\"description\":\"遍历字符串的每个字符，检查对应子节点是否存在；若路径完整且末尾节点标记为结束，则字符串存在。\",\"typical_usage\":\"验证字符串是否在集合中，如密码验证、文本编辑器的关键词检测\"},{\"name\":\"删除\",\"description\":\"找到字符串末尾节点，取消其结束标记；若节点无其他子节点，则向上回溯删除所有无意义的父节点（即无其他子节点且非结束节点的节点）。\",\"typical_usage\":\"更新字符串集合，如词库中移除过时词汇、用户删除自定义短语\"},{\"name\":\"前缀查询\",\"description\":\"先找到前缀对应的节点，再遍历该节点的所有子树，收集所有以该前缀开头的完整字符串。\",\"typical_usage\":\"搜索引擎的输入提示、手机输入法的联想词推荐、文档编辑器的关键词补全\"}],\"time_complexity_note\":\"k为操作涉及的字符串长度；space_complexity中k为相同字符串长度，n为字符串数量，k_avg为平均长度，k_max为最长字符串长度\"}",
  "308f8010dd5b40d487c0564565dcada6": "{\"description\":\"并查集（Disjoint Set Union, DSU）是一种用于高效处理动态连通性问题的树型数据结构，通过维护元素之间的父子关系表示集合，支持快速的集合合并与元素所属集合查询操作，核心优化策略为路径压缩和按秩/大小合并。\",\"storage_method\":\"通常使用两个数组存储：1. 父数组（parent array）：索引对应元素，值为该元素的父节点；2. 秩数组（rank array）或大小数组（size array）：记录树的高度（秩）或大小，用于合并时优化树结构。\",\"properties\":\"1. 动态连通性：支持动态合并集合与查询元素连通性；2. 路径压缩：查找操作时扁平化树结构，将路径上的节点直接指向根，降低后续查询成本；3. 按秩/大小合并：合并时将较浅/较小的树合并到较深/较大的树中，保持树的高度趋近于常数；4. 根节点唯一性：每个集合由唯一的根节点代表，根节点的父节点是自身。\",\"time_complexity\":{\"查找（Find）\":{\"best_case\":\"O(1)\",\"average_case\":\"α(n)\",\"worst_case\":\"α(n)\"},\"合并（Union）\":{\"best_case\":\"O(1)\",\"average_case\":\"α(n)\",\"worst_case\":\"α(n)\"},\"初始化（Initialize）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":\"O(n)，其中n为元素总数，需存储父数组和秩/大小数组（各占O(n)空间）。\",\"related_algorithms\":\"1. Kruskal算法：求解最小生成树时，用并查集判断边是否连接不同集合；2. 连通分量计数：统计图中连通分量数量，合并边时更新集合；3. 等价类划分：处理等价关系（如等价命题、连通关系）的集合划分问题；4. 离线动态连通性问题：处理批量的合并与查询操作。\",\"common_operations\":[{\"name\":\"初始化（Initialize）\",\"description\":\"为每个元素创建独立集合，父数组中每个元素的父节点设为自身，秩/大小数组初始化为1。\",\"typical_usage\":\"算法开始前初始化并查集，为后续的合并、查询操作准备数据结构。\"},{\"name\":\"查找（Find）\",\"description\":\"递归或迭代查找元素的根节点，过程中对路径上的所有节点执行路径压缩（直接指向根），优化后续查找效率。\",\"typical_usage\":\"判断两个元素是否连通（比较根节点是否相同）、获取元素所属集合的标识。\"},{\"name\":\"合并（Union）\",\"description\":\"找到两个元素的根节点，若根不同则按秩/大小合并（将较浅/较小的树合并到较深/较大的树的根下），更新秩/大小数组。\",\"typical_usage\":\"合并两个不连通的集合（如Kruskal算法中添加边时合并两个顶点的集合）、扩展连通区域。\"},{\"name\":\"查询连通性（IsConnected）\",\"description\":\"通过两次查找操作比较两个元素的根节点是否相同，判断是否属于同一集合。\",\"typical_usage\":\"Kruskal算法中判断边是否形成环（两点已连通则跳过）、图论中判断两点可达性。\"}]}",
  "f70f076782f675d78d4a460e13adf3de": "{\"description\":\"布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于快速判断一个元素是否属于某个集合。它通过多个独立哈希函数将元素映射到位数组的多个位置并置1，查询时检查这些位置是否全为1；其特点是存在假阳性（误判元素存在）但无假阴性（不会漏判存在的元素），且不支持元素删除（除非使用变种如计数布隆过滤器）\",\"storage_method\":\"使用固定大小的位数组（bit array）作为底层存储，结合多个独立哈希函数，每个哈希函数将输入元素映射到位数组的一个索引位置\",\"properties\":[\"概率准确性：存在假阳性错误（False Positive）但无假阴性错误（False Negative）\",\"空间高效：通过位数组存储大幅节省空间，远优于传统集合结构\",\"默认不可删除：标准实现不支持元素删除，因删除可能破坏其他元素的哈希位置\",\"哈希依赖性：哈希函数的独立性和分布均匀性直接影响假阳性率\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"查询\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"}},\"space_complexity\":{\"best_case\":\"O(m)\",\"average_case\":\"O(m)\",\"worst_case\":\"O(m)\"},\"related_algorithms\":[\"计数布隆过滤器（Counting Bloom Filter，支持删除）\",\"布谷鸟哈希（Cuckoo Hashing，概率型哈希结构）\",\"MurmurHash（常用高效哈希函数）\",\"SHA系列哈希函数（部分场景使用）\"],\"common_operations\":[{\"operation_name\":\"插入（add）\",\"description\":\"将元素加入布隆过滤器：通过所有哈希函数计算元素对应的位索引，将这些位置的bit置为1\",\"typical_usage\":\"URL去重（如爬虫标记已爬取的URL）、缓存预热时记录已加载的键\"},{\"operation_name\":\"查询（contains）\",\"description\":\"判断元素是否属于集合：通过所有哈希函数计算位索引，检查这些位置是否全为1；全1则可能存在（假阳性），有0则肯定不存在\",\"typical_usage\":\"缓存穿透防护（如Redis缓存前检查不存在的键）、HBase中行键的存在性预检查\"}]}",
  "be315a62193810735a4f4bb45f556c4f": "{\"description\":\"AC自动机（Aho-Corasick Automaton）是一种高效的多模式串匹配数据结构，基于Trie树扩展而来，通过为每个节点添加失败指针（类似KMP算法的部分匹配表）和输出指针，实现一次线性扫描文本即可找出所有模式串的出现位置，适用于需要同时匹配多个模式的场景（如敏感词过滤、日志分析等）。\",\"storage_method\":\"以Trie树为基础存储结构，每个节点包含三部分核心信息：1. 子节点映射（通常用固定大小数组或哈希表，键为字符，值为子节点指针，字符集大小为Σ时数组更高效）；2. 失败指针（Failure Link）：指向当前节点的最长真后缀（Longest Proper Suffix）对应的Trie节点，用于不匹配时快速跳转；3. 输出指针（Output Link）：指向当前节点匹配的模式串或后续匹配的模式串链表，用于收集所有匹配结果。\",\"properties\":\"1. 多模式串支持：可同时处理任意数量的模式串；2. 预处理-在线匹配分离：预处理阶段构建Trie树和失败指针（时间复杂度O(m)，m为所有模式串长度之和），匹配阶段线性扫描文本（时间复杂度O(n + z)，n为文本长度，z为匹配结果总数）；3. 无回溯匹配：匹配时仅需按文本顺序遍历，通过失败指针避免回溯；4. 全局匹配收集：通过输出指针收集所有以当前节点为结尾的模式串，确保不遗漏匹配。\",\"time_complexity\":{\"构建（Trie+失败指针）\":{\"best_case\":\"O(m)\",\"average_case\":\"O(m)\",\"worst_case\":\"O(m)\"},\"多模式匹配\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n + z)\",\"worst_case\":\"O(n + z)\"}},\"space_complexity\":{\"best_case\":\"O(m)\",\"average_case\":\"O(m * Σ)\",\"worst_case\":\"O(m * Σ)\"},\"related_algorithms\":[\"KMP算法（单模式串匹配，失败指针的思想来源，通过部分匹配表避免回溯）\",\"Trie树（前缀树基础结构，AC自动机的底层存储）\",\"广度优先搜索（BFS，用于按层构建失败指针，保证节点处理顺序的正确性）\"],\"common_operations\":[{\"operation_name\":\"build_trie\",\"description\":\"将所有模式串插入Trie树，构建前缀树结构：每个模式串的字符依次作为节点路径，结尾节点标记为模式串的终止点。\",\"typical_usage\":\"预处理阶段将多个模式串组织成Trie树，为后续失败指针构建和匹配提供基础结构，例如将敏感词库导入Trie。\"},{\"operation_name\":\"build_failure_links\",\"description\":\"通过BFS遍历Trie树，为每个节点计算失败指针：根节点的失败指针为null，根的子节点失败指针指向根；其他节点的失败指针由父节点的失败指针推导（若父节点的失败指针有当前字符的子节点，则指向该子节点，否则递归查找失败指针的失败指针）。\",\"typical_usage\":\"预处理阶段构建失败指针，解决匹配时的不匹配跳转问题，例如为敏感词Trie树添加失败指针以支持快速匹配。\"},{\"operation_name\":\"multi_pattern_match\",\"description\":\"线性扫描文本，从Trie树根节点开始，根据当前字符转移至子节点；若无法转移则通过失败指针跳转，直到根节点或找到可转移节点；每到达一个节点，通过输出指针收集所有匹配的模式串及其位置。\",\"typical_usage\":\"在线匹配阶段处理输入文本，找出所有模式串的出现位置，例如在聊天记录中扫描所有敏感词并标记。\"}]}",
  "ccc85f7dce0eaf0ebfa3f1936c41064c": "{\"description\":\"二项堆是一种基于二项树（Binomial Tree）结构的优先级队列数据结构，由一组满足\\\"无两个二项树度数相同\\\"的堆有序二项树构成，支持高效的合并操作，是斐波那契堆的基础\",\"storage_method\":\"通常通过链表或动态数组存储所有二项树的根节点（按度数从小到大排序），每个二项树节点包含键值、父节点指针、子节点指针（指向最左边的子节点）、右兄弟指针（指向同父节点的下一个兄弟节点）及度数（子节点数量）\",\"properties\":[\"堆有序性：每个二项树中的父节点键值不大于其子节点键值（最小堆，或反之最大堆）\",\"度数唯一性：二项堆中任意两个二项树的度数不同\",\"结构特性：度数为k的二项树B_k由两个度数为k-1的二项树B_{k-1}合并而成（根节点较小的树成为另一棵树的根节点的子树）\",\"节点数：度数为k的二项树有2^k个节点，高度为k\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"合并\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"提取最小\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"减少键值\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":\"O(n)\",\"related_algorithms\":[\"Dijkstra算法（二项堆优化单源最短路径）\",\"Prim算法（二项堆优化最小生成树）\",\"斐波那契堆（二项堆的扩展，提供更优摊还时间复杂度）\"],\"common_operations\":[{\"name\":\"插入\",\"description\":\"将一个新元素添加到二项堆中，通过创建度数为0的二项树（单节点）并与原堆合并实现\",\"typical_usage\":\"向优先级队列中添加任务\"},{\"name\":\"合并\",\"description\":\"将两个二项堆合并为一个新的二项堆，通过合并根链表并处理相同度数的树来维持二项堆性质\",\"typical_usage\":\"合并两个优先级队列（如任务池合并）\"},{\"name\":\"提取最小\",\"description\":\"找到并移除二项堆中的最小元素（最小堆），通过遍历根链表找到最小根，移除后将其子树合并回根链表\",\"typical_usage\":\"优先级队列中获取最高优先级任务（如调度器取最紧急任务）\"},{\"name\":\"减少键值\",\"description\":\"降低指定元素的键值，并调整其在堆中的位置以维持堆有序性（沿父链向上交换直到父节点键值更小）\",\"typical_usage\":\"更新优先级队列中元素的优先级（如任务紧急程度提升）\"},{\"name\":\"删除\",\"description\":\"移除二项堆中的指定元素，通过先将其键值减少到负无穷（最小堆中最小值），再执行提取最小操作实现\",\"typical_usage\":\"从优先级队列中删除特定任务\"}]}",
  "42f03c251533e85278112235388b4782": "{\"description\":\"斐波那契堆（Fibonacci Heap）是一种高效的优先队列数据结构，结合了二叉堆的堆序性与二项堆的树结构特性，通过**延迟操作**（懒惰合并、懒惰删除）优化合并、插入等操作的渐近时间复杂度，主要用于降低依赖优先队列的算法（如最短路径、最小生成树）的整体时间复杂度。其核心设计目标是将高频操作（如插入、合并、减少关键字）的摊还时间复杂度优化到常数级，仅在低频的抽取最小值等操作中进行必要的结构整理。\",\"storage_method\":\"斐波那契堆由**满足最小堆性质（或最大堆性质，通常默认最小堆）的树森林**构成，每个树是无序的多叉树（称为“斐波那契树”）。存储结构包含：1. **树根双向循环链表**：维护所有树的根节点，支持O(1)合并；2. **节点指针**：每个节点包含指向父节点（parent）、子节点（child）、左兄弟（left）、右兄弟（right）的指针；3. **节点属性**：每个节点存储度数（degree，即子节点数量）、标记位（mark，记录该节点是否在成为父节点后失去过子节点）；4. **全局最小指针**：直接指向树根链表中的最小节点，支持O(1)查找最小值。\",\"properties\":[\"1. 堆序性：所有树均满足最小堆性质（根节点关键字≤子节点关键字）；\",\"2. 延迟操作：合并、插入、减少关键字等操作仅修改指针或标记，推迟树的结构整理（如合并相同度数的树）到抽取最小值时执行；\",\"3. 度数约束：每个节点的度数k满足“该节点至少包含F_{k+2}个节点”（F为斐波那契数），因此节点度数上限为O(log n)，保证树的高度较低；\",\"4. 标记机制：用于处理decrease-key操作中的“cut”（切断子节点与父节点的连接），避免树结构退化；\",\"5. 树根链表：双向循环链表结构使合并两个斐波那契堆的时间复杂度为O(1)。\"],\"time_complexity\":{\"插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"合并\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"查找最小值\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"抽取最小值\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"减少关键字\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(log n)\"},\"删除\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":\"O(n)，其中n为斐波那契堆中的元素总数。每个节点需存储数据、4个指针（父、子、左、右）、度数（整数）和标记位（布尔值），总空间与节点数线性相关。\",\"related_algorithms\":[\"Dijkstra最短路径算法（用斐波那契堆优化后时间复杂度为O(m + n log n)，优于二叉堆的O(m log n)）\",\"Prim最小生成树算法（优化后时间复杂度O(m + n log n)）\",\"二项堆（Binomial Heap，斐波那契堆的设计基础，斐波那契堆通过延迟操作进一步优化了二项堆的合并/插入效率）\"],\"common_operations\":{\"插入\":{\"typical_usage\":\"向优先队列中添加新元素，如Dijkstra算法中发现未访问的节点时将其加入队列\"},\"合并\":{\"typical_usage\":\"合并两个优先队列，如分治算法中合并子问题的优先队列结果\"},\"查找最小值\":{\"typical_usage\":\"快速获取当前优先队列中的最小元素，如Prim算法中选择下一个加入生成树的边\"},\"抽取最小值\":{\"typical_usage\":\"取出并移除最小元素，如Dijkstra算法中确定当前最短路径的节点并扩展其邻接节点\"},\"减少关键字\":{\"typical_usage\":\"更新优先队列中元素的优先级，如Dijkstra算法中发现更短的路径时降低对应节点的距离值\"},\"删除\":{\"typical_usage\":\"从优先队列中移除指定元素，如动态调整优先队列中的元素（如某些调度系统中取消任务）\"}}}}",
  "b68e60b46e4e98f22673711575f07a43": "{\n    \"description\": \"循环队列是一种基于数组或链表实现的线性队列结构，通过将队列首尾逻辑相连形成环形，解决普通顺序队列的\\\"假溢出\\\"问题（即队尾指针到达数组末尾但队首仍有空闲空间时无法插入的问题），核心遵循先进先出（FIFO）原则，常用于需要高效空间利用的缓冲区或任务调度场景。\",\n    \"storage_method\": \"主要采用顺序存储（固定大小数组）实现，通过模运算使指针循环移动；也可通过链表实现链式循环队列（每个节点包含数据域和指针域，尾节点指针指向头节点），无需预先分配固定空间。\",\n    \"properties\": [\n        \"逻辑上为环形结构，队首（front）和队尾（rear）指针通过模运算（%容量）循环移动\",\n        \"解决普通顺序队列的假溢出问题，提高空间利用率\",\n        \"需通过牺牲一个存储空间（(rear+1)%capacity == front）或维护计数器来区分队列空满状态\",\n        \"保持队列先进先出（FIFO）的核心特性\",\n        \"顺序实现时空间固定，链式实现时可动态扩展\"\n    ],\n    \"time_complexity\": {\n        \"初始化（initialize）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\n        \"入队（enqueue）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\n        \"出队（dequeue）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\n        \"获取队首元素（get_front）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\n        \"判断队列空（is_empty）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\n        \"判断队列满（is_full）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"}\n    },\n    \"space_complexity\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"},\n    \"related_algorithms\": \"普通队列操作算法、生产者-消费者问题同步控制算法、广度优先搜索（BFS）队列优化算法、环形缓冲区管理算法、操作系统进程调度队列算法\",\n    \"common_operations\": [\n        {\n            \"name\": \"初始化（initialize）\",\n            \"description\": \"创建空循环队列，初始化队首指针front、队尾指针rear（通常为0）及队列最大容量，若为链式实现则初始化头节点和尾节点指针\",\n            \"typical_usage\": \"使用循环队列前的准备工作，如创建网络数据缓冲区、任务调度队列或BFS的待访问节点队列\"\n        },\n        {\n            \"name\": \"入队（enqueue）\",\n            \"description\": \"将元素插入队尾：顺序实现时若队列未满，执行rear = (rear + 1) % capacity并存储元素；链式实现时创建新节点并连接到尾节点后，更新尾节点指针\",\n            \"typical_usage\": \"生产者向缓冲区添加数据、任务系统接收新任务、BFS中添加待访问的邻接节点\"\n        },\n        {\n            \"name\": \"出队（dequeue）\",\n            \"description\": \"移除并返回队首元素：顺序实现时若队列未空，执行front = (front + 1) % capacity并返回原front位置元素；链式实现时移除头节点并更新头节点指针\",\n            \"typical_usage\": \"消费者从缓冲区取出数据、任务系统执行队首任务、BFS中取出当前节点进行邻接节点遍历\"\n        },\n        {\n            \"name\": \"获取队首元素（get_front）\",\n            \"description\": \"返回队首元素但不移除，顺序实现时直接访问front位置元素，链式实现时访问头节点数据\",\n            \"typical_usage\": \"查看缓冲区头部待处理数据、检查任务队列的首个任务内容、BFS中预览下一个待处理节点\"\n        },\n        {\n            \"name\": \"判断队列空（is_empty）\",\n            \"description\": \"判断队列是否为空：顺序实现通常通过front == rear（结合空满策略），链式实现通过头节点是否为null或front == rear\",\n            \"typical_usage\": \"消费者检查缓冲区是否无数据需等待、任务系统判断是否无任务可执行、BFS判断是否遍历完成\"\n        },\n        {\n            \"name\": \"判断队列满（is_full）\",\n            \"description\": \"判断队列是否已满：顺序实现通过(rear + 1) % capacity == front（牺牲一个空间策略）或计数器等于容量；链式实现通常无需判断满（可动态扩展）\",\n            \"typical_usage\": \"生产者检查缓冲区是否已满需停止添加、任务系统判断是否拒绝新任务、避免顺序队列溢出\"\n        }\n    ]\n}",
  "1bea5616ea9d75d3f52cf9aeba2273cd": "{\"description\":\"二叉堆（Binary Heap）是一种基于完全二叉树的数据结构，分为最大堆和最小堆两种类型。最大堆中每个父节点的值大于等于其子节点的值，根节点为最大值；最小堆中每个父节点的值小于等于其子节点的值，根节点为最小值。二叉堆常用于实现优先队列，支持高效的极值访问和更新操作。\",\"storage_method\":\"通常采用数组存储，利用完全二叉树的索引特性快速计算父子节点位置：若数组索引从0开始，父节点i的左子节点为2i+1、右子节点为2i+2；若索引从1开始，左子节点为2i、右子节点为2i+1。无需额外存储指针，空间利用率高。\",\"properties\":\"1. 结构特性：完全二叉树，即除最后一层外每一层都被填满，最后一层的节点靠左排列；2. 堆序特性：最大堆（父节点值≥子节点值）或最小堆（父节点值≤子节点值）；3. 极值特性：根节点是堆中的最大值（最大堆）或最小值（最小堆）；4. 动态维护性：插入或删除元素后需通过堆化操作（上浮/下沉）恢复堆序。\",\"time_complexity\":{\"插入（Insert）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除极值（Extract Min/Max）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"构建堆（Build Heap）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"获取极值（Get Min/Max）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"堆化（Heapify）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":\"优先队列（Priority Queue）、堆排序（Heap Sort）、Dijkstra最短路径算法（优先队列优化）、Prim最小生成树算法（优先队列优化）\",\"common_operations\":[{\"operation_name\":\"插入（Insert）\",\"description\":\"将新元素添加到堆的末尾，然后通过上浮操作（Sift Up）调整其位置，以维持堆序特性。\",\"typical_usage\":\"向优先队列中添加新的任务或元素，如任务调度系统中新增待处理任务。\"},{\"operation_name\":\"删除极值（Extract Min/Max）\",\"description\":\"移除并返回堆的根节点（极值），将堆的最后一个元素移动到根节点位置，然后通过下沉操作（Sift Down）调整其位置，维持堆序特性。\",\"typical_usage\":\"从优先队列中取出优先级最高的元素，如任务调度系统中执行优先级最高的任务。\"},{\"operation_name\":\"构建堆（Build Heap）\",\"description\":\"将无序数组转换为满足堆序特性的完全二叉树，通常从最后一个非叶节点开始依次进行下沉操作。\",\"typical_usage\":\"初始化优先队列或堆排序算法的预处理步骤，将输入数组转换为堆结构。\"},{\"operation_name\":\"获取极值（Get Min/Max）\",\"description\":\"直接返回堆的根节点元素，不修改堆结构。\",\"typical_usage\":\"查看优先队列中优先级最高的元素而不取出，如查询系统中当前最紧急的任务。\"},{\"operation_name\":\"堆化（Heapify）\",\"description\":\"分为上浮（Sift Up，处理插入操作后恢复堆序）和下沉（Sift Down，处理删除操作或构建堆时恢复堆序），调整节点位置以满足堆序特性。\",\"typical_usage\":\"插入或删除元素后修复堆结构，或构建堆时调整数组元素顺序。\"}]}",
  "5f2fa418551a42dc6f61b97e37af4dec": "{\"description\":\"双端队列（Double-Ended Queue，简称Deque）是一种线性数据结构，允许在队列的两端（队首和队尾）进行插入（入队）和删除（出队）操作，结合了栈（仅一端操作）和队列（先进先出）的特性，可灵活作为栈或队列使用\",\"storage_method\":\"常见实现方式有两种：1. 基于循环数组：使用固定大小数组，通过维护头/尾指针处理两端操作，需解决边界溢出问题；2. 基于双向链表：每个节点含前驱/后继指针，支持动态扩展，无需预分配空间\",\"properties\":[\"双向操作性：队首和队尾均可执行插入、删除操作\",\"顺序性：元素保持插入时的相对顺序\",\"可变性：链表实现支持动态调整大小，数组实现为固定大小\",\"访问特性：数组与链表实现均支持O(1)时间访问首尾元素，中间元素访问需O(n)时间\",\"无优先级：元素按插入顺序处理，无内置优先级机制\"],\"time_complexity\":{\"push_front\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"push_back\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"pop_front\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"pop_back\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"front\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"back\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"isEmpty\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"size\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"traverse\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"滑动窗口最大值算法（用双端队列维护窗口内最大值候选）\",\"单调队列（用于高效解决范围最值查询问题）\",\"表达式求值（结合栈的特性处理运算符优先级）\"],\"common_operations\":[{\"name\":\"push_front\",\"description\":\"在队首插入一个元素\",\"typical_usage\":\"需要在序列头部快速添加元素的场景，如实现栈的压栈操作或构建反转序列\"},{\"name\":\"push_back\",\"description\":\"在队尾插入一个元素\",\"typical_usage\":\"需要在序列尾部添加元素的常规场景，如实现普通队列的入队操作\"},{\"name\":\"pop_front\",\"description\":\"删除并返回队首元素\",\"typical_usage\":\"需要移除序列头部元素的场景，如实现队列的出队操作或处理前置优先级元素\"},{\"name\":\"pop_back\",\"description\":\"删除并返回队尾元素\",\"typical_usage\":\"需要移除序列尾部元素的场景，如实现栈的弹栈操作或撤销最后添加的元素\"},{\"name\":\"front\",\"description\":\"获取队首元素（不删除）\",\"typical_usage\":\"需要查看头部元素而不修改结构的场景，如检查队列下一个处理对象\"},{\"name\":\"back\",\"description\":\"获取队尾元素（不删除）\",\"typical_usage\":\"需要查看尾部元素而不修改结构的场景，如检查最后添加的元素状态\"},{\"name\":\"isEmpty\",\"description\":\"判断队列是否为空\",\"typical_usage\":\"操作前检查状态，避免空操作或越界错误（如删除空队列元素）\"},{\"name\":\"size\",\"description\":\"获取队列元素数量\",\"typical_usage\":\"需要统计元素总数的场景，如限制队列大小或监控资源使用情况\"},{\"name\":\"traverse\",\"description\":\"遍历队列所有元素\",\"typical_usage\":\"需要访问所有元素的场景，如打印队列内容或批量数据处理\"}]}",
  "c8df9e562927276ccef3a507c0b13e05": "{\"description\":\"LRU（Least Recently Used，最近最少使用）缓存是一种基于\\\"最近最少使用\\\"策略的缓存淘汰机制，当缓存容量达到上限时，优先移除最近一段时间内未被访问的元素。其核心目标是通过保留近期高频访问的数据来提高系统性能，广泛应用于数据库缓存、浏览器资源缓存、分布式缓存（如Redis的LRU策略）等场景。\",\"storage_method\":\"通常采用**哈希表（Hash Map）+ 双向链表（Doubly Linked List）**的组合实现：哈希表用于快速定位元素（键到链表节点的O(1)映射），双向链表用于维护元素的访问顺序（链表头部为最近使用的元素，尾部为最少使用的元素）。每个链表节点存储键、值及前后指针，哈希表存储键与链表节点的对应关系，确保查找、插入、删除操作的高效性。\",\"properties\":[\"淘汰策略：基于\\\"最近最少使用\\\"原则，未被访问时间最久的元素优先被淘汰\",\"时间效率：get（获取）和put（插入/更新）操作的时间复杂度均为O(1)（依赖哈希表的快速查找和双向链表的O(1)插入/删除）\",\"顺序维护：通过将访问或更新的元素移动到链表头部，将淘汰的元素从链表尾部移除，动态维护访问顺序\",\"空间开销：需额外存储双向链表的指针和哈希表的映射关系，空间复杂度与缓存容量线性相关\",\"容量限制：必须预先指定固定容量，当元素数量超过容量时自动触发淘汰逻辑\"],\"time_complexity\":{\"get（获取元素）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"put（插入/更新元素）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"evict（淘汰最少使用元素）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"move_to_head（标记为最近使用）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"LFU（最不经常使用缓存算法）\",\"FIFO（先进先出缓存算法）\",\"哈希表冲突解决算法（如链式哈希）\",\"双向链表节点操作算法（插入、删除、移动）\"],\"common_operations\":[{\"name\":\"get\",\"description\":\"根据键获取缓存中的值，若键存在则将对应的链表节点移动到头部（标记为最近使用），若不存在则返回空或默认值\",\"typical_usage\":\"浏览器缓存中查询之前访问过的图片、CSS样式表等静态资源，数据库缓存中获取近期查询的用户信息结果集\"},{\"name\":\"put\",\"description\":\"根据键插入或更新缓存中的值：若键已存在，更新对应节点的值并移动到链表头部；若键不存在，创建新节点插入链表头部，若缓存已满则删除链表尾部节点（淘汰最少使用元素）\",\"typical_usage\":\"将新访问的网页HTML内容加入浏览器缓存，将数据库查询的商品信息结果存入缓存以避免重复查询\"},{\"name\":\"evict\",\"description\":\"当缓存容量达到上限时，删除双向链表尾部的节点（最少使用的元素），并从哈希表中移除对应的键值对\",\"typical_usage\":\"图片服务器缓存满时删除最久未访问的图片资源，分布式缓存（如Redis）容量不足时清理 oldest 的键值对\"},{\"name\":\"move_to_head\",\"description\":\"将指定的双向链表节点从原位置移除并插入到链表头部，以标记该元素为最近使用\",\"typical_usage\":\"执行get或put操作时触发，确保最近访问的元素不会被优先淘汰，例如用户再次访问某网页时将其缓存节点移到头部\"}],\"name\":\"LRU缓存\",\"type\":\"DataStructure\"}",
  "ad6b0b8f62bb9d5ef370769bacd4867b": "{\"description\":\"LFU（Least Frequently Used）缓存是一种基于访问频率的缓存替换策略，核心思想是当缓存容量不足时淘汰访问频率最低的条目；若存在多个条目频率相同，则进一步淘汰其中最近最少使用（LRU）的条目，通过维护键的访问频率和顺序实现高效管理\",\"storage_method\":\"采用哈希表与双向链表结合的结构：1. 键映射表（key-to-node）：快速通过键查找缓存节点（含键、值、访问频率、前后指针）；2. 频率映射表（frequency-to-list）：将同频率节点组织为双向链表，便于移动节点和淘汰低频条目；同时维护当前最小频率变量以快速定位淘汰目标\",\"properties\":\"1. 基于访问频率的替换策略，优先淘汰低频条目；2. 同频率条目采用LRU策略处理；3. 支持O(1)时间复杂度的读写操作；4. 需维护每个键的访问频率和节点顺序\",\"time_complexity\":{\"get\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"put\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"LRU缓存（Least Recently Used，基于访问时间的替换策略）\",\"FIFO缓存（First-In-First-Out，基于插入顺序的替换策略）\",\"ARC缓存（Adaptive Replacement Cache，结合LFU和LRU的自适应策略）\"],\"common_operations\":[{\"operation_name\":\"get\",\"description\":\"根据键获取缓存值，若键存在则更新该键的访问频率\",\"typical_usage\":\"缓存读操作，如数据库查询结果、API响应的缓存读取\"},{\"operation_name\":\"put\",\"description\":\"插入或更新键值对，键存在则更新值并增频；缓存满时淘汰最不经常使用（同频时最近最少使用）的条目\",\"typical_usage\":\"缓存写操作，如将计算结果、静态资源存入缓存\"},{\"operation_name\":\"evict\",\"description\":\"内部操作，淘汰访问频率最低（同频时最近最少使用）的条目\",\"typical_usage\":\"缓存容量已满时自动触发，维持缓存大小在容量内\"}]}",
  "9da20a2de7895529ed8a46886ed12879": "{\"description\":\"不相交集合（Disjoint Set Union, DSU，又称并查集）是一种用于高效管理元素分组的数据结构，核心功能是维护动态连通性——支持查询元素所属集合（Find）和合并两个不相交集合（Union）操作，通过路径压缩和按秩合并优化，能在近常数时间内完成操作\",\"storage_method\":\"通常采用数组存储每个元素的父节点（父指针数组），父指针指向自身的元素为集合根节点；辅助数组（如秩数组rank或大小数组size）用于优化合并操作：秩数组记录树的高度，大小数组记录集合元素数量\",\"properties\":[\"动态连通性：支持动态维护元素间的连通关系\",\"不相交性：所有集合两两无交集\",\"路径压缩优化：Find操作时扁平化树结构，减少后续查询路径长度\",\"按秩/大小合并优化：Union操作时将较浅/较小的树合并到较深/较大的树，保持树高度较低\",\"根节点唯一性：每个集合有唯一根节点作为标识\"],\"time_complexity\":{\"make_set\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"find\":{\"best_case\":\"O(1)\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"},\"union\":{\"best_case\":\"O(1)\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"}},\"space_complexity\":\"O(n)，n为元素总数，需存储父数组和辅助数组（秩或大小）\",\"related_algorithms\":[\"Kruskal算法（最小生成树算法，用于判断边是否连接不同连通分量）\",\"动态连通性问题求解算法\"],\"common_operations\":[{\"name\":\"make_set\",\"description\":\"初始化单个元素为独立集合（父指针指向自身，秩/大小设为初始值）\",\"typical_usage\":\"Kruskal算法开始前初始化每个顶点为单独集合；图论中初始化所有节点为独立连通分量\"},{\"name\":\"find\",\"description\":\"查询元素所属集合的根节点（通过父指针回溯，路径压缩时直接指向根）\",\"typical_usage\":\"判断两个元素是否属于同一集合（如Kruskal算法中判断边的两个顶点是否连通）；查找元素的连通分量标识\"},{\"name\":\"union\",\"description\":\"合并两个元素所在的不相交集合（通过Find找到根后，按秩/大小合并根节点）\",\"typical_usage\":\"Kruskal算法中添加有效边（连接不同连通分量）时合并集合；合并两个独立的连通分量\"}]}",
  "21f87c6c1902a1f04e3441bf0e9de0d6": "{\"description\":\"可持久化数据结构是一种支持在修改操作时保留所有历史版本的数据结构，每次修改会生成新的版本而不破坏旧版本，核心通过结构共享（仅复制修改路径上的节点）优化空间开销，允许对任意历史状态进行查询、回溯或分支扩展\",\"storage_method\":\"主要采用路径复制（Path Copying）策略：修改操作仅复制数据结构中被修改路径上的节点，未修改的子结构在新旧版本间共享；部分结构（如持久化线段树、持久化并查集）结合分层存储、节点复用或路径压缩机制进一步优化空间效率\",\"properties\":[\"旧版本不可变性（修改不影响历史版本状态）\",\"版本分支能力（支持并行生成多个版本分支）\",\"结构共享性（不同版本复用未修改的子结构）\",\"时间旅行特性（可访问任意历史版本的完整状态）\"],\"time_complexity\":{\"版本化修改\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"版本查询\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"版本回溯\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"版本合并（支持结构）\":{\"best_case\":\"O(α(n))\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"}},\"space_complexity\":{\"单次修改额外空间\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(n)\"},\"k次修改总空间\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k log n)\",\"worst_case\":\"O(kn)\"}},\"related_algorithms\":[\"路径复制算法（Path Copying）\",\"持久化二叉搜索树（Persistent BST）\",\"持久化线段树（Persistent Segment Tree）\",\"持久化并查集（Persistent Union-Find）\",\"持久化平衡树（Persistent Splay Tree）\",\"持久化Trie树（Persistent Trie）\"],\"common_operations\":[{\"name\":\"版本化修改\",\"description\":\"基于旧版本数据结构进行修改（如插入、删除、更新元素），生成新的版本实例，旧版本保持不变\",\"typical_usage\":\"版本控制系统创建文件新版本（如Git commit）、数据库记录历史变更（如时间序列数据库写入）、文档编辑器保存历史版本\"},{\"name\":\"版本查询\",\"description\":\"根据版本标识符（如版本号、时间戳）访问对应版本中的元素值或结构状态\",\"typical_usage\":\"查看文档历史版本内容（如Word的版本浏览）、数据库查询过去状态（如SQL AS OF语句）、查看代码的历史提交记录\"},{\"name\":\"版本回溯\",\"description\":\"将当前工作版本切换到指定的历史版本，后续操作基于该历史版本进行\",\"typical_usage\":\"文本编辑器撤销到某一步操作（如多次Ctrl+Z）、系统故障时回滚到稳定版本（如数据库事务回滚）、恢复误删除的文件版本\"},{\"name\":\"版本合并\",\"description\":\"（仅部分结构支持）将两个或多个分支版本的修改合并为一个新版本，处理冲突并整合变更\",\"typical_usage\":\"协同编辑工具合并不同用户的修改（如Google Docs版本合并）、分布式系统合并分叉状态（如区块链分叉合并）、代码仓库合并不同分支（如Git merge）\"}]}",
  "8f68ed75e03fd55f94adb407fa68f851": "{\"description\":\"栈的基本操作之一，将一个元素添加至栈的顶端位置，该元素成为新的栈顶，栈的大小增加1\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"栈（Stack）\",\"operation_type\":\"修改操作（Mutation）\",\"side_effects\":\"修改栈的状态（增加栈顶元素）；固定大小数组实现时若栈已满会引发栈溢出（Stack Overflow）；动态扩展栈可能触发内存重新分配（如数组扩容的拷贝操作，均摊时间复杂度仍为O(1)）\",\"typical_usage\":\"函数调用的栈帧管理（保存返回地址、局部变量等上下文）；后缀表达式求值（压入操作数或中间结果）；回溯算法（如DFS记录当前路径，回溯时弹出无效节点）；括号匹配问题（压入左括号以等待右括号匹配）\"}",
  "e0221603583a1bf38c1bab3961327490": "{\"description\":\"向遵循先进先出（FIFO）原则的队列尾部添加一个元素的操作，是队列的核心操作之一\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"队列（Queue）、双端队列（Deque，尾部入队场景）\",\"operation_type\":\"修改型操作（Mutator）\",\"side_effects\":\"若为有界队列且已满时，会引发队列溢出；修改队列的长度及尾部元素；无界队列场景下可能增加内存占用\",\"typical_usage\":\"任务调度系统中就绪进程的加入；生产者-消费者模型中生产者向消息队列添加消息；广度优先搜索（BFS）中待访问节点的入队操作；排队系统（如银行叫号、打印机队列）中新顾客或任务的加入\"}",
  "ec6d889d115194b94fe026ca23e6837f": "{\"description\":\"栈数据结构中的基本操作，用于移除并返回栈的顶部元素（栈顶元素是最后一个入栈的元素，遵循后进先出LIFO原则）\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"栈（Stack）\",\"operation_type\":\"修改操作\",\"side_effects\":\"栈的大小减少1；若栈为空时执行出栈操作，会引发栈下溢（Underflow）异常\",\"typical_usage\":\"函数调用栈中函数执行完成后的返回操作；逆波兰表达式求值中弹出操作数进行计算；文本编辑器等应用的撤销（Undo）功能（移除最近的操作记录）；括号匹配算法中匹配右括号时弹出栈顶左括号验证\"}",
  "94af8fcbb848e1a9ceb678d33fef4bd8": "{\"description\":\"队列的基本操作之一，用于移除并返回队列的前端（队首）元素\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"队列\",\"operation_type\":\"删除操作\",\"side_effects\":\"1. 队列元素数量减1；2. 队首指针（或索引）向后移动（依实现方式而定）；3. 若队列为空时执行出队可能抛出下溢异常\",\"typical_usage\":\"1. 任务调度系统中取出待执行的任务（如打印机队列的下一个打印任务）；2. 广度优先搜索（BFS）算法中取出下一个待访问的节点；3. 消息中间件中消费者从消息队列获取并移除消息；4. 缓冲系统中获取最早进入缓冲区的元素\"}",
  "b1f6d12227f1895279768c2a41e7ed47": "{\"description\":\"在数据结构中，将新元素添加到指定位置或根据结构规则（如有序性、哈希映射规则）确定的合适位置的操作，用于扩展数据结构的元素集合并维持其特性（如有序性、哈希映射关系）\",\"complexity\":{\"数组（静态）\":{\"best_case\":\"O(1)（插入到末尾且无需移动元素）\",\"average_case\":\"O(n)（需移动约一半元素）\",\"worst_case\":\"O(n)（插入到表头需移动所有元素）\"},\"数组（动态，如ArrayList）\":{\"best_case\":\"O(1)（插入到末尾且无需扩容）\",\"average_case\":\"O(1)（摊还分析，扩容操作摊还到多次插入）\",\"worst_case\":\"O(n)（插入到末尾且需扩容，需复制所有元素）\"},\"单链表（表头插入）\":{\"best_case\":\"O(1)（直接修改表头指针）\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"单链表（表尾插入，有尾指针）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"单链表（表尾插入，无尾指针）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"双向链表（已知位置节点）\":{\"best_case\":\"O(1)（修改前后节点指针）\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"二叉搜索树（BST）\":{\"best_case\":\"O(logn)（平衡结构，插入到叶子节点）\",\"average_case\":\"O(logn)（随机插入的平均树高）\",\"worst_case\":\"O(n)（退化为链表，需遍历所有节点）\"},\"哈希表（链地址法/开放寻址法）\":{\"best_case\":\"O(1)（无哈希冲突，直接插入）\",\"average_case\":\"O(1)（负载因子低，冲突少）\",\"worst_case\":\"O(n)（所有元素哈希到同一位置，退化为链表或线性探测）\"}},\"applied_to\":\"数组、单链表、双向链表、栈、队列、二叉搜索树、哈希表、图（邻接表）\",\"operation_type\":\"写操作\",\"side_effects\":\"数组插入可能导致元素移位或动态扩容（内存复制）；链表插入需修改节点指针，操作不当可能引发链表断裂；二叉搜索树插入可能破坏平衡（非平衡树需额外调整）；哈希表插入可能引发冲突（需冲突处理）或负载因子过高导致扩容（重新哈希）；静态栈/队列插入可能导致溢出\",\"typical_usage\":\"动态数组添加元素（如Python list.append()）；有序链表插入节点维持顺序；二叉搜索树插入新键保持有序性；哈希表存储键值对（如Python dict赋值）；栈的push操作（表达式求值）；队列的enqueue操作（任务调度）；图邻接表添加边\"}",
  "b9f7dd52a4e0b2416899bfaa5db927ea": "{\"description\":\"按特定顺序访问数据结构中的每个元素且每个元素仅被访问一次的基本操作，目的是遍历过程中对元素进行查看、处理或收集信息\",\"complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"数组、链表、树（二叉树、二叉搜索树、AVL树等）、图（邻接表、邻接矩阵存储的图）、哈希表、栈、队列等线性与非线性数据结构\",\"operation_type\":\"读取操作（Read Operation）\",\"side_effects\":\"无（单纯遍历仅访问元素，不修改数据结构或元素的固有状态；若遍历过程中附加修改逻辑（如删除元素、修改元素值），则会产生对应副作用）\",\"typical_usage\":\"1. 全量元素访问（如打印链表所有节点值、输出图的所有顶点）；2. 目标元素搜索（遍历查找数组中等于目标值的元素位置）；3. 统计与聚合计算（如统计二叉树叶子节点数量、计算数组元素平均值）；4. 元素筛选（遍历筛选出哈希表中满足条件的键值对）；5. 数据序列化（遍历将树结构转为字符串格式存储或传输）；6. 图的连通性检测（遍历图的所有节点判断连通分量）\"}",
  "f2d5f3aff1fe1c5bd83e1161441af244": "{\"description\":\"计算机科学中，在数据结构（如数组、树、哈希表等）中根据给定键或条件，确定目标元素的存在性、位置或关联值的基本操作，核心是获取目标元素信息而默认不修改数据结构状态。\",\"complexity\":{\"best_case\":\"O(1)（目标元素位于数据结构起始位置，或哈希表通过哈希函数直接命中无冲突）\",\"average_case\":\"O(log n)（有序数组二分查找、平衡二叉搜索树查找）、O(1)（哈希表平均情况）或 O(n)（无序结构线性查找）\",\"worst_case\":\"O(n)（无序结构线性查找，或哈希表所有元素冲突至同一桶的链表遍历）\"},\"applied_to\":\"数组、链表、二叉搜索树、AVL树、红黑树、哈希表、图、跳表等数据结构\",\"operation_type\":\"检索型操作\",\"side_effects\":\"无（纯查找操作不修改数据结构的内容或布局）\",\"typical_usage\":\"数据库根据主键查询记录、搜索引擎关键词匹配文档、哈希表通过键获取对应值、有序数组寻找元素插入位置、平衡二叉树查找最小/最大值、图算法查找节点邻接元素等场景\"}",
  "6f4525807cdb4bacd1d2fc68c07c5c21": "{\"description\":\"在数据结构中移除指定元素或节点的操作，需先定位目标元素（或通过结构特性直接访问，如栈顶），再修改数据结构的存储或链接状态以排除该元素\",\"complexity\":{\"数组（Array）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链表（Linked List）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"哈希表（Hash Table）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(n)\"},\"二叉搜索树（BST）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"栈（Stack）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"队列（Queue）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"AVL树\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(logn)\"}},\"applied_to\":\"数组、链表、栈、队列、哈希表、树（二叉搜索树、AVL树、红黑树）、图（邻接表/邻接矩阵）\",\"operation_type\":\"写操作（Write Operation）\",\"side_effects\":\"1. 数组删除引发后续元素向前移位，产生O(n)时间开销；2. 链表未正确处理指针可能导致悬空指针或链表断裂；3. 哈希表删除可能降低负载因子，触发再哈希（动态调整大小时）；4. 平衡树（AVL/红黑树）删除后需旋转调整平衡，产生额外O(logn)操作；5. 图删除顶点时需同步删除关联边，可能修改邻接表/矩阵结构；6. 队列/栈删除若未处理边界条件可能导致下溢错误\",\"typical_usage\":\"1. 链表中移除指定值或位置的节点；2. 数组中删除索引k处的元素；3. 哈希表根据键删除键值对；4. 二叉搜索树删除节点以维持有序性；5. 栈弹出栈顶元素（LIFO语义）；6. 队列移除队首元素（FIFO语义）；7. 图中删除某顶点及所有关联边；8. 红黑树删除节点后修复颜色与平衡\"}",
  "8b559ad66f5a9655ba85e60f23c5cd79": "{\"description\":\"初始化操作是为数据结构分配必要内存空间，并将其设置为预定初始状态（如空状态、默认值或指定初始值）的过程，是数据结构使用前的必备步骤，确保其处于可操作的初始状态\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"数组、链表、栈、队列、树、图、哈希表等数据结构\",\"operation_type\":\"构造操作\",\"side_effects\":\"分配内存空间（动态数据结构）、修改内存区域初始值、建立数据结构基本结构（如链表头节点、栈的top指针）\",\"typical_usage\":\"创建数据结构实例时的初始设置（如数组元素初始化、链表头节点创建）、程序启动时为全局数据结构分配资源、重置数据结构至初始状态（如清空栈后重新初始化top指针）\"}",
  "ad674952bb35561bfb1b7b9f5980cd6c": "{\"description\":\"当连续存储数据结构（如动态数组、哈希表桶数组）的当前容量无法容纳新元素时，分配更大的连续存储空间，并将原有元素迁移至新空间以扩展容量的操作，是动态数据结构维持灵活性的关键机制\",\"complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"动态数组、哈希表、基于数组的栈/队列、字符串缓冲区等连续存储的动态数据结构\",\"operation_type\":\"结构调整操作\",\"side_effects\":\"1. 触发时产生O(n)时间开销；2. 连续存储结构的内存地址变更（如动态数组的引用更新）；3. 可能导致内存空间浪费（如翻倍扩容后的空闲容量）；4. 可能使依赖原内存地址的引用或迭代器失效（如哈希表rehash后的迭代器失效）\",\"typical_usage\":\"1. Java ArrayList执行add()时容量不足；2. Python dict负载因子超标触发rehash；3. C++ string执行append()时容量不足；4. 基于数组实现的栈push()操作导致栈满时\"}",
  "437cc9b57dbd678b96e9fc6f16849533": "{\"description\":\"复制操作是计算机科学中创建数据副本的基本操作，通过复制原数据的内容生成一个或多个新实例，根据拷贝深度可分为浅拷贝（仅复制顶层结构或引用，嵌套结构共享）和深拷贝（复制所有层级的结构，副本与原数据完全独立）\",\"complexity\":{\"best_case\":\"O(1)（复制单个值类型或固定大小的简单数据）\",\"average_case\":\"O(n)（复制包含n个元素的线性结构或中等复杂度对象）\",\"worst_case\":\"O(n)（复制n个元素的线性结构或深度嵌套的复杂对象）\"},\"applied_to\":\"数组、链表、字符串、结构体、类实例（对象）、文件、变量（值类型/引用类型）、哈希表、树\",\"operation_type\":\"数据复制操作\",\"side_effects\":\"内存占用增加（副本占用额外内存）；浅拷贝导致引用共享（修改副本的引用类型字段会影响原对象）；深拷贝带来性能开销（遍历嵌套结构耗时）；大型数据复制可能引发内存不足或性能瓶颈；不可变数据（如字符串）复制可能复用内存但不影响语义\",\"typical_usage\":\"数据备份（文件复制、数据库快照）；函数值类型参数传递（避免原变量被修改）；数组/列表的独立修改（修改副本不影响原结构）；对象克隆（创建独立实例避免原对象被改）；字符串处理（拼接时的中间副本）；多线程数据传递（避免共享状态保证线程安全）；算法中保留原始数据（如排序前拷贝数组）\"}",
  "9cf1b69861012ac737f87d6a40292ba3": "{\"description\":\"动态数据结构（如动态数组、哈希表）在元素数量降至设定阈值（如容量的1/4）时，通过减小底层存储容量以释放闲置内存的操作，需将现有元素复制到新的更小容器中\",\"complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"动态数组（如Python list、Java ArrayList）、哈希表（如Java HashMap）、动态缓存结构（如LRU缓存）\",\"operation_type\":\"容量调整操作\",\"side_effects\":\"1. 时间开销：复制元素导致O(n)时间复杂度，可能短暂降低性能；2. 并发风险：多线程环境下未同步易引发数据不一致；3. 频繁操作：阈值不合理可能导致频繁缩容，增加总开销；4. 内存泄漏：旧容器若被引用未释放，会占用额外内存\",\"typical_usage\":\"1. 动态数组在大量元素删除后（如元素数从1000减至200）触发缩容释放内存；2. 哈希表负载因子低于阈值（如0.25）时减少桶数量优化空间；3. LRU缓存项数量降至容量1/4时缩小容量节省内存；4. 内存敏感应用中动态优化数据结构内存占用\"}",
  "38e401ca2635c16b4da13c0e1fe0c014": "{\"description\":\"在计算机数据结构中，合并操作指将两个或多个独立的数据结构（如数组、链表、堆、集合等）整合为一个新的或经过修改的结构，通常需保持原结构的关键特性（如有序性、堆性质、连通性等），是归并排序、并查集、优先级队列等算法与数据结构的核心操作\",\"complexity\":{\"合并两个有序数组（归并排序场景）\":{\"best_case\":\"O(n+m)\",\"average_case\":\"O(n+m)\",\"worst_case\":\"O(n+m)\"},\"合并两个有序链表\":{\"best_case\":\"O(n+m)\",\"average_case\":\"O(n+m)\",\"worst_case\":\"O(n+m)\"},\"斐波那契堆合并\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"并查集合并（路径压缩+按秩合并）\":{\"best_case\":\"O(α(n))\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"},\"合并两个二叉堆\":{\"best_case\":\"O(log n + log m)\",\"average_case\":\"O(log n + log m)\",\"worst_case\":\"O(log n + log m)\"}},\"applied_to\":\"有序数组、无序数组、单向链表、双向链表、斐波那契堆、二叉堆、并查集集合、平衡二叉搜索树、跳表、有序文件段\",\"operation_type\":\"整合型操作\",\"side_effects\":\"合并有序数组若原地执行可能覆盖原数据，若生成新数组则占用O(n+m)额外空间；合并链表会修改原链表指针指向，破坏原链表独立性；并查集合并会更新父节点指针和秩/大小信息；斐波那契堆合并后原堆不再独立；合并平衡二叉搜索树可能触发再平衡操作；合并无序结构若需保持有序性则需额外排序开销\",\"typical_usage\":\"归并排序中合并两个有序子数组完成排序；并查集处理动态连通性问题（如网络节点连接、Kruskal算法合并边集合）；合并两个有序链表构建复杂链表结构；斐波那契堆合并优先级队列；外部排序中合并有序文件段；数据库合并有序查询结果集；合并有序日志文件生成时间线\"}",
  "68ef3419fdd8861a49f389f219801f36": "{\"description\":\"释放数据结构占用的内存或系统资源，使其完全不可用的操作，通常用于回收不再需要的资源\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"链表、树、动态数组、哈希表等需要手动管理内存或资源的数据结构\",\"operation_type\":\"资源释放操作\",\"side_effects\":\"销毁后数据结构不可再访问，若存在未失效的指针指向该结构会导致悬空指针或非法内存访问错误\",\"typical_usage\":\"当数据结构不再被使用时释放其占用的内存以避免内存泄漏；程序或模块退出前清理所有无用的数据结构资源\"}",
  "f1ba5bfb46e6cec8e1c39820bdb17d7f": "{\"description\":\"在数据结构中，移动操作指将元素从一个存储位置转移至另一个位置的操作，保持元素本身的值不变，仅改变其在数据结构中的相对或绝对位置\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"数组、链表、动态数组、双向链表等线性数据结构\",\"operation_type\":\"修改操作\",\"side_effects\":\"可能改变元素的索引或指针引用关系；若数据结构为有序结构，移动元素可能破坏其有序性；数组中移动元素会导致后续元素的位置平移，影响迭代或随机访问的结果\",\"typical_usage\":\"数组元素插入/删除时的元素平移、链表节点的重新排列（如移动节点至表头/表尾）、动态数组扩容时的元素迁移、有序线性表中调整元素位置以维持有序性\"}",
  "ad5fd97a8ed9857fe7bc42991956f942": "{\"description\":\"按数据结构中元素的逻辑顺序依次访问每个元素的操作，即从第一个元素开始逐个访问直至最后一个元素，不跳过任何中间元素\",\"complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"数组（Array）、链表（Linked List）、顺序表（Sequential List）、队列（Queue）、栈（Stack）\",\"operation_type\":\"遍历（Traversal）\",\"side_effects\":\"无（仅读取元素，不修改数据结构的状态）\",\"typical_usage\":\"遍历数组计算元素总和、查找链表中特定值的节点、统计队列中元素的个数、打印栈内所有元素内容、遍历顺序表进行元素有效性检查\"}",
  "eb6d9411819c93e0d6857cc16ed8da3f": "{\"description\":\"在树形数据结构（如平衡二叉搜索树）中，通过调整节点的父-子指针关系改变子树结构的操作，分为左旋（将节点右子节点提升为父节点）和右旋（将节点左子节点提升为父节点）两类，用于维持树的平衡性质。\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"平衡二叉搜索树（AVL树、红黑树）、Treap、Splay树等树形数据结构\",\"operation_type\":\"树形数据结构的结构调整与平衡维护操作\",\"side_effects\":\"修改节点的父指针和子指针关系；调整子树高度；维持二叉搜索树的有序性（不改变键值相对顺序）；影响树的整体高度或节点平衡因子\",\"typical_usage\":\"AVL树插入/删除后修复平衡因子超标子树；红黑树通过旋转配合颜色调整恢复红黑性质；Splay树将访问节点旋转至根优化后续访问；Treap旋转维护堆性质\"}",
  "befed7da6ae46bced04a47517cfaa7a1": "{\"description\":\"并查集（DSU）中的合并优化操作，合并两个集合时将秩较小的树的根节点连接到秩较大的树的根节点上，通过控制树的高度增长来提升后续查找操作的效率，其中秩通常定义为树的高度（或近似高度）或节点数量\",\"complexity\":{\"best_case\":\"O(α(n))\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"},\"applied_to\":\"并查集（Disjoint Set Union，DSU）\",\"operation_type\":\"合并操作\",\"side_effects\":\"修改并查集的秩数组（仅当两树秩相等时增加合并后树的秩）；调整集合的树状结构以保持较低高度；维护并查集的连通性状态\",\"typical_usage\":\"Kruskal算法中合并边的两个顶点所在连通组件以构建最小生成树；动态连通性问题中合并两个连通组件（如社交网络添加好友时合并用户连通块）；图论中批量处理连通组件的合并操作\"}",
  "1d4c3b462e11bbddcb9c52ee107afcd1": "{\"description\":\"直接通过元素的索引或存储地址访问数据结构中任意位置元素的操作，无需顺序遍历其前驱元素，是支持直接寻址的数据结构的核心操作之一\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"applied_to\":\"数组（Array）、哈希表（Hash Table，基于键的哈希寻址）、内存单元（Memory Cells）、磁盘扇区（Disk Sectors）、索引数组（Indexed Arrays）\",\"operation_type\":\"访问操作（包含读访问与写访问）\",\"side_effects\":\"读操作无副作用；写操作会修改目标位置的元素值，可能影响后续对该位置的访问结果\",\"typical_usage\":\"数组中根据索引快速获取或修改元素、哈希表通过键快速查找或更新值、数据库通过主键索引定位记录、内存中通过地址读写变量、磁盘I/O通过逻辑块地址访问扇区数据\"}",
  "5082e16e84a5aac264fe6af6c456797b": "{\"description\":\"路径压缩是并查集（Disjoint Set Union, DSU）数据结构中针对查找（find）操作的启发式优化技术。在执行find操作获取某节点的根节点时，该技术会将查找路径上的所有节点直接指向根节点，从而扁平化树结构，大幅缩短后续查找操作的路径长度，提升整体效率。\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(α(n))\",\"worst_case\":\"O(α(n))\"},\"applied_to\":\"并查集（Disjoint Set Union, DSU）的查找（find）操作\",\"operation_type\":\"查找优化操作\",\"side_effects\":\"修改并查集树的结构，将查找路径上的节点直接连接到根节点以扁平化树；不改变集合的连通性，但显著提升后续查找操作的效率\",\"typical_usage\":\"Kruskal算法求最小生成树中的连通性校验、图的动态连通性问题、社交网络中的好友关系连通性分析等需要频繁执行查找与合并操作的场景\"}",
  "4bd1ef7ec33c516b2ab042ef94af3405": "{\"description\": \"一种垃圾收集机制，通过维护对象的引用次数计数器，当对象被引用时增加计数器，引用失效时减少计数器，计数器为0时自动回收对象内存\", \"complexity\": {\"增加计数\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"}, \"减少计数\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"}}, \"applied_to\": \"动态分配的堆对象、多引用指向的共享对象\", \"operation_type\": \"内存管理操作、原子操作（计数器修改需保证线程安全）\", \"side_effects\": \"减少计数至0时触发对象内存回收及关联对象的计数递减；线程安全实现需同步机制导致性能开销；无法处理循环引用（需额外机制如弱引用解决）\", \"typical_usage\": \"Python等语言的内存管理基础机制；C++ shared_ptr等智能指针的实现；COM对象的引用生命周期管理；需要细粒度即时内存回收的场景\"}",
  "ccadaf963bce8846eee1e345c1aff8af": "{\"description\":\"从系统或进程的内存池中预留指定大小的内存块（通常为连续虚拟地址空间），返回指向该块起始地址的指针，供程序存储动态生成数据的操作，是动态内存管理的核心步骤\",\"complexity\":{\"best_case\":\"O(1)（如从预初始化的小内存bin中直接获取匹配块，无需遍历）\",\"average_case\":\"O(log n)（如伙伴系统分解/合并块）至O(n)（如首次适配算法在中低负载下的遍历）\",\"worst_case\":\"O(n)（如首次适配/最佳适配算法遍历整个空闲链表寻找可用块）\"},\"applied_to\":\"动态内存管理中的空闲内存池、进程虚拟地址空间、堆内存区域\",\"operation_type\":\"内存资源分配操作\",\"side_effects\":\"会产生内存碎片化（外部碎片：空闲块分散无法满足大内存请求；内部碎片：分配块大于需求的剩余空间无法利用）；可能触发系统调用（如brk/mmap扩展堆空间）；分配失败时返回空指针（导致空指针引用错误）；频繁分配释放可能降低内存利用率\",\"typical_usage\":\"为动态数据结构（链表节点、树节点、哈希表）分配存储空间；对象-oriented语言中创建对象的底层内存分配（如C++ new、Java对象堆分配）；处理临时数据（文件读取缓冲区、网络数据包缓存）；加载动态链接库时分配代码/数据段内存；实现自定义内存池以优化特定场景性能\"}",
  "6588593284f1b1f232a4bb38fd307c53": "{\"description\":\"自动识别程序中不再被任何活跃引用指向的内存对象（垃圾），并释放其占用的内存资源，以实现内存的自动管理，避免手动内存管理带来的内存泄漏、悬垂指针等错误\",\"complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"applied_to\":\"支持自动内存管理的编程语言或运行时环境的堆内存（如Java JVM堆、Python对象堆、JavaScript V8堆）\",\"operation_type\":\"内存管理操作\",\"side_effects\":\"可能导致应用线程暂停（Stop-the-World）、内存碎片化（如标记-清除算法）、额外CPU/内存开销（维护GC元数据与执行回收逻辑）、影响程序响应时间（长GC停顿）\",\"typical_usage\":\"Java虚拟机的分代垃圾回收（如G1 GC处理老年代）、Python的循环垃圾收集器回收循环引用对象、JavaScript V8引擎的新生代Scavenge回收、C# .NET运行时的自动内存回收\"}",
  "6b89cdd5ed53a3e13ca00ef398d95a0d": "{\"description\":\"深度优先搜索（Depth-First Search, DFS）是一种用于遍历或搜索树、图等数据结构的算法，核心策略为“深度优先”——优先沿当前路径尽可能深入探索未访问节点，直至无法继续（到达叶子节点或邻接节点均已访问），再回溯至上一节点探索其他分支。\",\"principle\":\"基于栈结构（递归实现利用程序调用栈，非递归实现使用显式栈）维护待探索节点序列。从起始节点开始，标记为已访问后，递归或压栈处理其未访问邻接节点；当节点所有邻接节点均处理完毕则回溯，通过标记已访问节点避免图结构中的环路问题。\",\"applicable_conditions\":\"适用于树/图遍历（如树的前序、中序、后序遍历）、连通性检测（无向图连通性、连通分量查找）、路径查找（迷宫求解、节点间路径搜索）、拓扑排序（有向无环图DAG）、环路检测（判断图中是否存在环）等场景；处理图时需具备避免重复访问的机制（如已访问集合）。\",\"time_complexity\":{\"邻接表\":{\"best_case\":\"O(V+E)\",\"average_case\":\"O(V+E)\",\"worst_case\":\"O(V+E)\"},\"邻接矩阵\":{\"best_case\":\"O(V²)\",\"average_case\":\"O(V²)\",\"worst_case\":\"O(V²)\"}},\"space_complexity\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"related_data_structures\":[\"栈\",\"树\",\"图\",\"哈希表\"],\"key_steps\":[\"初始化：创建已访问节点集合（如布尔数组、哈希表），非递归实现需初始化显式栈，递归实现利用调用栈\",\"起始节点处理：选择起始节点，标记为已访问并压入栈（非递归）或直接递归调用\",\"节点探索：从栈弹出节点，执行处理逻辑（如记录、输出）\",\"邻接节点处理：遍历当前节点所有邻接节点，若未访问则标记为已访问并压入栈（非递归）或递归调用DFS\",\"终止：重复探索与邻接处理步骤，直至栈空（非递归）或所有递归返回（递归）\"]}",
  "86e9490e44bd75a721f9b5c6d9c19ba2": "{\"description\": \"快速排序（Quicksort）是一种基于分治策略的高效排序算法，通过选择基准元素将数组分割为两个子数组，递归地对其子数组进行排序，最终实现整个数组的有序排列，通常为原地排序（in-place）。\", \"principle\": \"基于分治（Divide-and-Conquer）策略，分为三个核心步骤：1. 分解（Divide）：从数组中选取一个基准元素（Pivot），将原数组重新排列为左子数组（所有元素≤基准）、基准元素、右子数组（所有元素≥基准）三部分，基准元素此时位于其最终的正确位置；2. 解决（Conquer）：递归地对左子数组和右子数组分别执行快速排序；3. 合并（Combine）：由于排序操作是原地进行的，无需额外合并步骤，递归终止后整个数组自然有序。\", \"applicable_conditions\": \"适用于需要高效排序的场景，尤其是数据量较大且分布随机的情况；不适用于要求稳定排序（相同元素相对位置不变）、数据已接近有序（易触发最坏时间复杂度）或对递归深度有限制的场景。\", \"time_complexity\": {\"best_case\": \"O(n log n)\", \"average_case\": \"O(n log n)\", \"worst_case\": \"O(n²)\"}, \"space_complexity\": {\"best_case\": \"O(log n)\", \"average_case\": \"O(log n)\", \"worst_case\": \"O(n)\"}, \"related_data_structures\": [\"数组（Array，快速排序的主要操作对象，通常为原地排序）\", \"栈（Stack，递归实现隐式依赖调用栈，非递归实现需显式使用栈存储子数组边界）\"], \"key_steps\": [\"选择基准元素：常用策略包括随机选择、三数取中（取首、中、尾元素的中位数）或九数取中，以降低最坏情况发生概率；\", \"分割操作（Partition）：通过双指针（如左指针从左向右、右指针从右向左遍历）交换元素，将≤基准的元素移至基准左侧，≥基准的元素移至右侧，最终将基准放置在正确位置；\", \"递归排序子数组：对基准左侧子数组（左边界至基准前一位）和右侧子数组（基准后一位至右边界）递归执行快速排序；\", \"终止递归：当子数组长度≤1时停止递归（子数组已天然有序）\"]}",
  "44194a8f76b7f5c51de13d6787ac7f0f": "{\"description\":\"Dijkstra算法是一种用于解决带权图中单源最短路径问题的贪心算法，能够计算从给定源顶点到图中所有其他顶点的最短路径长度，要求图中所有边的权重非负\",\"principle\":\"基于贪心策略，每次从未确定最短路径的顶点集合中选择当前距离源点最近的顶点（贪心选择），并以该顶点为中间点对其所有邻接顶点进行松弛操作（更新邻接顶点的最短路径估计），重复此过程直到所有顶点的最短路径被确定\",\"applicable_conditions\":\"1. 图为带权有向图或无向图；2. 所有边的权重均为非负数；3. 需求解单源最短路径问题（从一个源顶点到所有其他顶点的最短路径）\",\"time_complexity\":{\"数组实现\":{\"best_case\":\"O(V²)\",\"average_case\":\"O(V²)\",\"worst_case\":\"O(V²)\"},\"二叉堆实现\":{\"best_case\":\"O((V+E)logV)\",\"average_case\":\"O((V+E)logV)\",\"worst_case\":\"O((V+E)logV)\"},\"斐波那契堆实现\":{\"best_case\":\"O(E + VlogV)\",\"average_case\":\"O(E + VlogV)\",\"worst_case\":\"O(E + VlogV)\"}},\"space_complexity\":{\"邻接表存储\":{\"best_case\":\"O(V+E)\",\"average_case\":\"O(V+E)\",\"worst_case\":\"O(V+E)\"},\"邻接矩阵存储\":{\"best_case\":\"O(V²)\",\"average_case\":\"O(V²)\",\"worst_case\":\"O(V²)\"}},\"related_data_structures\":[\"优先队列（堆）\",\"邻接表\",\"邻接矩阵\",\"数组（距离数组、前驱数组）\"],\"key_steps\":[\"初始化：源顶点距离设为0，其他顶点设为无穷大；初始化前驱数组，所有顶点标记为未确定状态\",\"迭代选择：重复至所有顶点确定：a. 选未确定中距离源点最近的顶点u并标记；b. 对u的邻接顶点v执行松弛：若dist[v] > dist[u]+weight(u,v)，则更新dist[v]和前驱\",\"结果输出：距离数组存最短路径长度，前驱数组重构具体路径\"]}",
  "4818f2de98bfc0a1d3a30c65478243d7": "{\"description\":\"KMP算法是一种高效的单模式串字符串匹配算法，用于在文本串（长度为n）中快速查找模式串（长度为m）的出现位置，核心是通过预处理模式串构建部分匹配表（LPS数组，最长前缀后缀数组）来避免文本串指针的回溯，从而减少不必要的字符比较\",\"principle\":\"基于模式串的前缀和后缀的最长公共前后缀（Longest Prefix Suffix, LPS）构建部分匹配表。当文本串与模式串在某位置匹配失败时，无需回溯文本串指针，而是根据当前模式串指针位置的LPS值将模式串指针跳转到对应位置，继续比较后续字符，从而避免重复比较已匹配过的字符\",\"applicable_conditions\":\"适用于单模式串的字符串匹配场景，尤其是需要在长文本中多次查找同一模式串的情况；要求不允许或不希望文本串指针回溯以提高效率的场景\",\"time_complexity\":{\"best_case\":\"O(m + n)\",\"average_case\":\"O(m + n)\",\"worst_case\":\"O(m + n)\"},\"space_complexity\":\"O(m)\",\"related_data_structures\":[\"部分匹配表（LPS数组）\",\"暴力匹配算法（BF算法）\",\"Rabin-Karp算法\",\"Boyer-Moore算法\"],\"key_steps\":[\"预处理模式串生成LPS数组：初始化LPS数组（长度与模式串相同），使用双指针（i指向当前位置，j指向最长公共前后缀的长度）遍历模式串，若当前字符匹配则i和j同时递增并设置LPS[i]=j，否则调整j为LPS[j-1]（若j>0）或j=0（若j=0）\",\"文本串与模式串匹配：初始化文本串指针i=0、模式串指针j=0，遍历文本串，若当前字符匹配则i和j同时递增；若j等于模式串长度则匹配成功（记录位置后调整j=LPS[j-1]继续查找）；若字符不匹配且j>0则j=LPS[j-1]，否则i递增；重复直到遍历完文本串\"]}",
  "0961610fad944891c49cd1bae44fe0f5": "{\"description\":\"一种简单的交换排序算法，通过重复遍历待排序序列，比较并交换相邻逆序元素，使较大元素逐步“浮”到序列末端，直至整体有序\",\"principle\":\"基于相邻元素的比较与交换操作，每一轮遍历将当前未排序部分的最大元素移动至正确位置，重复此过程直到无交换发生（表示序列已序）\",\"applicable_conditions\":\"适用于小规模数据排序场景或算法教学演示，对数据初始状态不敏感，但效率较低不适合大规模数据\",\"time_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n²)\",\"worst_case\":\"O(n²)\"},\"space_complexity\":\"O(1)\",\"related_data_structures\":[\"数组（Array）\",\"列表（List）\"],\"key_steps\":[\"遍历待排序数组从首元素到倒数第二个元素\",\"比较当前元素与下一个元素的大小关系\",\"若逆序则交换两元素位置\",\"重复遍历直到某轮无交换发生\",\"每轮遍历后缩小未排序部分的范围\"]}",
  "939a28831fa18642f6609469e008daa5": "{\"description\":\"选择排序是一种简单的比较排序算法，其核心思想是通过反复从**未排序部分**中选取最小（或最大）元素，并将其放置在**已排序部分**的末尾，逐步构建有序序列\",\"principle\":\"将待排序数组划分为**已排序区间**（初始为空）和**未排序区间**（初始为整个数组）。每次迭代时，从**未排序区间**中遍历找到最小元素的索引，将该元素与未排序区间的**第一个元素**交换位置——此时该元素被归入已排序区间的末尾。重复此过程，直到未排序区间缩至空（或仅含一个元素，无需排序）\",\"applicable_conditions\":\"适用于数据量较小的场景（如n≤1000），或对内存空间要求严格的环境（原地排序，无需额外辅助空间）；不适用于大规模数据或需要高效平均性能的场景\",\"time_complexity\":{\"best_case\":\"O(n²)\",\"average_case\":\"O(n²)\",\"worst_case\":\"O(n²)\"},\"space_complexity\":\"O(1)\",\"related_data_structures\":[\"Array（数组）\"],\"key_steps\":[\"初始化：已排序区间为空，未排序区间为整个数组\",\"遍历未排序区间：找到其中最小元素的索引min_idx\",\"交换：将min_idx对应的元素与未排序区间的第一个元素交换，使该最小元素归入已排序区间的末尾\",\"重复：缩小未排序区间（从下一个元素开始），再次执行步骤2-3，直到未排序区间只剩一个元素（或为空）\"]}",
  "d93a2cecdc230662b3dee7ae0045082e": "{\"description\":\"广度优先搜索（Breadth-First Search, BFS）是一种用于遍历或搜索树、图等数据结构的分层算法，从起始节点出发，优先访问当前节点的所有邻接节点（同一层节点），再依次处理邻接节点的下一层节点，核心特征是按节点到起始点的距离（边数）递增顺序访问，常用于求解无权图的最短路径问题\",\"principle\":\"基于队列（FIFO，先进先出）的数据结构实现，通过维护队列存储待访问节点：起始节点入队后，每次取出队首节点处理，将其未访问邻接节点标记并入队，保证节点按距离递增顺序访问，避免重复遍历\",\"applicable_conditions\":\"适用于无权图最短路径查找（如迷宫最短路径）、树的层序遍历（如二叉树按层输出）、图连通性检查（如判断两节点是否连通）、状态空间搜索（如八数码问题状态扩展）等场景\",\"time_complexity\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"},\"space_complexity\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"related_data_structures\":[\"队列（Queue）\",\"哈希表（Hash Table）\",\"数组（Array）\"],\"key_steps\":[\"初始化队列，将起始节点入队并标记为已访问\",\"循环：若队列非空，取出队首节点并处理（如记录/输出）\",\"遍历当前节点的所有未访问邻接节点，标记为已访问并加入队列尾部\",\"重复上述循环直到队列为空\"]}",
  "84237f12c94c26561dd9f0ea35fba06e": "{\n  \"description\": \"插入排序是一种简单直观的比较排序算法，通过逐步构建有序序列，对每个未排序元素在已排序序列中从后向前扫描以找到正确插入位置，最终完成整个数组的排序\",\n  \"principle\": \"借鉴人类整理手牌的逻辑：初始将第一个元素视为有序序列，后续每个元素作为待插入项，从已排序序列末尾向前比较，若已排序元素大于待插入项则后移，直至找到不大于待插入项的位置并插入，逐步扩大有序区域至整个数组\",\n  \"applicable_conditions\": \"适用于小规模数据（n通常小于1000）、数据接近有序（如部分元素已处于正确位置）或需要稳定排序的场景\",\n  \"time_complexity\": {\n    \"best_case\": \"O(n)\",\n    \"average_case\": \"O(n²)\",\n    \"worst_case\": \"O(n²)\"\n  },\n  \"space_complexity\": \"O(1)\",\n  \"related_data_structures\": [\"Array\"],\n  \"key_steps\": [\n    \"从数组第二个元素（索引1）开始遍历所有未排序元素\",\n    \"取出当前元素作为待插入值，保存其值和索引\",\n    \"从已排序序列的最后一个元素（当前元素前一位）向前比较：若已排序元素大于待插入值，则将该元素向后移动一位\",\n    \"当遇到小于等于待插入值的元素或到达数组开头时，停止比较并将待插入值放入当前位置\",\n    \"重复上述过程直到所有元素处理完毕\"\n  ]\n}",
  "a07040d9c53064399bc766b3551df64f": "{\"description\":\"归并排序（Merge Sort）是一种基于分治策略的稳定排序算法，通过递归地将数组划分为子数组、排序子数组并合并结果来实现整体有序\",\"principle\":\"基于分治（Divide-and-Conquer）思想，核心分为三个步骤：1.分解（Divide）：将待排序数组从中间分割为两个长度大致相等的子数组，重复此过程直到每个子数组仅含一个元素（自然有序）；2.解决（Conquer）：递归地对两个子数组进行排序；3.合并（Combine）：将两个已排序的子数组合并为一个更大的有序数组，此为算法关键\",\"applicable_conditions\":\"适用于需要稳定排序、处理大规模数据（尤其是外部排序如磁盘文件排序）、数据分布不敏感的场景；支持数组和链表结构，链表实现可优化空间复杂度\",\"time_complexity\":{\"best_case\":\"O(n log n)\",\"average_case\":\"O(n log n)\",\"worst_case\":\"O(n log n)\"},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_data_structures\":[\"数组（Array）\",\"链表（Linked List）\"],\"key_steps\":[\"分解：计算数组中点，递归分割左右子数组直至子数组长度为1；\",\"合并：创建临时数组，双指针遍历左右子数组，按顺序存入元素后拷贝回原数组；\",\"递归回溯：重复合并步骤直至所有子数组合并为完整有序数组\"]}",
  "cede926a2ec694a73617dc2e076f7e59": "{\"description\": \"堆排序（Heap Sort）是一种基于堆（Heap）数据结构的比较类排序算法，通过构建最大堆（升序排序）或最小堆（降序排序）并利用堆的极值性质实现排序，属于原地排序算法。\", \"principle\": \"堆排序的核心原理是利用堆的极值特性：最大堆的堆顶元素为当前堆的最大值。首先将待排序数组构建为最大堆，此时堆顶为全局最大值；接着交换堆顶与堆的最后一个元素，将最大值放置到正确的末尾位置；然后缩小堆的范围（排除已排序的末尾元素），并对新堆顶执行堆调整（Max-Heapify）以维持最大堆性质；重复交换、缩小范围和调整步骤，直到堆的大小为1，最终得到升序数组。\", \"applicable_conditions\": \"适用于需要原地排序（空间复杂度低）、对时间复杂度稳定性要求不高（堆排序不稳定）且数据规模较大的场景；要求输入数据存储在支持随机访问的结构（如数组）中，以便通过索引快速计算父节点（i//2）与子节点（2i+1、2i+2）的位置。\", \"time_complexity\": {\"整体\": {\"best_case\": \"O(n log n)\", \"average_case\": \"O(n log n)\", \"worst_case\": \"O(n log n)\"}}, \"space_complexity\": {\"整体\": \"O(1)\"}, \"related_data_structures\": [\"堆（Heap）\"], \"key_steps\": [\"构建最大堆：从数组的非叶子节点（索引n//2-1开始）遍历，对每个节点执行Max-Heapify操作，将数组转换为最大堆\", \"交换堆顶与堆尾：将堆顶的最大值与当前堆的最后一个元素交换，完成该元素的排序\", \"缩小堆范围：将堆的大小减1（排除已排序的末尾元素）\", \"堆调整：对新堆顶执行Max-Heapify，维持剩余元素的最大堆性质\", \"重复操作：循环执行交换、缩小范围和堆调整，直到堆的大小为1，数组完全排序\"]}",
  "096a8e54765482cd2c4aef93752ade7a": "{\"description\":\"对有向无环图（DAG）的顶点进行线性排序，使得对于图中每一条有向边(u, v)，顶点u在排序序列中始终位于顶点v之前。拓扑排序主要用于解决存在依赖关系的调度问题（如课程选修顺序、任务执行顺序等）。\",\"principle\":\"拓扑排序的核心原理基于两种经典方法：1. Kahn算法（贪心策略）：通过不断选择入度为0的顶点（即无未处理前置依赖的顶点）加入序列，逐步消除其对后续顶点的依赖；2. DFS逆后序遍历：通过深度优先搜索递归访问所有可达顶点，在递归回溯时将当前顶点加入结果栈，最终逆序栈中元素得到拓扑序列（确保父节点在子节点之后被记录，逆序后父节点在前）。\",\"applicable_conditions\":\"图必须是有向无环图（DAG）；图的顶点集可为空（空图的拓扑排序结果为空）。\",\"time_complexity\":{\"Kahn算法\":\"O(V+E)\",\"DFS逆后序算法\":\"O(V+E)\"},\"space_complexity\":{\"Kahn算法\":\"O(V)\",\"DFS逆后序算法\":\"O(V)\"},\"related_data_structures\":[\"邻接表（存储图结构）\",\"队列（Kahn算法维护入度为0的顶点）\",\"栈（DFS算法存储逆后序结果）\",\"数组（存储入度或访问状态）\"],\"key_steps\":[\"Kahn算法步骤：1. 构建图的邻接表表示，并计算每个顶点的入度（indegree数组）；2. 初始化队列，将所有入度为0的顶点加入队列；3. 初始化结果列表；4. 循环处理队列：取出队首顶点u，加入结果列表；遍历u的所有邻接顶点v，将v的入度减1；若v的入度变为0，将其加入队列；5. 若结果列表大小等于顶点总数，返回结果；否则图存在环，无法拓扑排序。\",\"DFS逆后序算法步骤：1. 构建图的邻接表表示，初始化访问状态数组（标记顶点是否已访问）和结果栈；2. 遍历所有顶点：若顶点未被访问，执行DFS递归；3. DFS递归函数：标记当前顶点为已访问；遍历当前顶点的所有邻接顶点，若未访问则递归调用DFS；将当前顶点压入结果栈；4. 将结果栈逆序（或弹出所有元素），得到拓扑排序序列。\"]}",
  "8a90fb31a8e124667017f94df155f0d0": "{\"description\":\"最小生成树（Minimum Spanning Tree, MST）算法用于在连通无向加权图中找到一棵包含所有顶点的生成树，使得树中所有边的权重之和最小。生成树是图的极小连通子图，包含所有顶点且无环，边数为顶点数减一\",\"principle\":\"基于贪心策略，核心思想是每次选择当前最优的局部解（即权重最小且不形成环的边），最终得到全局最优的最小生成树。经典实现分为两类：Kruskal算法通过对边按权重排序并利用并查集避免环来选边；Prim算法通过从起始顶点逐步扩展生成树，每次选择连接生成树与非生成树顶点的最小权重边\",\"applicable_conditions\":\"1. 图是连通的无向图；2. 图的边带有权重（权重可为任意实数，但图必须连通以保证存在生成树）\",\"time_complexity\":{\"Kruskal（并查集优化）\":\"O(E log E)\",\"Prim（邻接矩阵+线性查找）\":\"O(V²)\",\"Prim（邻接表+斐波那契堆）\":\"O(E + V log V)\"},\"space_complexity\":{\"Kruskal\":\"O(E + V)\",\"Prim（邻接表存储）\":\"O(V + E)\",\"Prim（邻接矩阵存储）\":\"O(V²)\"},\"related_data_structures\":[\"并查集（Disjoint Set Union, DSU）\",\"优先队列（Priority Queue）\",\"邻接表（Adjacency List）\",\"邻接矩阵（Adjacency Matrix）\"],\"key_steps\":\"Kruskal算法步骤：1. 将图中所有边按权重从小到大排序；2. 初始化并查集（每个顶点自成一个集合）；3. 依次遍历排序后的边，若边的两个顶点属于不同集合，则将该边加入生成树，并合并两个顶点所在的集合；4. 重复步骤3直到生成树包含V-1条边（V为顶点数）。Prim算法步骤：1. 选择任意起始顶点，初始化距离数组（记录每个顶点到当前生成树的最小权重，起始顶点距离为0，其余为无穷大）和访问数组（标记顶点是否已加入生成树）；2. 重复V次：a. 选取距离最小且未访问的顶点u，标记为已访问；b. 遍历u的所有邻接边（u, v），若v未访问且边权重小于v当前的距离值，则更新v的距离值；3. 收集所有被选中的边（即用于更新距离值的边）以构成最小生成树\"}",
  "7402fc8339bebe291f938b8985b77a67": "{\"description\":\"直接插入排序（Insertion Sort）是一种简单直观的比较排序算法，核心思想是将待排序序列逐步构建为已排序序列，每次将未排序部分的第一个元素插入到已排序部分的正确位置，使已排序部分不断扩展直至整个序列有序\",\"principle\":\"将输入数组划分为已排序（初始含第一个元素）和未排序（含剩余元素）两部分；对每个未排序元素，从已排序部分末尾向前比较，若已排序元素大于当前元素则向后移动，找到小于等于当前元素的位置后，将当前元素插入该位置\",\"applicable_conditions\":\"适用于小规模数据排序（如n≤1000）、部分有序序列（接近有序或逆序程度低），也作为复杂排序算法（如归并、快速排序）的子过程处理小规模子数组\",\"time_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n²)\",\"worst_case\":\"O(n²)\"},\"space_complexity\":\"O(1)\",\"related_data_structures\":[\"数组（Array）\",\"链表（Linked List）\",\"冒泡排序（Bubble Sort）\",\"选择排序（Selection Sort）\"],\"key_steps\":[\"1. 初始化已排序部分：将数组第一个元素作为初始已排序序列\",\"2. 遍历未排序部分：从第二个元素开始依次处理每个未排序元素\",\"3. 查找插入位置：当前元素与已排序部分从后往前比较，移动大于当前元素的已排序元素\",\"4. 插入当前元素：将当前元素放入找到的插入位置\",\"5. 重复处理所有未排序元素直至序列有序\"]}",
  "8adcccc4cc57b84de7843edfd790d1bd": "{\"description\":\"基数排序（Radix Sort）是一种非比较型整数排序算法，通过按数字的每一位（从最低有效位到最高有效位或反之）依次进行稳定排序来实现整体有序，核心是利用稳定的子排序算法（通常为计数排序）处理每一位，避免高位排序破坏低位已形成的顺序\",\"principle\":\"基数排序基于位权展开的思想，将整数按位数拆分为不同的位（如个位、十位、百位等），从最低有效位（Least Significant Digit, LSD）或最高有效位（Most Significant Digit, MSD）开始，对每一位使用稳定的排序算法（如计数排序）进行排序。由于子排序算法的稳定性，低位已排好的顺序会被高位排序保留，最终所有位处理完毕后整个序列有序\",\"applicable_conditions\":\"1. 输入元素必须是整数或可表示为固定位数的结构化数据（如日期、电话号码、字符串等）；2. 元素的位数可统一（若位数不同，需用前导零补全）；3. 需使用稳定的子排序算法（如计数排序）来处理每一位；4. 适用于元素范围较大但位数较少的场景（如排序大量电话号码）\",\"time_complexity\":{\"best_case\":\"O(d*(n+k))\",\"average_case\":\"O(d*(n+k))\",\"worst_case\":\"O(d*(n+k))\"},\"space_complexity\":\"O(n+k)\",\"related_data_structures\":[\"计数排序（Counting Sort）\",\"数组（Array）\"],\"key_steps\":[\"1. 确定输入序列中的最大元素，计算其位数d（即所有元素的最大位数）；2. 选择排序方向（通常从最低有效位LSD开始）；3. 对每一位（从第1位到第d位）执行以下操作：a. 使用稳定的计数排序算法，根据当前位的数字值对序列进行排序；b. 更新序列为当前位排序后的结果；4. 当所有d位处理完毕后，序列整体有序\"]}",
  "e4f22d1328e4a15055f080d00fa288ca": "{\n  \"description\": \"希尔排序（Shell Sort）是插入排序的优化变体，通过引入递减的“增量间隔”将数组划分为多个子数组，对每个子数组独立执行插入排序，逐步缩小间隔至1，最终以普通插入排序完成全局排序\",\n  \"principle\": \"利用插入排序在“基本有序数组”上的高效性（接近O(n)），通过“分组预排序”策略先让数组整体趋向有序：较大间隔的分组排序减少元素的“逆序对”数量，后续更小间隔的排序逐步细化，最后间隔1的插入排序因数组已接近有序而大幅降低时间成本。增量序列的选择直接决定算法性能\",\n  \"applicable_conditions\": \"适用于中等规模数据（如数千至数万条）、对稳定性无要求的场景；不适用于数据量极大（需快速排序等更优算法）或极小（普通插入排序更简洁）、或要求绝对稳定的场景\",\n  \"time_complexity\": {\n    \"best_case\": \"O(n)（数组完全有序时，所有增量下的插入排序均只需线性比较）\",\n    \"average_case\": \"介于O(n log n)与O(n²)之间（依赖增量序列，常见如Sedgewick增量下约O(n^1.3)）\",\n    \"worst_case\": \"依赖增量序列：原始Shell增量（n/2, n/4,...1）为O(n²)；Hibbard增量（1,3,7,...,2^k-1）为O(n^(3/2))；Sedgewick增量为O(n^(4/3))\"\n  },\n  \"space_complexity\": \"O(1)（原地排序，仅需常数级额外空间存储增量和临时变量）\",\n  \"related_data_structures\": [\"插入排序（基础依赖）\", \"数组（依赖随机访问特性）\"],\n  \"key_steps\": [\n    \"选择增量序列（如Hibbard序列、Sedgewick序列等）\",\n    \"遍历增量序列中的每个gap：将数组划分为若干逻辑子数组（元素间隔为gap）\",\n    \"对每个逻辑子数组执行插入排序（将子数组内的元素逐个插入到正确位置）\",\n    \"按增量序列递减gap，重复分组排序步骤\",\n    \"当gap=1时执行最后一次插入排序（此时数组已基本有序，插入排序效率极高）\"\n  ]\n}",
  "e55c22c4fb157cc5607c89d423f35bab": "{\"description\": \"普里姆（Prim）算法是一种用于求解加权无向连通图的最小生成树（Minimum Spanning Tree, MST）的贪心算法。该算法从任意起始顶点出发，通过逐步选择连接当前生成树与未包含顶点的最小权重边，最终构造出包含所有顶点且边权总和最小的无环连通子图。\", \"principle\": \"基于贪心策略和切割性质（Cut Property）：对于图的任意切割（将顶点集划分为两个非空且不相交的子集），若某条边是该切割的最小权重边且连接两个子集，则这条边必然属于图的最小生成树。算法通过维护每个未包含顶点到当前生成树的最小距离，每次选择距离最小的顶点加入生成树，并更新其邻接顶点的距离，逐步扩展生成树直至覆盖所有顶点。\", \"applicable_conditions\": \"1. 图为无向图；2. 图是连通的（任意两顶点间有路径）；3. 图的边具有实数权重（无正负限制，但需保证图存在最小生成树）。\", \"time_complexity\": {\"邻接矩阵+线性查找\": \"O(V²)\", \"邻接表+二叉堆\": \"O(E log V)\", \"邻接表+斐波那契堆\": \"O(E + V log V)\"}, \"space_complexity\": {\"邻接矩阵实现\": \"O(V²)\", \"邻接表实现\": \"O(V + E)\"}, \"related_data_structures\": [\"最小优先队列（Min-Priority Queue）\", \"邻接矩阵（Adjacency Matrix）\", \"邻接表（Adjacency List）\"], \"key_steps\": [\"1. 初始化：选择起始顶点s，标记s为已加入生成树；初始化距离数组dist[]，其中dist[s] = 0（起始顶点到自身的距离为0），其余顶点的dist值设为无穷大（∞）；\", \"2. 重复以下操作直至所有顶点均加入生成树：\", \"   a. 查找未加入生成树的顶点中dist值最小的顶点u（即当前距离生成树最近的未包含顶点）；\", \"   b. 将u加入生成树，并记录u与生成树的连接边（若需构建树的结构）；\", \"   c. 遍历u的所有邻接顶点v：若v未加入生成树，且边(u, v)的权重w(u, v)小于v当前的dist值，则更新dist[v] = w(u, v)（更新v到生成树的最小距离）。\"]}",
  "2c3f21ec199f2edb944566a96520cb33": "{\n  \"description\": \"克鲁斯卡尔（Kruskal）算法是一种基于贪心策略的算法，用于求解加权无向图的最小生成树（Minimum Spanning Tree, MST）。该算法通过按边权值从小到大的顺序选择边，同时避免形成环，最终得到包含图中所有顶点且边权和最小的生成树\",\n  \"principle\": \"基于贪心选择性质：每次选择当前权值最小且不会与已选边形成环的边加入生成树。利用并查集（Disjoint Set Union, DSU）数据结构高效检测环：若边的两个顶点属于不同的连通分量，则加入该边不会形成环，否则会形成环\",\n  \"applicable_conditions\": \"适用于连通的加权无向图（若图不连通，则生成最小生成森林）；需处理边权为任意实数的场景，目标是找到包含所有顶点且边权和最小的生成树\",\n  \"time_complexity\": {\n    \"best_case\": \"O(E log E)\",\n    \"average_case\": \"O(E log E)\",\n    \"worst_case\": \"O(E log E)\"\n  },\n  \"space_complexity\": \"O(V + E)，其中V为图的顶点数，E为图的边数（用于存储所有边及并查集结构）\",\n  \"related_data_structures\": [\"并查集（Disjoint Set Union, DSU）\", \"排序算法（如快速排序、归并排序）\"],\n  \"key_steps\": [\n    \"1. 边排序：将图中所有边按权值从小到大进行排序\",\n    \"2. 初始化并查集：为每个顶点创建独立的集合（每个顶点自成一个连通分量）\",\n    \"3. 遍历边集：按排序后的顺序依次处理每条边(u, v)\",\n    \"4. 环检测：使用并查集的find操作，判断u和v是否属于同一连通分量\",\n    \"5. 合并与选边：若u和v不属于同一连通分量，使用union操作合并两个集合，并将该边加入最小生成树\",\n    \"6. 终止条件：当最小生成树包含n-1条边（n为顶点数）时停止，此时已覆盖所有顶点且边权和最小\"\n  ]\n}",
  "66babf14535d2666f1b14d3f0d35ca28": "{\"description\": \"弗洛伊德算法（Floyd-Warshall Algorithm）是一种用于求解带权图中所有顶点对之间最短路径的动态规划算法，可处理存在负权边的情况，但无法处理包含负权环的图\", \"principle\": \"基于动态规划思想，通过逐步引入中间顶点松弛所有顶点对的最短路径。状态定义为d[k][i][j]（表示经过前k个顶点时i到j的最短路径长度），状态转移方程为d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k] + d[k-1][k][j])；通过滚动数组优化将三维状态压缩为二维，直接在原始距离矩阵上迭代更新\", \"applicable_conditions\": \"1. 图类型：有向或无向的带权图；2. 边权限制：允许负权边，但图中不能存在负权环（否则顶点到自身的最短路径无意义）；3. 问题需求：需求解所有顶点对之间的最短路径\", \"time_complexity\": {\"best_case\": \"O(n³)\", \"average_case\": \"O(n³)\", \"worst_case\": \"O(n³)\"}, \"space_complexity\": \"优化前为O(n³)，优化后通过滚动数组压缩为O(n²)（实际应用中通常采用O(n²)）\", \"related_data_structures\": [\"邻接矩阵（存储顶点间直接边权，适用于密集图）\", \"动态规划表（二维数组存储中间及最终最短路径长度）\"], \"key_steps\": [\"1. 初始化距离矩阵：d[i][j]设为i到j的直接边权（无边时为无穷大），d[i][i]设为0；2. 迭代更新：遍历每个中间顶点k（1到n），再遍历所有顶点对(i,j)，用d[i][j] = min(d[i][j], d[i][k] + d[k][j])更新最短路径；3. 负权环检测：若存在d[i][i] < 0，说明图含负权环，算法失效；4. 输出结果：最终d[i][j]即为i到j的最短路径长度\"}}",
  "6c3c02f57cc943cc6307b20a72c66f93": "{\"description\":\"迪杰斯特拉算法（Dijkstra's Algorithm）是一种单源最短路径算法，用于计算图中从一个指定源节点到所有其他节点的最短路径长度，要求图中所有边的权重非负\",\"principle\":\"基于贪心策略，核心思想是维护未确定最短路径的节点集合，每次从中选择距离源节点最近的节点（该节点的最短路径此时已确定），再以该节点为中间点更新其邻接节点的当前最短距离（松弛操作），重复此过程直到所有节点的最短路径均被确定\",\"applicable_conditions\":\"1. 图的边权重全部非负；2. 求解单源最短路径问题（单个源节点到所有其他节点）；3. 图为有向图或无向图\",\"time_complexity\":{\"best_case\":\"O(M + N log N)（斐波那契堆实现）\",\"average_case\":\"O(M log N)（二叉堆实现）\",\"worst_case\":\"O(M log N)（二叉堆实现）\"},\"space_complexity\":{\"best_case\":\"O(M + N)\",\"average_case\":\"O(M + N)\",\"worst_case\":\"O(M + N)\"},\"related_data_structures\":[\"优先队列（Priority Queue，用于高效获取当前距离最小的节点）\",\"邻接表（Adjacency List，用于存储图结构并遍历邻接节点）\",\"数组/哈希表（Array/Hash Table，用于存储节点的最短距离）\"],\"key_steps\":[\"初始化：源节点距离设为0，其他节点设为无穷大，所有节点标记为未访问\",\"将所有节点按当前距离插入优先队列（最小堆）\",\"取出队列中距离最小的节点u，标记为已访问\",\"遍历u的邻接节点v：计算新距离（dist[u]+边权u→v），若新距离更小则更新v的距离并调整队列位置\",\"重复步骤3-4直到队列为空，所有节点的最短距离确定\"]}",
  "25408089a7aec1cc556aa51ade0fbc49": "{\"description\":\"分治法（Divide and Conquer）是一种基于递归的算法设计范式，核心思想是将规模较大的复杂问题分解为多个规模较小、结构相同或相似的子问题，递归解决子问题后合并其解得到原问题的解\",\"principle\":\"分治法基于问题的可分解性、子问题独立性与解的可合并性：1. 分解性：原问题可拆分为结构一致的子问题；2. 独立性：子问题间无依赖；3. 可合并性：子问题解能合并为原问题解；4. 终止条件：子问题规模足够小时直接求解（基本情况）\",\"applicable_conditions\":\"适用于满足以下条件的问题：1. 小规模时易解决；2. 可分解为同类型子问题（最优子结构）；3. 子问题解可合并；4. 子问题无重叠（否则动态规划更优）\",\"time_complexity\":{\"递归式\":\"T(n) = aT(n/b) + f(n)（a≥1为子问题数，b>1为规模缩小比例，f(n)为分解与合并时间）\",\"best_case\":\"取决于具体问题（如归并排序为O(n log n)）\",\"average_case\":\"取决于具体问题（如归并排序为O(n log n)）\",\"worst_case\":\"取决于具体问题（如快速排序为O(n²)、归并排序为O(n log n)）\"},\"space_complexity\":{\"递归栈空间\":\"O(log n)（子问题等分时光递归深度）\",\"额外空间\":\"取决于合并步骤（如归并排序需O(n)、快速排序无需额外）\",\"best_case\":\"O(log n)（如快速排序最好情况）\",\"average_case\":\"O(log n)（如快速排序平均情况）\",\"worst_case\":\"O(n)（如归并排序或快速排序最坏递归深度）\"},\"related_data_structures\":[\"数组\",\"二叉树\",\"链表\"],\"key_steps\":[\"分解（Divide）：将原问题划分为规模更小、结构一致且独立的子问题\",\"解决（Conquer）：递归求解子问题，规模足够小时直接返回解（基本情况）\",\"合并（Combine）：将子问题解合并为原问题解，是影响效率的关键步骤\"]}",
  "925b67aafa532ecb33f4660c8fe9a1cd": "{\"description\": \"贪心策略（Greedy Strategy）是一种启发式算法设计范式，核心思想是在每一步决策中选择当前状态下的局部最优解，逐步构建全局最优解。它不回溯调整之前的选择，依赖问题本身的贪心选择性质和最优子结构性质来保证局部最优能累积成全局最优。\", \"principle\": \"1. 贪心选择性质：问题的全局最优解可通过一系列局部最优选择（贪心选择）获得，每一步选择仅依赖当前状态，无需回溯；2. 最优子结构性质：原问题的最优解包含其子问题的最优解，即子问题的最优解可组合成原问题的最优解。\", \"applicable_conditions\": \"问题必须同时满足以下两个核心条件：1. 贪心选择性质：局部最优选择能够直接导向全局最优解；2. 最优子结构性质：原问题的最优解可以分解为子问题的最优解的组合。\", \"time_complexity\": {\"典型问题时间复杂度\": {\"活动选择\": {\"best_case\": \"O(n log n)\", \"average_case\": \"O(n log n)\", \"worst_case\": \"O(n log n)\"}, \"哈夫曼编码\": {\"best_case\": \"O(n log n)\", \"average_case\": \"O(n log n)\", \"worst_case\": \"O(n log n)\"}, \"Prim算法（邻接矩阵）\": {\"best_case\": \"O(V²)\", \"average_case\": \"O(V²)\", \"worst_case\": \"O(V²)\"}, \"Kruskal算法\": {\"best_case\": \"O(E log E)\", \"average_case\": \"O(E log E)\", \"worst_case\": \"O(E log E)\"}}}, \"space_complexity\": {\"一般情况\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"}}, \"related_data_structures\": [\"优先队列（Priority Queue）\", \"并查集（Disjoint Set Union, DSU）\", \"数组（Array）\", \"图（Graph）\", \"列表（List）\"], \"key_steps\": [\"1. 问题建模：将原问题转化为可逐步选择局部最优解的形式，明确解的构成要素；2. 贪心准则设计：定义“局部最优”的判断标准（如活动选择中选结束时间最早的活动）；3. 迭代选择：按贪心准则选择当前最优元素加入解集合，并排除冲突元素；4. 约束验证：确保所选元素满足问题约束（如活动不重叠、生成树连通）；5. 终止检查：当解集合完整或无更多可选元素时终止，输出解\"]}",
  "d0cb7e563b7906f1238ab48d3dc84d9a": "{\"description\": \"动态规划（Dynamic Programming, DP）是一种通过将原问题分解为重叠子问题，求解每个子问题并存储其解以避免重复计算，从而高效解决具有最优子结构性质问题的算法设计范式。\", \"principle\": \"1. 最优子结构：原问题的最优解包含其子问题的最优解，即可以通过子问题的最优解构造原问题的最优解；2. 重叠子问题：求解原问题时会重复遇到相同的子问题实例，通过存储子问题的解可避免重复计算；3. 无后效性：子问题的解一旦确定，不会被后续更大规模问题的求解所影响（即未来的决策仅依赖当前状态，与状态的获取路径无关）。\", \"applicable_conditions\": \"问题需同时满足两个核心条件：（1）最优子结构：原问题的最优解可由其子问题的最优解组合而成；（2）重叠子问题：求解过程中存在大量重复的子问题，重复计算的代价过高。\", \"time_complexity\": {\"子问题数量 × 每个子问题的处理时间\": \"O(Θ)，其中Θ为子问题规模相关的复杂度（例如矩阵链乘法为O(n³)，斐波那契数列自底向上为O(n)，最长公共子序列为O(mn)，m、n为输入序列长度）\"}, \"space_complexity\": {\"存储子问题解的空间\": \"O(Θ)（例如斐波那契数列自底向上用一维数组为O(n)，矩阵链乘法用二维数组为O(n²)；部分问题可通过空间优化降低复杂度，如0-1背包问题优化后为O(W)，W为背包容量）\"}, \"related_data_structures\": [\"数组（用于自底向上的 tabulation 存储子问题解，如斐波那契数列）\", \"哈希表（用于自顶向下的 memoization 存储子问题解，如递归求解斐波那契数列）\", \"二维表格（用于多维度子问题的状态存储，如矩阵链乘法、最长公共子序列）\"], \"key_steps\": \"1. 定义子问题与状态：将原问题分解为规模更小的同类子问题，用状态（如dp[i]、dp[i][j]）表示子问题的解（例如dp[i]表示第i个斐波那契数，dp[i][j]表示矩阵链i到j的最小计算代价）；2. 推导状态转移方程：建立原问题与子问题之间的递归关系，描述如何通过子问题的解得到原问题的解（例如斐波那契数列的dp[n] = dp[n-1] + dp[n-2]，矩阵链乘法的dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]p[k]p[j])，i≤k<j）；3. 初始化基础情况：确定最小规模子问题的解（即无法再分解的子问题），如斐波那契数列的dp[0]=0、dp[1]=1，矩阵链乘法的dp[i][i]=0；4. 计算子问题解：选择自底向上（tabulation，从最小子问题开始依次计算更大规模的子问题，确保计算当前子问题时所需的子问题已解决）或自顶向下（memoization，递归求解子问题，若子问题已解则直接返回存储的结果）的方式填充状态表；5. 构造最优解（可选）：若需要输出具体的最优解而非仅最优值，需记录状态转移过程中的选择（如矩阵链乘法中记录分割点k），通过回溯状态表得到最优解的具体路径。\"}",
  "87525c4d0e7411427d4e8bed4f54c2cf": "{\"description\":\"插值查找是二分查找的改进版查找算法，针对有序且数据分布均匀的数组，通过计算目标值在数组中的估计位置（而非固定取中间位置）来更高效地缩小查找范围，适用于数据分布均匀时的快速查找场景\",\"principle\":\"基于目标值与数组首尾元素的数值比例估计目标位置，核心公式为mid = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])（假设数组升序）；通过比较mid位置元素与目标值的大小，调整查找范围的上下界（若arr[mid]<target则缩小至右半部分，否则缩小至左半部分），重复此过程直到找到目标或范围无效\",\"applicable_conditions\":\"1. 数组必须有序（升序或降序，需对应调整插值公式）；2. 数组元素的数据分布相对均匀（否则估计位置误差大，效率接近线性查找）；3. 数组支持随机访问（如连续存储的数组结构，可O(1)访问任意索引元素）\",\"time_complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log log n)\",\"worst_case\":\"O(n)\"},\"space_complexity\":{\"递归实现\":\"O(log n)\",\"非递归实现\":\"O(1)\"},\"related_data_structures\":[\"有序数组\",\"二分查找\"],\"key_steps\":[\"初始化查找范围的下界low为0，上界high为数组长度减1\",\"循环条件：当low ≤ high且目标值target介于arr[low]和arr[high]之间时，执行以下步骤\",\"根据插值公式计算中间位置mid：mid = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])\",\"比较arr[mid]与target：若相等则返回mid（找到目标）；若arr[mid] < target，则将low更新为mid + 1（目标在右半部分）；否则将high更新为mid - 1（目标在左半部分）\",\"循环结束后，若未找到目标则返回-1（或表示目标不存在的标识）\"]}",
  "27a0a0cbf1317661a8a18ee5b903d7da": "{\"description\":\"折半查找（Binary Search）是一种针对有序数组的高效查找算法，通过不断将查找区间减半来定位目标元素，适用于静态数据且需频繁查找的场景\",\"principle\":\"基于分治思想，将有序数组的查找区间从中间划分，比较中间元素与目标值：若相等则找到；若目标值更小则在左半区间继续查找；若更大则在右半区间继续，重复直到区间缩小为空（未找到）或找到目标\",\"applicable_conditions\":\"1. 数据结构为随机访问结构（如数组，支持O(1)时间访问任意位置元素）；2. 数据已按升序或降序排序；3. 数据静态（无频繁插入/删除操作，否则维护有序性成本高）\",\"time_complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"space_complexity\":{\"迭代实现\":\"O(1)\",\"递归实现\":\"O(log n)\"},\"related_data_structures\":\"有序数组\",\"key_steps\":[\"1. 初始化查找区间边界：左边界left=0，右边界right=数组长度-1\",\"2. 循环（或递归）：当left≤right时，计算中间位置mid=left+(right-left)//2（避免整数溢出）\",\"3. 比较中间元素arr[mid]与目标值target：a. 若相等，返回mid（找到目标）；b. 若target<arr[mid]，调整右边界right=mid-1（目标在左半区间）；c. 若target>arr[mid]，调整左边界left=mid+1（目标在右半区间）\",\"4. 若循环结束未找到，返回-1（或表示未找到的标记）\"]}",
  "a00374eeb955bd5fe4f633e5ce6119b9": "{\"description\":\"回溯法（Backtracking）是一种系统地搜索问题解空间的算法，通过尝试分步构建解的方式，当发现当前分步选择违反约束条件或无法达到目标时，回溯（撤销上一步选择）并尝试其他可能，直到找到所有可行解或确定无解。其核心是利用剪枝策略减少无效搜索，避免穷举所有可能。\",\"principle\":\"回溯法基于**解空间树**（将问题的所有可能解组织为树结构，根节点对应空解，子节点对应解的一个分量选择，叶子节点对应完整解），采用**深度优先搜索（DFS）**遍历解空间；通过**约束函数**（判断当前部分解是否违反问题的显式/隐式约束，如排列问题中“元素不重复”）剪枝无效分支，避免探索不可能产生可行解的路径；对于优化问题（如旅行商问题），还可通过**限界函数**（评估当前部分解延伸后的最优可能值，若该值不优于已知最优解则剪枝）进一步优化搜索效率。\",\"applicable_conditions\":\"1. 问题的解可表示为**n元组（x₁,x₂,…,xₙ）**，每个分量x_i取值于有限集合（如排列问题中x_i∈{1,2,…,n}且不重复）；2. 存在**约束条件**（显式约束：变量的取值范围；隐式约束：解的可行性条件，如八皇后的“不同列/对角线”），可用于排除无效分支；3. 需要搜索**所有可行解**（如子集和问题的所有子集）或**最优解**（如旅行商的最短路径），且解空间规模较大（需剪枝降低时间复杂度）；4. 解的构建具有**分步决策**特性，即每一步选择仅影响解的一个分量。\",\"time_complexity\":{\"best_case\":\"O(k)（k为找到第一个可行解所需的搜索步数，若提前终止搜索）\",\"average_case\":\"依赖于约束/限界函数的剪枝效果，通常介于O(k)与最坏情况之间\",\"worst_case\":\"O(b^d)（b为解空间树的平均分支因子，d为树的深度，即穷举所有可能的解空间）\"},\"space_complexity\":{\"best_case\":\"O(d)（d为解空间树的深度，即当前部分解的长度或递归栈深度）\",\"average_case\":\"O(d)\",\"worst_case\":\"O(d)\"},\"related_data_structures\":[\"栈（递归栈或迭代栈，用于回溯路径）\",\"树（解空间树，概念性结构）\",\"数组（存储当前部分解，如排列问题的当前序列）\",\"集合（记录已选元素，避免重复选择，如排列/组合问题）\"],\"key_steps\":[\"1. 定义解的结构：将问题解抽象为有序的部分解序列（如n元组），明确每个分量的取值范围；2. 构造解空间树：以空解为根节点，每个子节点对应解的一个分量的可能选择，叶子节点对应完整解；3. 设计约束函数：制定判断部分解是否合法的规则（如排除违反显式/隐式约束的选择）；4. 设计限界函数（优化问题）：制定评估部分解潜在最优性的规则（如当前路径成本加后续最小成本下界，若超过已知最优则剪枝）；5. 深度优先搜索：从根节点出发，递归地选择解的下一个分量，每步检查约束/限界函数：若满足则继续深入下一层；若不满足或达到叶子节点，则回溯至上一节点并尝试其他选择；6. 记录解：当部分解达到完整长度（叶子节点）时，保存可行解；若为优化问题，更新最优解。\"]}",
  "efc321d862112f89309eb864ff642ce4": "{\"description\":\"计数排序是一种非比较型整数排序算法，通过统计待排序数组中每个元素的出现次数，再根据次数信息重建有序数组，具有稳定性。\",\"principle\":\"利用待排序元素的值作为键，统计每个值的出现频率，通过前缀和计算确定每个元素在输出数组中的位置，最后按位置放置元素以得到有序结果，避免了比较操作。\",\"applicable_conditions\":\"适用于元素为整数（通常为非负，若含负数可通过偏移量调整）且取值范围（最大值与最小值的差）远小于元素个数的场景，否则空间复杂度会过高。\",\"time_complexity\":{\"best_case\":\"O(n + k)\",\"average_case\":\"O(n + k)\",\"worst_case\":\"O(n + k)\"},\"space_complexity\":\"O(n + k)\",\"related_data_structures\":[\"Array\"],\"key_steps\":[\"1. 确定范围：遍历待排序数组，找到最大值max和最小值min，计算取值范围size = max - min + 1；\",\"2. 统计次数：初始化大小为size的计数数组count，遍历待排序数组，对每个元素x，将count[x - min]加1以统计其出现次数；\",\"3. 前缀和计算：遍历计数数组count（从索引1开始），将每个元素更新为其与前一个元素的和，得到每个元素在输出数组中的最后位置；\",\"4. 构建输出：逆序遍历待排序数组（保持稳定性），对每个元素x，将其放入输出数组output的count[x - min] - 1位置，然后将count[x - min]减1；\",\"5. 结果复制（可选）：将输出数组output的内容复制回原数组，完成排序。\"]}",
  "73985b44a4a7fc723e459aaeea7c496b": "{\"description\":\"穷举法（又称暴力搜索法）是一种通过系统地遍历问题所有可能的候选解，逐一验证每个候选解是否满足问题条件，从而找到所有或最优解的算法策略。其不依赖启发式信息，直接穷尽所有可能性，是最基础的搜索策略之一\",\"principle\":\"核心原理是利用问题解空间的有限性与可枚举性，将求解过程转化为对候选解的全面遍历与验证。通过逐一检查每个候选解是否符合约束条件，保证解的完备性（不遗漏任何可能解）；若问题要求最优解且解空间可按优劣顺序遍历，则能确保找到绝对最优解\",\"applicable_conditions\":\"1. 解空间规模较小，遍历所有候选解的时间成本在实际场景中可接受；2. 无更高效的启发式算法（如贪心、动态规划）或数学优化方法；3. 候选解生成规则明确，可通过顺序、递推或递归等方式系统枚举；4. 需要获取所有精确解或绝对最优解，而非近似解；5. 解空间边界清晰，候选解数量有限（无无限延伸可能）\",\"time_complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(N)\",\"worst_case\":\"O(N)\"},\"space_complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(k)\"},\"related_data_structures\":[\"数组\",\"链表\",\"栈\",\"队列\",\"集合\"],\"key_steps\":\"1. 界定解空间：明确候选解的形式（如数值范围、组合方式）与边界条件，确定所有可能的候选解范围；2. 生成候选解：按预定义顺序（如顺序、深度优先、广度优先）系统生成候选解，确保不重复、不遗漏；3. 验证候选解：将候选解代入约束条件或目标函数，判断是否满足要求；4. 记录结果：若满足条件则记录解（需所有解则存储，需单个解则找到后终止）；5. 终止遍历：遍历完所有候选解后，返回结果\"}",
  "b007a71b1e550f1c569f0dae806f4a12": "{\n  \"description\": \"桶排序是一种基于分布的排序算法，通过将待排序元素映射到多个桶中，对每个桶内元素单独排序后合并所有桶内容以得到有序序列\",\n  \"principle\": \"利用映射函数将元素均匀分配到有限桶中，利用桶间有序性（桶的区间按顺序排列），通过桶内排序（如插入排序）和桶间合并实现整体排序\",\n  \"applicable_conditions\": \"1. 输入数据需服从均匀分布（或近似均匀分布）以避免桶负载失衡；2. 数据取值范围已知以确定桶的数量和区间；3. 桶数量k需合理选择（通常与n相关）\",\n  \"time_complexity\": {\n    \"best_case\": \"O(n)\",\n    \"average_case\": \"O(n)\",\n    \"worst_case\": \"O(n²)\"\n  },\n  \"space_complexity\": \"O(n + k)（k为桶数量）\",\n  \"related_data_structures\": [\"数组（存储桶集合）\", \"链表（桶内动态存储）\", \"插入排序（桶内排序常用算法）\"],\n  \"key_steps\": [\n    \"确定桶参数：根据数据范围（max-min）和桶数量k计算每个桶的区间范围\",\n    \"元素分配：遍历所有元素，通过映射函数将元素放入对应桶中\",\n    \"桶内排序：对每个非空桶使用插入排序处理\",\n    \"合并结果：按桶顺序依次拼接所有桶的有序元素\"\n  ]\n}",
  "3e76b7ff214707a9d60efcbc1e3972d2": "{\"description\":\"外部排序是一种用于处理数据量远超过内存容量的排序算法，通过分治策略将外存数据划分为可装入内存的块，逐块排序生成初始归并段，再通过多路归并将多个有序归并段合并为最终有序结果，核心是利用外存作为中间存储并优化读写次数\",\"principle\":\"基于分治思想，分为两个核心阶段：1. 生成初始归并段：将外存中的大数据集分割为若干大小不超过内存容量的块，逐块读入内存并使用内部排序算法（如堆排序、归并排序）排序后，写回外存形成有序的初始归并段；2. 多路归并：使用k路归并策略（k为归并路数），利用内存中的k个输入缓冲区和1个输出缓冲区，同时读取k个初始归并段的当前块到输入缓冲区，通过败者树或堆快速选出当前所有缓冲区中的最小元素，写入输出缓冲区，当输出缓冲区满时写回外存，当某输入缓冲区空时从对应的归并段读入下一块，重复此过程直到所有初始归并段合并为一个完整的有序段\",\"applicable_conditions\":\"待排序数据的总大小远大于内存可用存储容量，无法一次性将所有数据装入内存进行内部排序（如磁盘中的大型数据集排序）\",\"time_complexity\":{\"整体\":{\"best_case\":\"O(n log n)\",\"average_case\":\"O(n log n)\",\"worst_case\":\"O(n log n)\"},\"初始归并段生成\":{\"best_case\":\"O(n log m)\",\"average_case\":\"O(n log m)\",\"worst_case\":\"O(n log m)\"},\"多路归并\":{\"best_case\":\"O(n log_k r)\",\"average_case\":\"O(n log_k r)\",\"worst_case\":\"O(n log_k r)\"}},\"space_complexity\":{\"内存额外空间\":\"O((k+1)B)\",\"外存额外空间\":\"O(n)\"},\"related_data_structures\":[\"败者树\",\"堆（优先队列）\",\"缓冲区\"],\"key_steps\":[\"生成初始归并段：将外存数据分块读入内存，使用内部排序算法排序后写回外存，形成多个有序的初始归并段\",\"初始化多路归并缓冲区：分配k个输入缓冲区（对应k路归并）和1个输出缓冲区，读取每个初始归并段的第一块数据到对应的输入缓冲区\",\"归并选最小值：通过败者树或堆结构从k个输入缓冲区的当前元素中选出最小值，写入输出缓冲区\",\"缓冲区管理：当输出缓冲区满时，将数据写回外存；当某个输入缓冲区为空时，从对应的初始归并段中读取下一块数据到该缓冲区\",\"重复归并过程：持续执行选最小值、缓冲区读写操作，直到所有初始归并段的所有数据都被合并，最终得到一个完整的有序数据段\"]}",
  "dbe1bcc3bf04b0bf663ff7a150540a42": "{\"description\":\"单源最短路径算法是一类用于求解图中从某一特定源顶点到所有其他顶点的最短路径的算法统称，核心目标是找到源点到每个顶点的路径中边权之和最小的路径\",\"principle\":\"整体基于松弛（Relaxation）操作：对于边(u, v)，若源点到v的当前距离估计值大于源点到u的距离加上边权w(u, v)，则更新v的距离估计值和前驱顶点；不同子算法通过不同策略控制松弛的顺序和次数以保证正确性：Dijkstra算法采用贪心策略，每次选择当前距离最小的未处理顶点进行松弛（适用于非负权图）；Bellman-Ford算法通过V-1次遍历所有边进行松弛（适用于有负权边但无负权环的图）；SPFA算法是Bellman-Ford的队列优化，仅将可能被松弛的顶点加入队列以减少重复处理；DAG拓扑排序优化算法按拓扑序松弛所有边（适用于有向无环图，可处理负权边）\",\"applicable_conditions\":\"图可以是有向或无向；边权可正可负，但需满足：若存在负权边则图中不能有从源点可达的负权环（否则最短路径不存在）；不同子算法的具体适用条件：Dijkstra算法要求所有边权非负；Bellman-Ford和SPFA算法允许负权边但不允许源点可达的负权环；DAG拓扑排序优化算法要求图是有向无环图\",\"time_complexity\":{\"Dijkstra算法（邻接矩阵）\":{\"best_case\":\"O(V²)\",\"average_case\":\"O(V²)\",\"worst_case\":\"O(V²)\"},\"Dijkstra算法（斐波那契堆）\":{\"best_case\":\"O(E + V log V)\",\"average_case\":\"O(E + V log V)\",\"worst_case\":\"O(E + V log V)\"},\"Bellman-Ford算法\":{\"best_case\":\"O(VE)\",\"average_case\":\"O(VE)\",\"worst_case\":\"O(VE)\"},\"SPFA算法\":{\"best_case\":\"O(E)\",\"average_case\":\"O(E)\",\"worst_case\":\"O(VE)\"},\"DAG拓扑排序优化算法\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"}},\"space_complexity\":{\"Dijkstra算法（邻接矩阵）\":\"O(V²)\",\"Dijkstra算法（邻接表）\":\"O(V + E)\",\"Bellman-Ford算法\":\"O(V)\",\"SPFA算法\":\"O(V + E)\",\"DAG拓扑排序优化算法\":\"O(V + E)\"},\"related_data_structures\":[\"优先队列\",\"队列\",\"邻接矩阵\",\"邻接表\",\"数组\"],\"key_steps\":[\"初始化源点到各顶点的距离（源点为0，其余为无穷大）及前驱顶点（初始为未定义）\",\"对边(u, v)执行松弛操作：若dist[v] > dist[u] + w(u, v)，则更新dist[v]和前驱顶点\",\"根据算法策略重复松弛：Dijkstra选距离最小的未处理顶点松弛邻边，Bellman-Ford重复V-1次松弛所有边，SPFA用队列维护待松弛顶点，DAG按拓扑序松弛边\",\"（可选）检查负权环：Bellman-Ford第V次松弛仍能更新则存在，SPFA通过顶点入队次数超过V判断\"]}",
  "acf5788330f4856f30343888662f81a6": "{\"description\":\"一种基于优先级队列（或队列）的系统搜索算法，用于求解组合优化问题（如旅行商问题、0-1背包问题）。其核心思想是将解空间组织为树结构，通过限界函数估计节点的最优潜力，剪去无法产生更优解的分支，优先扩展最有希望的节点以快速找到全局最优解\",\"principle\":\"1. 解空间树建模：将问题的所有可能解表示为树状结构，根节点对应初始状态，每个子节点对应一次决策选择（如选择某个物品放入背包、选择下一个访问的城市）；2. 限界函数引导：为每个节点计算限界值（如下界或上界，反映从该节点出发能得到的最优解的极限），作为节点优先级的依据；3. 优先级扩展：使用优先队列（如最小堆用于最小化问题，最大堆用于最大化问题）维护待扩展节点，每次取出优先级最高的节点；4. 剪枝策略：若节点的限界值无法改进当前已知的最优解（如最小化问题中限界值≥当前最优解），则剪去该节点及其子树；否则扩展节点生成子节点，重复上述过程；5. 最优解更新：当扩展到叶节点时，其对应完整解，若优于当前最优解则更新\",\"applicable_conditions\":\"1. 问题类型：组合优化问题（需寻找最优解，如最小成本、最大收益）；2. 限界函数存在性：存在有效且可快速计算的限界函数，能准确估计节点的最优潜力；3. 解空间可树化：问题的解空间可组织为解空间树，每个节点对应部分解，子节点对应决策扩展；4. 剪枝有效性：限界函数需足够强，能显著减少待扩展节点数量（否则算法效率与暴力搜索相当）\",\"time_complexity\":{\"best_case\":\"O(b^d)（b为解空间树的分支因子，d为最优解所在的深度，限界函数高效剪枝时，快速找到最优解并停止搜索）\",\"average_case\":\"未定义（高度依赖限界函数的有效性、问题规模及解空间特性，无通用平均情况复杂度）\",\"worst_case\":\"O(b^n)（n为问题规模，如旅行商问题的城市数，限界函数无效时遍历整个解空间）\"},\"space_complexity\":{\"best_case\":\"O(b^d)（优先队列仅存储最优解路径附近的少量节点，空间占用小）\",\"average_case\":\"未定义（依赖限界函数和问题特性，无通用平均情况复杂度）\",\"worst_case\":\"O(b^n)（存储解空间树的所有节点，空间占用与暴力搜索相当）\"},\"related_data_structures\":[\"优先队列（堆，用于按限界值优先级管理待扩展节点）\",\"解空间树（逻辑结构，建模问题的所有可能解）\",\"队列（用于广度优先分支限界，如FIFO策略扩展节点）\"],\"key_steps\":[\"1. 构建解空间树：将问题的所有可能解组织为树结构，明确根节点（初始状态）、内部节点（部分解）和叶节点（完整解）的含义；2. 设计限界函数：根据问题目标（最大化/最小化）定义限界值计算方法（如下界函数用于最小化问题，上界函数用于最大化问题）；3. 初始化状态：创建优先队列，将根节点加入队列；初始化当前最优解为极端值（如最小化问题设为+∞，最大化问题设为-∞）；4. 循环扩展节点：a. 取出队列中优先级最高的节点（如最小堆的堆顶节点）；b. 若节点为叶节点，更新当前最优解（若该解更优）；c. 否则计算节点的限界值，若限界值优于当前最优解（如最小化问题中限界值<当前最优解），则生成所有子节点，计算子节点的限界值并加入优先队列；d. 若限界值不优于当前最优解，则剪枝（跳过该节点）；5. 终止与输出：当队列为空时，当前最优解即为全局最优解\"]}",
  "1cdf9afcc6ce0ae80008561793e0a46e": "{\"description\":\"一种基于哈希表结构的快速查找算法，通过哈希函数将关键字直接映射到哈希表中的对应位置，从而快速定位目标元素，核心是利用哈希函数实现直接寻址以降低查找时间复杂度\",\"principle\":\"哈希查找的核心原理是哈希函数的映射与冲突处理。首先通过哈希函数H将关键字key转换为哈希表的索引index=H(key)；然后检查哈希表中index位置的元素：若该元素与key匹配，则查找成功；若该位置存在其他不同key的元素（即冲突），则按照预设的冲突解决策略（如链地址法将冲突元素链表存储、开放寻址法探测下一个可用位置）继续查找，直至找到目标元素或遍历完所有可能位置确认不存在\",\"applicable_conditions\":\"1. 存在大量频繁的查找、插入或删除操作，需要高效的时间效率；2. 关键字能够通过哈希函数高效转换为有限范围内的整数索引；3. 可以接受一定的额外空间开销（哈希表存储）；4. 能够通过设计哈希函数（如降低冲突率）和选择冲突解决策略（如链地址法）来控制哈希表的负载因子（元素数量与表大小的比值），以保证性能\",\"time_complexity\":{\"查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"space\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"related_data_structures\":\"哈希表, 链表（链地址法冲突处理）, 数组（开放寻址法哈希表底层存储）\",\"key_steps\":\"1. 设计哈希函数：选择合适的哈希函数（如除法哈希法H(key)=key mod m，乘法哈希法H(key)=floor(m*(key*A - floor(key*A)))等），目标是尽量减少冲突；2. 初始化哈希表：根据哈希函数的输出范围确定哈希表的大小（通常大于等于预计元素数量以控制负载因子），并初始化表中的每个位置（如链地址法初始化为空链表，开放寻址法初始化为空）；3. 处理冲突：预先确定冲突解决策略（如链地址法将冲突元素添加到对应位置的链表中，开放寻址法使用线性探测、二次探测或双哈希法寻找下一个可用位置）；4. 执行查找操作：a. 计算目标关键字key的哈希值index=H(key)；b. 检查哈希表index位置的元素：若存在且等于key，返回结果；c. 若存在冲突（位置非空但元素不等于key），则按照冲突解决策略遍历下一个可能的位置（如链地址法遍历链表节点，开放寻址法探测下一个索引）；d. 若遍历完所有可能位置仍未找到，返回不存在\"}",
  "93d249d10f4e12443060e57f63742228": "{\"description\":\"Bellman-Ford算法是一种用于求解单源最短路径问题的算法，能够处理存在负权边的图，并且可以检测图中是否存在从源点可达的负权回路（即总权重为负的环）。\",\"principle\":\"基于松弛（Relaxation）操作的贪心策略：对于图中的每条边(u, v)，若从源点到u的距离加上边权w(u, v)小于当前源点到v的距离，则更新源点到v的距离。由于任意两点间的最短路径最多包含V-1条边（V为顶点数），因此只需对所有边进行V-1次松弛操作即可得到所有顶点的最短路径；若在第V次松弛时仍能更新距离，则说明图中存在从源点可达的负权回路。\",\"applicable_conditions\":\"1. 解决单源最短路径问题（即从一个源点出发到所有其他顶点的最短路径）；2. 图中可以存在负权边；3. 图可以是有向图或无向图（无向图中的负权边等价于负权回路）；4. 若需检测负权回路，则图需允许存在这样的回路。\",\"time_complexity\":{\"best_case\":\"O(V*E)\",\"average_case\":\"O(V*E)\",\"worst_case\":\"O(V*E)\"},\"space_complexity\":\"O(V)，主要用于存储源点到各顶点的最短距离数组（distance array）和前驱顶点数组（predecessor array），空间复杂度由顶点数决定。\",\"related_data_structures\":\"1. 图的表示结构（邻接表Adjacency List、邻接矩阵Adjacency Matrix）：用于存储图的顶点和边信息；2. Dijkstra算法：同为单源最短路径算法，但仅适用于非负权边，时间复杂度更优（基于优先队列优化时为O(E + VlogV)）；3. 队列（Queue）：用于优化Bellman-Ford的SPFA算法（Shortest Path Faster Algorithm），通过队列维护待松弛的顶点以减少不必要的松弛操作。\",\"key_steps\":\"1. 初始化：将源点到自身的距离设为0，到其他所有顶点的距离设为无穷大（∞），并初始化前驱顶点数组（如无前驱则设为-1或null）；2. 松弛操作：重复执行V-1次（V为顶点数），对图中的每条边(u, v)进行松弛：若distance[v] > distance[u] + weight(u, v)，则更新distance[v] = distance[u] + weight(u, v)，并更新前驱顶点为u；3. 负权回路检测：对图中的每条边再次进行松弛操作，若存在边(u, v)使得distance[v] > distance[u] + weight(u, v)，则说明图中存在从源点可达的负权回路；4. 输出结果：若不存在负权回路，则输出源点到各顶点的最短距离及路径（通过前驱数组回溯）；若存在负权回路，则输出相关提示。\"}",
  "d912a9e52f8b8901d2db3d1000a78b02": "{\"description\":\"二路归并是一种将两个已排序的数组（或子数组）合并为一个更大的已排序数组的算法，是归并排序的核心操作，主要用于合并分治策略中分解得到的有序子问题解。\",\"principle\":\"基于分治思想的合并阶段逻辑：通过两个指针分别遍历两个有序子数组，每次比较指针指向的元素，选择较小（或较大，依排序顺序而定）的元素放入辅助结果数组，并移动对应指针；当其中一个子数组遍历完毕后，将另一个子数组的剩余元素直接复制到结果数组末尾，最终得到完整的有序数组。\",\"applicable_conditions\":\"1. 输入的两个子数组必须已按同一规则（升序或降序）排序；2. 数据元素支持可比较的二元关系（如整数的大小、字符串的字典序）；3. 需提供足够的辅助空间以存储合并后的结果（若原地合并则需额外处理，但标准二路归并不支持原地操作）。\",\"time_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"space_complexity\":\"O(n)\",\"related_data_structures\":[\"数组（Array）\"],\"key_steps\":[\"初始化双指针i、j分别指向两个有序子数组的起始位置，辅助结果数组指针k指向起始位置（n为两子数组总长度，结果数组长度为n）；\",\"循环比较子数组A[i]与子数组B[j]：若A[i] ≤ B[j]，则将A[i]放入结果数组的k位置，i增1；否则将B[j]放入k位置，j增1；同时k增1；\",\"当i超过A的长度（即A遍历完毕），将B中从j开始的剩余元素复制到结果数组k位置之后；若j超过B的长度，则复制A的剩余元素；\",\"合并完成，结果数组即为包含A和B所有元素的有序数组。\"]}",
  "23e8f829d8a777151e7bd067777db129": "{\"description\":\"线性查找（又称顺序查找）是一种基础的查找算法，通过从数据结构的一端开始逐个遍历元素，与目标值比较直到找到匹配项或遍历结束\",\"principle\":\"从数据结构的起始位置出发，依次将每个元素与目标值进行相等性检查，若匹配则返回元素位置，若遍历完所有元素未匹配则判定目标不存在\",\"applicable_conditions\":\"适用于任意数据结构（如数组、链表、动态数组等），无论数据是否有序；适合小规模数据集合或无序数据的查找场景\",\"time_complexity\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"space_complexity\":\"O(1)\",\"related_data_structures\":\"数组、链表、动态数组\",\"key_steps\":\"1. 初始化遍历指针（如数组索引从0开始）；2. 依次将当前指针指向的元素与目标值比较；3. 若匹配，返回当前指针位置；4. 遍历至末尾未匹配，返回不存在标识（如-1）\"}",
  "5ee03b8c9b94b1df3d2b693c8107aafa": "{\"description\":\"记忆化搜索是一种结合递归搜索与动态规划思想的优化技术，通过存储已计算子问题的结果来避免重复计算，常用于解决具有重叠子问题和最优子结构特征的问题\",\"principle\":\"基于深度优先搜索（DFS）的递归框架，在递归过程中使用缓存（如数组、哈希表）存储每个子问题的解；当再次需要计算同一子问题时，直接返回缓存中的结果而非重新计算，从而将时间复杂度从指数级降低到多项式级\",\"applicable_conditions\":\"1. 问题具有重叠子问题特性（同一子问题被多次求解）；2. 问题具有最优子结构特性（原问题的最优解包含子问题的最优解）；3. 子问题的状态可通过有限参数唯一标识（即状态具有可哈希性或可索引性）\",\"time_complexity\":{\"best_case\":\"O(S*T)\",\"average_case\":\"O(S*T)\",\"worst_case\":\"O(S*T)\"},\"space_complexity\":{\"best_case\":\"O(S + D)\",\"average_case\":\"O(S + D)\",\"worst_case\":\"O(S + D)\"},\"related_data_structures\":[\"数组（Array）\",\"哈希表（Hash Table）\"],\"key_steps\":[\"定义子问题：将原问题分解为具有重叠性的子问题，明确子问题的状态参数（如斐波那契数列中第n项的状态参数为n）\",\"初始化缓存：创建缓存结构（数组或哈希表），用于存储已计算的子问题结果（初始时缓存为空或标记为未计算状态）\",\"递归求解：编写递归函数，针对当前状态首先检查缓存：若缓存中有结果则直接返回，否则递归计算子问题的解，并将结果存入缓存后返回\",\"求解原问题：调用递归函数处理原问题对应的初始状态，返回最终结果\"]}",
  "c7d6dd08d91ab0f90ef36c154588baed": "{\"description\":\"分块查找（Block Search），又称索引顺序查找，是一种结合顺序查找与二分查找优势的查找算法。其核心是将待查找数据集划分为若干块（子表），块内元素可无序，但块间必须满足严格有序性（即后一块所有元素的关键字均大于前一块所有元素的关键字）；同时为每个块构建索引项（包含块的最大关键字和起始地址），形成有序的索引表。查找时先通过索引表定位目标块，再在块内进行顺序查找。\",\"principle\":\"分块查找基于\\\"分块有序\\\"结构设计，原理分为三步：1. 分块处理：将原始数据集划分为若干块，块间满足关键字有序（第i块最大关键字<第i+1块最小关键字），块内无需排序；2. 构建索引表：为每个块创建索引项，记录块的最大关键字（用于块定位）和起始位置，索引表因块间有序而自身有序；3. 两阶段查找：首先在有序索引表中查找待查关键字所在块（可选用二分查找或顺序查找），然后在目标块内进行顺序查找（块内无序，仅能顺序查找）。\",\"applicable_conditions\":\"1. 数据集需满足\\\"分块有序\\\"：块间元素关键字严格递增（或递减），块内元素可无序；2. 需预先构建有序索引表，索引项包含块的最大关键字和起始地址；3. 适用于较大规模数据集，块大小通常取√n（n为数据总量）以平衡索引查找与块内查找效率；4. 支持动态数据调整，但需维护块间有序性（如插入时若块溢出需分裂块，删除时若块空需合并块）。\",\"time_complexity\":{\"索引二分查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(√n)\",\"worst_case\":\"O(√n)\"},\"索引顺序查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(√n)\",\"worst_case\":\"O(√n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_data_structures\":[\"索引表\",\"顺序查找\",\"二分查找\"],\"key_steps\":[\"分块处理：将原始数据划分为块间有序、块内无序的若干块\",\"构建索引表：为每个块创建包含最大关键字和起始地址的索引项，形成有序索引表\",\"索引查找：在有序索引表中查找待查关键字所在的目标块（二分或顺序查找）\",\"块内查找：在目标块内进行顺序查找，定位待查元素或确认不存在\"]}",
  "79c10fe034f850b4b3756ef06b798668": "{\"notation\":\"O(1)\",\"description\":\"常数时间复杂度，表示算法的运行时间不依赖于输入数据的规模（n），无论输入大小如何，操作所需时间始终保持恒定\",\"typical_cases\":[\"数组通过索引访问元素\",\"栈的push/pop操作\",\"队列的enqueue/dequeue操作（数组实现）\",\"哈希表的平均查找/插入/删除操作\"],\"explanation\":\"大O符号O(1)描述了算法时间复杂度的上界为常数。这意味着存在一个固定的常数C，对于所有足够大的输入规模n，算法的运行时间T(n) ≤ C。换句话说，操作的执行时间与输入数据的数量级无关，不会随n的增长而变化\",\"best_case\":{\"时间复杂度\":\"O(1)\"},\"average_case\":{\"时间复杂度\":\"O(1)\"},\"worst_case\":{\"时间复杂度\":\"O(1)\"},\"example\":\"对于数组arr = [1,2,3,4,5]，访问arr[2]时直接通过索引计算内存地址（如基地址+2×元素大小），无需遍历数组，执行时间恒定为O(1)；又如栈的push操作：当栈用数组实现时，stack.push(6)仅需将元素写入栈顶指针指向的位置并递增指针，操作时间不随栈中元素数量变化\"}",
  "47af4b0b882923df238cd39848230307": "{\"description\": \"状态转移是计算机科学中广泛应用于动态规划、有限自动机、图遍历等领域的核心机制，指通过当前状态和输入、决策或规则转换到下一状态的过程，用于描述问题的演化过程并求解最优解或状态序列\", \"principle\": \"基于对问题的状态抽象（状态需包含问题求解的关键信息，满足无后效性），通过预定义的状态转移规则（如动态规划中的状态转移方程、自动机中的转移函数），将原问题分解为子问题的状态演化过程，利用重叠子问题的重复性和最优子结构特性（动态规划场景）或确定的状态转换逻辑（自动机场景），逐步推导得到最终状态或解\", \"applicable_conditions\": \"1. 问题可建模为状态空间中的路径或演化问题，存在明确的状态定义；2. 存在清晰的状态转移规则，当前状态可通过规则推导下一状态；3. 状态空间规模可管理（避免无限状态或指数级增长导致无法计算）；4. 动态规划场景需满足最优子结构和无后效性\", \"time_complexity\": {\"动态规划（单变量状态链）\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"}, \"动态规划（二维状态网格）\": {\"best_case\": \"O(mn)\", \"average_case\": \"O(mn)\", \"worst_case\": \"O(mn)\"}, \"有限自动机（DFA/NFA）\": {\"best_case\": \"O(k)\", \"average_case\": \"O(k)\", \"worst_case\": \"O(k)\"},\"图的状态遍历（如BFS）\": {\"best_case\": \"O(V+E)\", \"average_case\": \"O(V+E)\", \"worst_case\": \"O(V+E)\"}}, \"space_complexity\": {\"动态规划（单变量状态链，未优化）\": {\"best_case\": \"O(n)\", \"average_case\": \"O(n)\", \"worst_case\": \"O(n)\"}, \"动态规划（二维状态网格）\": {\"best_case\": \"O(mn)\", \"average_case\": \"O(mn)\", \"worst_case\": \"O(mn)\"}, \"动态规划（单变量状态链，空间优化）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"}, \"有限自动机（DFA/NFA）\": {\"best_case\": \"O(1)\", \"average_case\": \"O(1)\", \"worst_case\": \"O(1)\"},\"图的状态遍历\": {\"best_case\": \"O(V)\", \"average_case\": \"O(V)\", \"worst_case\": \"O(V)\"}}, \"related_data_structures\": [\"数组（一维/二维，动态规划状态存储）\", \"状态转移表（有限自动机的转移规则存储）\", \"邻接表/邻接矩阵（图状态空间的存储）\", \"哈希表（动态状态的映射存储）\"], \"key_steps\": [\"1. 状态定义：抽象问题的关键特征为状态（如动态规划中dp[i]表示前i个元素的最优解，自动机中状态表示当前的匹配进度）；2. 转移规则推导：根据问题约束建立状态间的转换关系（如动态规划的状态转移方程、自动机的转移函数）；3. 初始状态初始化：设置问题的基准状态（如动态规划的边界条件dp[0]=0，自动机的初始状态q0）；4. 状态转移执行：按拓扑序（动态规划）、输入顺序（自动机）或遍历顺序（图）依次计算每个状态的值或转移路径；5. 结果提取：从最终状态（如dp[n]）或状态集合（如自动机的接受状态）中获取问题的解\"]}",
  "3f0f44266f73f9b1ae271263efc7b883": "{\"description\":\"多路归并（Multi-way Merge）是一种将多个已排序的输入序列合并为一个有序输出序列的算法，是外部排序（处理大规模离线数据）和多源有序数据整合的核心技术，能高效解决多组有序数据的合并问题\",\"principle\":\"基于最小堆（优先队列）实现全局最小值的快速查找与更新：维护一个大小等于输入序列数量k的最小堆，堆中元素存储当前各序列的未处理首元素值及所属序列信息；每次提取堆顶的全局最小元素加入结果，再从该元素所属序列中取出下一个元素插入堆以维持最小堆性质，反复执行直到所有元素处理完毕\",\"applicable_conditions\":\"1. 输入为k个互不相交的已排序序列（顺序需与堆类型一致，如升序对应最小堆）；2. 需求是将多组有序数据合并为单一有序序列；3. 适用于数据量超过内存容量的外部排序场景，或需要高效合并数据库查询结果、日志文件等多源有序数据的情况\",\"time_complexity\":{\"堆初始化\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"单次提取-插入操作\":{\"best_case\":\"O(logk)\",\"average_case\":\"O(logk)\",\"worst_case\":\"O(logk)\"},\"整体复杂度\":{\"best_case\":\"O(n logk)\",\"average_case\":\"O(n logk)\",\"worst_case\":\"O(n logk)\"}},\"space_complexity\":{\"额外堆空间\":{\"best_case\":\"O(k)\",\"average_case\":\"O(k)\",\"worst_case\":\"O(k)\"},\"整体空间（含输入输出）\":{\"best_case\":\"O(n + k)\",\"average_case\":\"O(n + k)\",\"worst_case\":\"O(n + k)\"}},\"related_data_structures\":[\"最小堆（优先队列）\",\"有序数组\",\"有序链表\"],\"key_steps\":[\"1. 初始化堆：从每个输入序列中取第一个元素，构建大小为k的最小堆（元素需关联值与所属序列索引）；2. 提取最小值：弹出堆顶的全局最小元素，将其加入结果序列；3. 补充堆元素：若该最小元素所属序列还有剩余元素，取下一个元素插入堆以维持最小堆性质；4. 循环处理：重复步骤2-3，直至堆为空（所有输入序列元素处理完毕）\"]}",
  "b6df537d38da3e0a4c04c174fc5bfb00": "{\"notation\":\"O(n)\",\"description\":\"大O符号表示的渐近上界时间复杂度，描述算法的运行时间随输入规模n的增大而线性增长，即时间消耗与输入规模成正比例关系\",\"typical_cases\":[\"线性搜索（Linear Search）\",\"遍历数组或单链表（Traversing an Array/Singly Linked List）\",\"计算数组元素之和（Summing Elements of an Array）\",\"查找数组中的最大值/最小值（Finding Maximum/Minimum in an Array）\",\"构建前缀和数组（Constructing Prefix Sum Array）\"],\"explanation\":\"大O符号O(n)的数学定义为：存在正常数c和n₀，使得当输入规模n≥n₀时，算法的运行时间T(n)满足T(n) ≤ c·n。这意味着算法的时间增长速率被线性函数约束，输入规模每扩大k倍，运行时间大致也扩大k倍（忽略常数因子）。O(n)代表线性时间复杂度，算法通常对输入的每个元素仅处理一次，是效率较高的复杂度类别之一\",\"best_case\":{\"线性搜索\":\"O(1)\",\"数组遍历\":\"O(n)\",\"数组求和\":\"O(n)\",\"查找数组最值\":\"O(n)\"},\"average_case\":{\"线性搜索\":\"O(n)\",\"数组遍历\":\"O(n)\",\"数组求和\":\"O(n)\",\"查找数组最值\":\"O(n)\"},\"worst_case\":{\"线性搜索\":\"O(n)\",\"数组遍历\":\"O(n)\",\"数组求和\":\"O(n)\",\"查找数组最值\":\"O(n)\"},\"example\":\"以下是Python中线性搜索的O(n)时间复杂度示例（最坏情况为O(n)，最好情况为O(1)）：\\n\\ndef linear_search(arr, target):\\n    for index, value in enumerate(arr):\\n        if value == target:\\n            return index  # 最好情况：第一个元素即目标，O(1)\\n    return -1  # 最坏情况：遍历所有元素未找到，O(n)\\n\\n该算法需要逐个检查数组元素，输入规模n越大，平均检查的元素数量越多，整体时间随n线性增长\"}",
  "612bb590e22e192087726f227f64d655": "{\"notation\":\"O(log n)\",\"description\":\"对数时间复杂度，表示算法的运行时间与输入规模n的对数函数成正比增长，其增长速率远慢于线性时间复杂度，是高效算法的标志性特征之一\",\"typical_cases\":[\"二分查找（Binary Search）\",\"平衡二叉搜索树（如AVL树、红黑树）的查找、插入与删除操作\",\"二叉堆（Binary Heap）的插入、删除与提取极值操作\",\"快速幂算法（Exponentiation by Squaring）\",\"并查集（Disjoint Set Union, DSU）的路径压缩与按秩合并操作\"],\"explanation\":\"大O记法中的对数基（如2、10等）可忽略，因不同基之间仅相差常数因子（根据对数换底公式log_b n = log_k n / log_k b，常数因子不影响复杂度阶数）。该复杂度的核心是算法采用“分治”或“规模缩减”策略，每次将问题规模缩小为原规模的固定比例（如二分查找每次将搜索范围减半），从而使总操作次数呈对数级增长。例如，二分查找在n个元素的有序数组中查找目标元素，最坏情况下需log₂n次比较，统一写作O(log n)\",\"best_case\":{\"二分查找\":\"O(1)\",\"平衡二叉搜索树查找\":\"O(1)\",\"二叉堆插入\":\"O(1)\",\"快速幂算法\":\"O(1)\"},\"average_case\":{\"二分查找\":\"O(log n)\",\"平衡二叉搜索树查找\":\"O(log n)\",\"平衡二叉搜索树插入\":\"O(log n)\",\"平衡二叉搜索树删除\":\"O(log n)\",\"二叉堆插入\":\"O(log n)\",\"快速幂算法\":\"O(log n)\"},\"worst_case\":{\"二分查找\":\"O(log n)\",\"平衡二叉搜索树查找\":\"O(log n)\",\"平衡二叉搜索树插入\":\"O(log n)\",\"平衡二叉搜索树删除\":\"O(log n)\",\"二叉堆插入\":\"O(log n)\",\"快速幂算法\":\"O(log n)\"},\"example\":\"以二分查找为例，给定有序数组arr = [1, 3, 5, 7, 9, 11, 13]（n=7），查找目标元素13：1. 初始搜索范围为左边界left=0，右边界right=6，中间索引mid=(0+6)//2=3，对应元素7，小于13，调整left=mid+1=4；2. 新范围left=4，right=6，mid=(4+6)//2=5，对应元素11，小于13，调整left=mid+1=6；3. 新范围left=6，right=6，mid=6，对应元素13，找到目标。总操作次数为3次，而log₂7≈2.8，符合O(log n)的复杂度特征。若查找目标元素7（位于中间位置），仅需1次操作，对应最好情况O(1)\"}",
  "92947ddfbc78d375cd5b44f348e2dfed": "{\"notation\": \"O(f(n))\", \"description\": \"算法在输入规模为n时，所有可能输入中执行时间的最大值，即运行时间的紧确上界（对于任意输入，运行时间不超过f(n)的常数倍）\", \"typical_cases\": \"冒泡排序处理逆序数组、线性查找目标元素不存在、快速排序处理已排序/逆序数组、插入排序处理逆序数组\", \"explanation\": \"用于评估算法在极端不利输入下的性能，是确保算法稳定性的关键指标，可避免算法在特殊输入下出现不可接受的延迟或资源消耗\", \"best_case\": \"未定义\", \"average_case\": \"未定义\", \"worst_case\": \"未定义\", \"example\": \"冒泡排序处理逆序数组时，每轮需比较并交换所有未排序元素，总比较次数为n(n-1)/2，时间复杂度为O(n²)，此为其最坏情况时间复杂度\"}",
  "6e7f4e52b9e77438f8c858bbfe16b5d3": "{\"notation\":\"O(n²)\",\"description\":\"大O符号定义的时间复杂度类别，用于描述算法运行时间随输入规模n增长的速率为二次方级别，即运行时间与输入规模的平方成正比\",\"typical_cases\":[\"冒泡排序（最坏与平均情况）\",\"选择排序（所有情况）\",\"插入排序（最坏与平均情况）\",\"双重嵌套循环遍历所有元素对（如计算两两元素的乘积和）\"],\"explanation\":\"当算法包含两层嵌套循环，且外层循环执行n次、内层循环对每个外层迭代执行约n次时，总基本操作次数为n×n=n²量级。这种复杂度通常出现在需要全面比较或处理所有元素对的场景中，未利用输入的有序性等特性进行优化\",\"best_case\":\"部分算法（如选择排序）的最好情况仍为O(n²)；部分算法（如冒泡排序）经优化后最好情况可降至O(n)\",\"average_case\":\"多数具有O(n²)复杂度的比较排序算法（如插入排序、冒泡排序）的平均情况时间复杂度为O(n²)\",\"worst_case\":\"多数基础比较排序算法（如插入排序、冒泡排序）的最坏情况时间复杂度为O(n²)\",\"example\":\"以下示例通过双重循环计算数组中所有两两元素的乘积和，时间复杂度为O(n²)：\\n\\ndef sum_of_products(arr):\\n    total = 0\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(n):\\n            total += arr[i] * arr[j]\\n    return total\\n\\n外层循环执行n次，内层循环每次执行n次，总操作次数为n²，因此时间复杂度为O(n²)\"}",
  "9b4e75f22088cb59dce270bf2a2f4906": "{\"notation\":\"T_best(n)（具体运行时间函数）、O(f(n))（渐近上界）、Θ(f(n))（渐近紧确界，当最好情况运行时间与f(n)渐近等价时）\",\"description\":\"算法在输入规模为n时，针对所有可能的输入中使算法执行步骤最少、资源消耗最低的最优输入情况所对应的运行时间或资源消耗的度量，是算法性能的一个重要指标，反映了算法的最优可能效率\",\"typical_cases\":\"线性查找（目标元素位于输入序列首位置）、插入排序（输入序列完全有序）、快速排序（每次划分都将序列分成两个大小相等的子序列）、冒泡排序（输入序列完全有序）\",\"explanation\":\"算法的运行时间通常与输入数据的特性（如有序性、元素分布、目标位置等）密切相关。最好情况复杂度描述的是算法在最理想输入下的性能表现，即算法执行过程中无需处理额外的操作（如无需多次比较、交换或递归）。例如，线性查找在目标元素位于序列开头时，无需遍历剩余元素；插入排序在输入完全有序时，每个元素只需与前一个元素比较一次即可。虽然最好情况展示了算法的最佳潜力，但由于实际应用中最优输入并不常见，因此最好情况复杂度通常仅用于辅助分析算法的极限性能，而非代表算法的普遍表现\",\"best_case\":\"未定义\",\"average_case\":\"未定义\",\"worst_case\":\"未定义\",\"example\":\"以插入排序算法为例，其核心操作是将每个元素插入到已排序的子序列中的正确位置。当输入数组已经完全有序时（如[1,2,3,4,5]），每个元素只需与前一个元素比较一次（确认无需移动），此时插入排序的最好情况时间复杂度为Θ(n)（或O(n)，若仅关注上界）。具体来说，对于n个元素的输入，插入排序在最好情况下只需执行n-1次比较和0次交换，运行时间与输入规模呈线性关系\"}",
  "2976e54b658012324fd244b32aa766b2": "{\"notation\":\"O(n log n)\",\"description\":\"线性对数时间复杂度（Linearithmic Time Complexity），表示算法时间随输入规模n增长呈现n与log n（通常以2为底）的乘积级增长，是介于线性时间O(n)和二次时间O(n²)之间的关键复杂度类别\",\"typical_cases\":[\"归并排序（Merge Sort）\",\"堆排序（Heap Sort）\",\"快速排序（Quicksort，平均情况）\",\"合并k个有序链表（基于堆的最优实现）\",\"快速傅里叶变换（FFT）\"],\"explanation\":\"该复杂度源于分治策略：将问题递归分解为log n层子问题（每次二分，故层数为log n），且每一层所有子问题的总处理时间为O(n)。例如归并排序中，分解阶段将数组二分至单元素（log n层），合并阶段每一层合并总耗时O(n)，总复杂度为O(n×log n)\",\"best_case\":{\"归并排序\":\"O(n log n)\",\"堆排序\":\"O(n log n)\"},\"average_case\":{\"归并排序\":\"O(n log n)\",\"堆排序\":\"O(n log n)\",\"快速排序\":\"O(n log n)\"},\"worst_case\":{\"归并排序\":\"O(n log n)\",\"堆排序\":\"O(n log n)\"},\"example\":\"以归并排序处理数组[38,27,43,3,9,82,10]为例：1. 分解：递归二分数组至单元素，得到[38]、[27]、[43]、[3]、[9]、[82]、[10]（共log₂7≈3层）；2. 合并：从底层开始合并相邻子数组：第一层合并为[27,38]、[3,43]、[9,82]、[10]；第二层合并为[3,27,38,43]、[9,10,82]；第三层合并为最终有序数组[3,9,10,27,38,43,82]。合并阶段每一层总耗时O(n)，总层数log n，故总复杂度为O(n log n)\"}",
  "14db16367b3ec1445a5b6c744ea7630b": "{\"notation\": \"ASL（Average Search Length）\", \"description\": \"查找算法在查找过程中对关键字进行比较的次数的期望值，是衡量查找算法时间效率的核心指标之一\", \"typical_cases\": [\"顺序查找的平均查找长度\", \"折半查找的平均查找长度\", \"哈希查找（开放寻址法/链地址法）的平均查找长度\", \"二叉排序树查找的平均查找长度\"], \"explanation\": \"平均查找长度通过将所有可能的查找情况（如查找成功或失败）下的关键字比较次数乘以对应情况的概率，再求和得到。它反映了查找算法在“平均意义”下的性能，是评估查找算法效率的重要量化标准\", \"best_case\": {\"顺序查找\": \"1（目标元素位于查找表第一个位置）\", \"折半查找\": \"1（目标元素位于查找表中间位置）\", \"哈希查找（无冲突）\": \"1（目标元素直接通过哈希函数定位）\", \"二叉排序树查找\": \"1（目标元素是根节点）\"}, \"average_case\": {\"顺序查找（成功查找）\": \"(n+1)/2（n为查找表长度，等概率查找）\", \"折半查找（成功查找）\": \"log₂(n+1) - 1（n为查找表长度，等概率查找）\", \"哈希查找（开放寻址法，成功查找）\": \"1 + α/2（α为装填因子，0<α<1）\", \"二叉排序树查找（平衡树）\": \"O(log n)（等概率查找）\"}, \"worst_case\": {\"顺序查找\": \"n（目标元素位于查找表最后一个位置或不存在）\", \"折半查找\": \"⌊log₂n⌋ + 1（n为查找表长度，目标元素位于叶子节点或不存在）\", \"哈希查找（链地址法）\": \"n（所有元素冲突到同一链表，退化为顺序查找）\", \"二叉排序树查找（斜树）\": \"n（目标元素位于斜树的最深层）\"}, \"example\": \"对于长度为5的有序数组[1,3,5,7,9]，采用顺序查找算法查找成功时，查找1需比较1次，查找3需2次，查找5需3次，查找7需4次，查找9需5次。等概率情况下，平均查找长度ASL = (1+2+3+4+5)/5 = 3，符合顺序查找成功时的平均情况公式(n+1)/2 = (5+1)/2 = 3\"}",
  "69fdf9b642e6e68c285ec31d28011572": "{\"notation\": {\"上界\": \"O(·)\", \"下界\": \"Ω(·)\", \"紧界\": \"Θ(·)\"}, \"description\": \"渐近复杂度是用于描述算法的时间或空间资源消耗随输入规模n增长而变化的趋势的理论分析工具，通过忽略低阶项和常数因子，聚焦于主导项以简化对算法效率的评估。\", \"typical_cases\": [\"常数时间O(1)\", \"对数时间O(log n)\", \"线性时间O(n)\", \"线性对数时间O(n log n)\", \"平方时间O(n²)\", \"立方时间O(n³)\", \"指数时间O(2ⁿ)\", \"阶乘时间O(n!)\"], \"explanation\": \"渐近复杂度通过渐近符号（O、Ω、Θ）刻画算法复杂度的增长量级：O符号表示复杂度的上界（即存在常数c>0和n₀>0，当n≥n₀时，算法复杂度T(n)≤c·f(n)）；Ω符号表示下界（存在常数c>0和n₀>0，当n≥n₀时，T(n)≥c·f(n)）；Θ符号表示紧界（同时满足O和Ω，即T(n)与f(n)同阶）。分析时忽略常数因子和低阶项，因n足够大时主导项对复杂度的影响起决定性作用。\", \"best_case\": \"算法在最优输入下的渐近复杂度，即输入使算法执行最少操作的情况，此时复杂度由输入的最佳分布决定，例如插入排序在输入已完全有序时的时间复杂度为Θ(n)。\", \"average_case\": \"算法在随机输入下的期望渐近复杂度，需考虑所有可能输入的概率分布并计算期望，例如插入排序在随机排列输入下的期望时间复杂度为Θ(n²)。\", \"worst_case\": \"算法在最坏输入下的渐近复杂度，即输入使算法执行最多操作的情况，此时复杂度是算法性能的最坏保障，例如插入排序在输入完全逆序时的时间复杂度为Θ(n²)。\", \"example\": \"1. 插入排序：最好情况（输入已排序）Θ(n)，平均情况（随机输入）Θ(n²)，最坏情况（输入逆序）Θ(n²)；2. 二分查找（有序数组）：最好情况（目标元素在中间位置）Θ(1)，平均情况Θ(log n)，最坏情况（目标元素在数组端点或不存在）Θ(log n)；3. 归并排序：所有情况（最好、平均、最坏）的时间复杂度均为Θ(n log n)，因分治策略的执行步骤不受输入顺序影响；4. 斐波那契递归算法（未优化）：时间复杂度为Θ(φⁿ)（φ为黄金分割比≈1.618），属于指数时间复杂度。\"}",
  "48b15dbf915f402ecb21d306ba15cab1": "{\"notation\": \"Amortized Cost（常用\\\\hat{c}_i表示第i个操作的摊还代价，总摊还代价需满足\\\\sum_{i=1}^n \\\\hat{c}_i \\\\geq \\\\sum_{i=1}^n c_i，其中c_i为第i个操作的实际代价）\", \"description\": \"摊还分析是一种算法复杂度分析方法，用于分析**操作序列**的平均代价。它通过将高代价操作的成本分摊到低代价操作上，得到每个操作的**摊还代价**——即使单个操作可能具有较高的最坏情况复杂度，但整体序列的平均复杂度更紧且更符合实际运行情况。\", \"typical_cases\": \"动态数组（如C++ vector）的push_back操作、二进制计数器的递增操作、带批量pop的栈（如MultiPop操作）、伸展树的旋转操作\", \"explanation\": \"摊还分析关注操作序列的**总实际代价**，而非单个操作的最坏情况。常用三种方法：1. 聚合分析（Aggregate Analysis）：直接计算n个操作的总实际代价T(n)，摊还代价为T(n)/n；2. 会计方法（Accounting Method）：为每个操作预先分配“信用”（credit），高代价操作时用信用抵消成本（要求总信用非负）；3. 势能方法（Potential Method）：定义势能函数Φ，将摊还代价表示为实际代价加上势能变化（即\\\\hat{c}_i = c_i + Φ(D_i) - Φ(D_{i-1})），确保总势能变化非负以覆盖实际代价。核心思想是跨操作分摊成本，得到更准确的平均复杂度界。\", \"best_case\": \"序列中所有操作的实际代价均较低，摊还代价等于或接近实际代价（如动态数组连续push_back未触发扩容的操作序列，摊还代价为O(1)）\", \"average_case\": \"n个操作的总实际代价为T(n)，每个操作的摊还代价为T(n)/n（如动态数组push_back的平均摊还代价为O(1)）\", \"worst_case\": \"序列中包含高代价操作，但总实际代价仍被摊还代价总和覆盖，摊还代价保持较低（如动态数组触发k次扩容的操作序列，总实际代价为O(n)，摊还代价仍为O(1)）\", \"example\": \"动态数组push_back操作的摊还分析：初始容量为1，push规则为：若元素个数<容量，直接插入（实际代价1）；否则扩容至原容量2倍（复制原容量个元素，实际代价1+原容量）。对n次push操作，扩容发生在第2、4、8…次，总扩容代价为1+2+4+…+2^{m-1}=2^m-1 ≤n-1（m为扩容次数），总实际代价T(n)=n + (2^m-1) ≤2n-1。因此每个操作的摊还代价为T(n)/n ≈2，即O(1)——说明即使存在扩容的高代价操作，摊还后的时间复杂度仍为常数级。\"}",
  "f9f4e8287122eddc1fc5e03a4d4045b5": "{\"notation\": \"Ĉ(i)（第i个操作的平摊成本）、c(i)（第i个操作的实际成本）\", \"description\": \"算法平摊分析的三大方法之一，通过为每个操作分配虚拟的平摊成本，将高于实际成本的部分以“信用”形式存储，用于抵消未来高成本操作的差额，最终保证总平摊成本不超过总实际成本，从而确定操作序列的平均时间复杂度上限\", \"typical_cases\": \"栈的push/pop/multipop操作序列分析、二进制计数器的递增操作序列分析、动态表的插入/删除与扩容/缩容操作序列分析\", \"explanation\": \"会计方法的核心思想是“预存信用以应对未来高成本”：当操作的平摊成本高于实际成本时，多余成本转化为信用存储在数据结构元素中；当平摊成本低于实际成本时，使用已有信用弥补差额。通过确保全程信用非负，总平摊成本即为总实际成本的上界，进而得到每个操作的平摊时间复杂度（即序列的平均复杂度）\", \"best_case\": {\"栈push操作\": \"O(1)\", \"栈pop操作\": \"O(1)\", \"栈multipop操作\": \"O(1)\", \"二进制计数器递增\": \"O(1)\"}, \"average_case\": {\"栈操作(push/pop/multipop)\": \"O(1)\", \"二进制计数器递增\": \"O(1)\", \"动态表插入\": \"O(1)\"}, \"worst_case\": {\"栈multipop(弹出全部元素)\": \"O(1)\", \"二进制计数器递增(全位翻转)\": \"O(1)\", \"动态表插入(触发扩容)\": \"O(1)\"}, \"example\": \"以栈的multipop操作为例：设定push操作实际成本1，平摊成本2（多余1存入新元素作为信用）；pop和multipop实际成本为弹出元素数，平摊成本0。执行pop时，用元素信用支付实际成本；执行multipop(k)时，用k个元素的信用支付实际成本k。对于任意操作序列，总平摊成本=2×push次数，总实际成本=push次数+pop/multipop次数≤2×push次数（每个元素最多被弹出一次），信用始终非负。因此每个操作的平摊复杂度为O(1)，远低于multipop的最坏单个操作复杂度O(n)\"}",
  "c27bfa12065df9a70da46aca86e8eca5": "{\"notation\": \"Ω(g(n))\", \"description\": \"算法时间或空间复杂度的渐近下界记号，表示存在正常数c和n₀，当输入规模n≥n₀时，0 ≤ c·g(n) ≤ f(n)（其中f(n)为算法的复杂度函数，g(n)为其渐近下界函数），用于刻画算法资源消耗的最低渐近下限\", \"typical_cases\": [\"插入排序在输入完全有序时的比较次数下界\", \"基于比较的查找算法的时间复杂度下界\", \"线性查找找到目标元素的最少比较次数下界\"], \"explanation\": \"Ω记号关注算法在足够大输入规模下的最坏性能下限（或最优输入下的性能下限），即无论算法如何优化，其复杂度至少是g(n)的常数倍。它不考虑小输入的表现或具体常数因子，仅描述渐近趋势\", \"best_case\": \"插入排序在输入完全有序时的时间复杂度为Ω(n)，此时仅需n-1次比较，是其最优情况下的渐近下界\", \"average_case\": \"线性查找在平均情况下的时间复杂度为Ω(1)，因存在概率（如目标元素在第一个位置）使得比较次数为常数1，构成平均情况的下界\", \"worst_case\": \"基于比较的排序算法的最坏情况时间复杂度下界为Ω(n log n)，任何此类算法在最坏情况下都无法突破这一下限（如归并排序的最坏情况为Θ(n log n)，满足Ω(n log n)）\", \"example\": \"对于插入排序，输入数组[1,2,3,4,5]时，仅需4次比较和0次交换，f(n)=n-1，取c=0.5、n₀=2，则当n≥2时，0.5n ≤ n-1，故f(n)=Ω(n)；对于二叉搜索树的查找操作，每次比较将问题规模减半，至少需log₂n次比较，故时间复杂度为Ω(log n)\"}",
  "1135bea899dff076bc5bcf27588bac5f": "{\"notation\": \"Θ(g(n))\",\"description\": \"渐近紧确界记号，表示存在正常数c₁、c₂和n₀，使得对于所有n ≥ n₀，有0 ≤ c₁g(n) ≤ f(n) ≤ c₂g(n)，其中f(n)为算法的运行时间函数，g(n)为基准函数（如n、n²、n log n等），用于刻画f(n)的渐近行为。\",\"typical_cases\": \"用于描述运行时间具有精确渐近增长趋势的算法，例如合并排序的时间复杂度、数组元素随机访问的时间复杂度、计算1到n的和的循环算法的时间复杂度等。\",\"explanation\": \"Θ记号是渐近上界（O记号）与渐近下界（Ω记号）的交集，即f(n) ∈ Θ(g(n))当且仅当f(n) ∈ O(g(n))且f(n) ∈ Ω(g(n))。它精确刻画了算法运行时间随输入规模n增大时的增长速率，表明f(n)与g(n)同阶，是对算法效率最准确的渐近描述。\",\"best_case\": {\"合并排序\": \"Θ(n log n)\", \"数组随机访问\": \"Θ(1)\"},\"average_case\": {\"合并排序\": \"Θ(n log n)\", \"计算1到n的和\": \"Θ(n)\"},\"worst_case\": {\"合并排序\": \"Θ(n log n)\", \"冒泡排序（未优化）\": \"Θ(n²)\"},\"example\": \"合并排序的时间复杂度为Θ(n log n)，其递归式为T(n) = 2T(n/2) + Θ(n)，通过主定理解得T(n) = Θ(n log n)，且其最好、平均、最坏情况的时间复杂度均为此值；计算1到n的和的算法sum = 0; for (int i=1; i<=n; i++) sum += i; 因循环执行n次，每次迭代为常数时间操作，故时间复杂度为Θ(n)。\"}",
  "e455a8e4ec4ece9cc5414dc6e2848cb6": "{\"notation\": \"Φ(D)（势能函数，D为数据结构状态）\", \"description\": \"势能方法是一种均摊（amortized）分析技术，通过为数据结构的每个状态定义非负势能函数，将操作的瞬时成本分摊到后续操作中，从而计算操作序列的均摊成本。其核心是利用势能变化平衡不同操作的成本，避免最坏情况的集中出现。\", \"typical_cases\": \"栈的MULTIPOP操作、二进制计数器的递增操作、动态表的扩张与收缩操作\", \"explanation\": \"势能方法的步骤为：1. 定义势能函数Φ(D)映射数据结构状态D到非负实数（初始状态D₀的势能Φ(D₀)=0）；2. 对操作i，计算瞬时成本c_i（实际执行时间）和势能变化ΔΦ_i=Φ(D_i)-Φ(D_{i-1})（D_i为操作后状态）；3. 均摊成本为â_i = c_i + ΔΦ_i。总均摊成本Σâ_i = Σc_i + Φ(D_n)-Φ(D₀)，因Φ(D_n)≥Φ(D₀)，总均摊成本是总实际成本的上界，可用于分析序列复杂度。\", \"best_case\": {\"均摊成本\": \"O(1)\"}, \"average_case\": {\"均摊成本\": \"O(1)\"}, \"worst_case\": {\"均摊成本\": \"O(1)\"}, \"example\": \"以二进制计数器递增操作为例：初始全0（Φ=0），每次递增翻转末尾1至0直到第一个0（如111→1000翻转4位，瞬时成本4）。定义Φ为1的个数，第i次操作翻转t_i位，则Φ_i=Φ_{i-1}-(t_i-1)+1=Φ_{i-1}-t_i+2。均摊成本â_i=c_i+ΔΦ_i=t_i+(-t_i+2)=2，即O(1)。n次操作总均摊成本O(n)，分摊了高瞬时成本。\"}",
  "582e49b02e3198cceebe3664cdda0500": "{\"notation\":\"O(g(n))\",\"description\":\"大O记号（Big O Notation）是用于描述算法时间复杂度或空间复杂度随输入规模n增长的渐近上界的数学符号，它忽略低阶项和常数因子，仅关注主导复杂度增长的核心项，用于分析算法在极限情况下的性能上限。\",\"typical_cases\":[\"O(1)（常数复杂度）\",\"O(log n)（对数复杂度）\",\"O(n)（线性复杂度）\",\"O(n log n)（线性对数复杂度）\",\"O(n²)（平方复杂度）\",\"O(2ⁿ)（指数复杂度）\"],\"explanation\":\"对于算法的时间/空间开销函数f(n)和参考函数g(n)，若存在正常数c和n₀，使得当输入规模n≥n₀时，恒有0≤f(n)≤c·g(n)，则称f(n)的渐近上界为g(n)，记为f(n)=O(g(n))。大O记号主要刻画算法在最坏情况下的性能上限，但也可用于描述平均或最佳情况的上界，核心是捕捉复杂度增长的“最坏可能”趋势。\",\"best_case\":{\"插入排序（输入已完全有序）\":\"O(n)\"},\"average_case\":{\"插入排序（输入随机无序）\":\"O(n²)\"},\"worst_case\":{\"线性查找（目标元素不存在或位于数组末尾）\":\"O(n)\"},\"example\":\"例如，线性查找算法的最坏情况时间复杂度为O(n)。假设输入数组长度为n，当目标元素不在数组中时，算法需要依次检查每个元素，共执行n次比较操作，时间开销T(n)=n。根据大O定义，取正常数c=1、n₀=1，当n≥n₀时，0≤T(n)=n≤1·n=c·g(n)（其中g(n)=n），满足渐近上界的条件，因此T(n)=O(n)。\"}",
  "4949fa504a02c96227775ecae2d89610": "{\"notation\":\"使用大O符号（O，表示上界）、Θ符号（Θ，表示紧界）、Ω符号（Ω，表示下界）等渐近符号描述算法运行时间与输入规模的渐近关系\",\"description\":\"时间复杂度（Time Complexity）是计算机科学中用于刻画算法执行时间随输入规模（通常用n表示）增长而变化的渐近行为的概念，反映算法效率的可扩展性（scalability）\",\"typical_cases\":\"常数时间O(1)、线性时间O(n)、对数时间O(log n)、线性对数时间O(n log n)、二次时间O(n²)、多项式时间O(n^k)（k为常数）、指数时间O(2ⁿ)、阶乘时间O(n!)\",\"explanation\":\"时间复杂度通过渐近分析（Asymptotic Analysis）忽略算法运行时间中的低阶项与常数因子，聚焦输入规模n趋向无穷大时的主导项。例如，若算法运行时间T(n)=3n²+5n+2，其时间复杂度为O(n²)——因n极大时3n²主导整体表达式。大O符号描述最坏情况或上界，Θ符号描述紧界（同时为上界与下界），Ω符号描述最好情况或下界\",\"best_case\":{\"线性查找（Linear Search）\":\"O(1)（目标元素为第一个元素）\",\"冒泡排序（Bubble Sort）\":\"O(n)（输入数组已完全有序）\",\"插入排序（Insertion Sort）\":\"O(n)（输入数组已完全有序）\"},\"average_case\":{\"线性查找（Linear Search）\":\"O(n)（目标元素均匀分布在数组中）\",\"快速排序（Quick Sort）\":\"O(n log n)（pivot选择合理且数组均分）\",\"插入排序（Insertion Sort）\":\"O(n²)（输入数组随机排列）\"},\"worst_case\":{\"线性查找（Linear Search）\":\"O(n)（目标元素为最后一个或不存在）\",\"冒泡排序（Bubble Sort）\":\"O(n²)（输入数组完全逆序）\",\"快速排序（Quick Sort）\":\"O(n²)（pivot为极值导致分割失衡）\",\"递归斐波那契（Recursive Fibonacci）\":\"O(2ⁿ)（无记忆化的递归实现）\"},\"example\":\"以线性查找为例：算法遍历数组元素直到找到目标或结束。最好情况（O(1)）为目标是首元素，仅1次比较；最坏情况（O(n)）为目标是末元素或不存在，需n次比较；平均情况（O(n)）假设目标等概率分布，平均比较(n+1)/2次。再如快速排序：最好与平均情况因数组均分达O(n log n)，但最坏情况因pivot选极值导致分割失衡，退化为O(n²)——实际常用随机pivot避免此情况\"}",
  "90232fcee951f03052540de68ad255af": "{\"description\":\"操作系统、分布式系统或并发编程中，依据特定策略将任务（进程、线程、作业等）分配给计算资源（CPU、服务器、线程池等），以优化系统性能目标（如吞吐量、响应时间、资源利用率、实时性）的核心过程\",\"key_problem\":\"资源冲突（多任务争夺同一资源导致等待）、优先级反转（高优先级任务因低优先级任务持有资源而阻塞）、负载不均衡（部分资源过载而其他资源闲置）、实时约束满足（实时任务需在截止时间前完成）、任务依赖管理（有先后执行顺序的任务需按依赖关系调度）\",\"common_solutions\":\"批处理系统：先来先服务（FCFS）、短作业优先（SJF）、优先级调度；分时系统：时间片轮转（RR）；实时系统：最早截止时间优先（EDF）、速率单调调度（RM）；分布式系统：负载均衡调度（轮询、最小连接数）、数据本地化调度；并发编程：线程池调度（固定线程池、缓存线程池）；优先级反转解决：优先级继承协议、优先级天花板协议\",\"related_data_structures\":\"队列（FCFS/RR的任务排队）、优先队列（堆实现，用于优先级调度/EDF/RM）、哈希表（记录资源负载或任务状态）、有向无环图（DAG，描述任务依赖）、红黑树（Linux CFS的公平调度队列）\",\"related_algorithms\":\"拓扑排序（处理DAG任务依赖）、一致性哈希（分布式调度的负载均衡）、完全公平调度（CFS，Linux进程调度）、MapReduce任务调度（Hadoop的作业分配）、Kubernetes调度算法（节点筛选与优先级排序）、优先级继承协议（解决优先级反转）\",\"real_world_examples\":\"操作系统进程调度（Linux CFS调度、Windows抢占式多任务）、分布式计算框架（Spark任务调度、Hadoop MapReduce作业调度）、云原生容器调度（Kubernetes Pod调度）、实时系统（航空飞控系统任务调度、工业机器人运动控制）、线程池调度（Java Executor框架的任务分配）\"}",
  "22b7a5f3e0ab95112dfc2bcebd55984b": "{\"description\":\"表达式求值是计算机科学中处理算术或逻辑表达式的核心任务，目标是将由操作数（如整数、浮点数）、运算符（如+、-、*、/、^）和括号组成的中缀表达式转换为正确的数值结果，需严格遵循运算符优先级规则（如乘除高于加减）和括号嵌套逻辑（括号内表达式优先计算）\",\"key_problem\":\"1. 运算符优先级的正确排序（如^优先级高于*、/，*、/高于+、-）；2. 括号嵌套的处理（需优先计算最内层括号内的表达式）；3. 非交换性运算符（如-、/）的操作数顺序保持（如a - b不能转换为b - a）；4. 表达式的语法有效性检查（如括号不匹配、无效字符或运算符连续出现）；5. 多位数或浮点数的正确识别（如'123'需作为整体操作数，而非三个单数字）\",\"common_solutions\":\"1. 逆波兰表达式（后缀表达式）法：通过Shunting Yard算法将中缀表达式转为后缀表达式（运算符位于操作数之后），再用栈计算后缀表达式（操作数入栈，运算符弹出栈顶两操作数计算后结果入栈）；2. 双栈直接求值法：用两个栈分别存储操作数和运算符，遍历中缀表达式时按优先级弹出运算符计算，处理括号时左括号入栈、右括号触发括号内计算\",\"related_data_structures\":\"栈（Stack）、队列（Queue）\",\"related_algorithms\":\"Shunting Yard算法（中缀转后缀）、后缀表达式求值算法、双栈中缀直接求值算法\",\"real_world_examples\":\"1. 桌面/移动计算器应用（如Windows计算器、iOS计算器）；2. 编程语言编译器/解释器（如Java解析`3 + 4 * (2 - 1)`）；3. 电子表格软件公式计算（如Excel的`=A1*2 + B2/3`）；4. 数学计算库（如Math.js的`evaluate('3 + 4 * 2')`）；5. 规则引擎条件求值（如Drools中`age > 18 && score >= 60`）\"}",
  "5958de757fcd50ead48807ac7b088e96": "{\"description\":\"迷宫求解是指给定由通路和障碍（墙）构成的网格状或图状结构（迷宫），寻找从起点到终点的有效路径（即仅通过通路移动且不重复访问节点），或判断起点与终点间是否存在可达路径的问题。迷宫通常可抽象为无向图（节点表示可通行的格子，边表示相邻格子间的可达性）。\",\"key_problem\":\"1. 迷宫的结构化表示（如何将物理或抽象迷宫转换为可计算的模型，如邻接矩阵/邻接表）；2. 避免重复访问节点（防止陷入死循环，如DFS/BFS中的visited集合）；3. 路径探索策略的选择（如需要最短路径时选择BFS，需要任意路径时选择DFS）；4. 处理复杂迷宫场景（如含环迷宫、多出口迷宫、带权重的迷宫（如移动成本不同的格子））；5. 高效搜索（在大规模迷宫中减少搜索空间，如启发式算法A*）。\",\"common_solutions\":\"1. 深度优先搜索（DFS）：用栈或递归实现，优先探索当前路径的最深处，适合寻找任意路径，但无法保证最短；2. 广度优先搜索（BFS）：用队列实现，按层探索，能保证找到起点到终点的最短路径；3. Dijkstra算法：用优先队列实现，适合带权重的迷宫（如不同格子移动成本不同），求解最短权重路径；4. A*算法：基于BFS的启发式搜索，结合当前路径成本（g值）和启发函数（如曼哈顿距离，h值）估计剩余成本，优先探索更可能接近终点的节点，大幅减少搜索空间；5. 双向BFS：从起点和终点同时进行BFS，相遇时停止，适用于大规模迷宫，提升搜索效率。\",\"related_data_structures\":\"栈（DFS的递归底层或显式栈实现）、队列（BFS的FIFO结构）、优先队列（Dijkstra/A*的优先级排序）、图（迷宫的抽象表示，邻接矩阵/邻接表存储节点与边）、哈希集合/数组（记录已访问节点，避免重复）\",\"related_algorithms\":\"深度优先搜索（DFS）、广度优先搜索（BFS）、Dijkstra算法、A*算法、双向广度优先搜索（Bidirectional BFS）\",\"real_world_examples\":\"1. 游戏AI路径规划：如迷宫类游戏（如《吃豆人》）中角色寻找出口或躲避敌人的路径；2. 机器人导航：室内服务机器人（如扫地机器人）在房间内避开家具等障碍，规划从当前位置到充电座的路径；3. 网络路由：计算机网络中数据包从源节点到目标节点的路径查找（网络拓扑类似迷宫，节点为路由器，边为链路）；4. 仓储物流：仓库AGV（自动导引车）在货架间搬运货物时，规划避开障碍物的最短路径；5. 救援路径规划：地震等灾害后，救援机器人在废墟中寻找幸存者的路径（废墟结构类似迷宫，障碍为倒塌的建筑）\"}",
  "d6e2b9d73cdfb0684b17b223bbb8a7b0": "{\"description\":\"最短路径应用场景是指在带权图（有向或无向）中，针对起点到终点（或多源点、单源多终点）的路径问题，寻找总权重最小的路径的一类实际或理论应用场景集合，权重可代表距离、时间、成本等实际意义，核心是将现实中的优化需求抽象为图的最短路径问题\",\"key_problem\":\"给定带权图（可能含负权重边，但需避免负权环导致最短路径不存在），如何高效计算单源（起点到所有顶点）、多源（所有顶点对）或带启发式信息的最短路径，核心挑战包括处理不同权重类型（非负/负）、大规模图的效率、负权环检测及路径存在性验证\",\"common_solutions\":[\"Dijkstra算法（适用于非负权重单源最短路径，用优先队列优化）\",\"Bellman-Ford算法（适用于含负权重边无负权环的单源最短路径，可检测负权环）\",\"Floyd-Warshall算法（适用于多源最短路径，基于动态规划）\",\"SPFA算法（Bellman-Ford的队列优化，适用于含负权重边的单源最短路径）\",\"A*算法（启发式搜索，结合全局最优与局部启发信息，适用于路径规划）\",\"Johnson算法（适用于含负权重边的多源最短路径，通过重赋权转化为非负权重）\"],\"related_data_structures\":[\"邻接表（存储稀疏图，高效遍历邻接顶点）\",\"邻接矩阵（存储稠密图，快速查询边权重）\",\"优先队列（如二叉堆、斐波那契堆，用于Dijkstra算法选最短路径顶点）\",\"队列（用于SPFA算法的松弛操作）\",\"堆（优先队列的底层实现，影响Dijkstra时间复杂度）\"],\"related_algorithms\":[\"Dijkstra算法\",\"Bellman-Ford算法\",\"Floyd-Warshall算法\",\"SPFA算法\",\"A*算法\",\"Johnson算法\",\"拓扑排序（用于有向无环图的单源最短路径，线性时间求解）\"],\"real_world_examples\":[\"导航系统（如Google Maps、高德地图，计算最短距离/时间路线）\",\"网络路由协议（如OSPF，计算路由器间最短路径优化数据传输）\",\"物流配送（优化货车运输路线，最小化成本或时间）\",\"社交网络分析（寻找用户间最短好友链，验证六度分隔理论）\",\"游戏AI路径规划（如NPC从当前位置到目标点的最短移动路径）\",\"电路设计（计算电路板上两点间最短导线长度，优化布局）\"]}",
  "e988a0fa143aced7d21883a5696f5845": "{\"notation\": \"大O符号（Big O Notation）\", \"description\": \"算法在运行过程中临时占用的额外存储空间（不包含输入数据本身）随输入规模n增长的变化趋势，是衡量算法效率的重要指标之一\", \"typical_cases\": [\"常量空间复杂度O(1)\", \"线性空间复杂度O(n)\", \"对数空间复杂度O(log n)\", \"平方空间复杂度O(n²)\"], \"explanation\": \"空间复杂度主要关注算法执行过程中动态分配的临时存储空间（如函数调用栈、临时变量、辅助数据结构等），不包含输入数据的原始存储空间。其大小通常与输入规模n相关，反映算法对内存资源的需求——递归算法的空间复杂度常与递归深度直接相关，迭代算法则取决于临时变量或辅助结构的规模\", \"best_case\": \"算法在最佳输入场景下的空间复杂度，例如递归快速排序在输入数据均匀分布时，递归深度为O(log n)，对应空间复杂度O(log n)\", \"average_case\": \"算法在平均输入场景下的空间复杂度，例如递归快速排序的平均递归深度为O(log n)，对应空间复杂度O(log n)\", \"worst_case\": \"算法在最坏输入场景下的空间复杂度，例如递归快速排序在输入数据完全有序或逆序时，递归深度为O(n)，对应空间复杂度O(n)\", \"example\": \"1. 常量空间复杂度O(1)：线性搜索算法，仅使用循环索引、目标值等临时变量，空间占用不随输入数组长度变化；2. 线性空间复杂度O(n)：归并排序算法，需分配与输入数组大小相同的辅助数组用于合并操作；3. 对数空间复杂度O(log n)：递归二分查找算法，递归深度为log₂n（如查找长度为n的有序数组），每个递归层仅用常量空间；4. 平方空间复杂度O(n²)：动态规划求解最长公共子序列问题，用二维数组dp[n+1][m+1]存储中间结果，当n≈m时空间复杂度为O(n²)\"}",
  "11d0505799c27b3381a2e0602482be35": "{\"description\":\"用于检查字符串中的括号序列是否符合语法规则，要求左右括号类型匹配、顺序正确且数量平衡，是判断代码语法正确性、结构化数据格式有效性等场景的基础问题\",\"key_problem\":\"如何高效验证括号序列的有效性，包括：1. 左右括号类型是否对应（如'('需对应')'，'['需对应']'等）；2. 括号顺序是否符合“先开后闭”规则；3. 括号数量是否平衡（无多余或缺失）\",\"common_solutions\":\"最经典的解决方案是使用栈数据结构：遍历字符串，遇到左括号时将其压入栈；遇到右括号时，检查栈顶是否为对应的左括号，若是则弹出栈顶元素，否则序列无效；遍历结束后，若栈为空则序列有效，否则无效。该方法时间复杂度为O(n)（n为字符串长度），空间复杂度为O(n)（最坏情况如全为左括号）\",\"related_data_structures\":\"栈（Stack）\",\"related_algorithms\":\"栈-based括号有效性检查算法\",\"real_world_examples\":\"1. 编译器/解释器的语法分析（如检查C/C++/Java代码中的{}、()、[]是否匹配）；2. JSON/XML/YAML等结构化数据的格式验证（如JSON对象的{}和数组的[]是否正确闭合）；3. 算术表达式求值（如计算'(3+4)*(5-2)'时验证括号有效性）；4. 文本编辑器的括号匹配提示功能（如VS Code中括号的高亮匹配）\"}",
  "275fb8dc1b4f2fefc93018b9b45953aa": "{\"description\": \"FIFO（First-In-First-Out，先进先出）是一种数据处理与存储的顺序原则，规定最早进入数据结构的元素最先被访问或移除，遵循“先来先服务”的逻辑，是队列（Queue）抽象数据类型的核心操作准则。\", \"key_characteristic\": \"1. 顺序强一致性：元素的处理顺序严格等同于其进入数据结构的顺序；2. 操作边界固定：入队（添加元素）仅允许在结构的“尾部”执行，出队（移除元素）仅允许在“头部”执行；3. 访问唯一性：任意时刻可直接访问的元素是当前结构中存在时间最长的元素（即头部元素）；4. 状态可预测性：给定入队序列，出队序列必然与入队序列完全一致。\", \"implications\": \"1. 时间复杂度特性：若采用链表或循环数组实现，入队（enqueue）和出队（dequeue）操作的时间复杂度均为{\\\"enqueue\\\": \\\"O(1)\\\", \\\"dequeue\\\": \\\"O(1)\\\"}；2. 应用场景适配性：适用于需要“公平顺序处理”的场景，但不适用于需优先处理近期元素的场景（如缓存淘汰、递归调用）；3. 空间管理要求：需维护头指针（指向当前头部元素）和尾指针（指向当前尾部元素的下一个位置），以保证操作的高效性；4. 数据不可回溯性：一旦元素被出队，后续无法再通过FIFO原则重新访问（除非重新入队）。\", \"related_concepts\": \"队列（Queue，FIFO是其本质特征）、LIFO（后进先出，与FIFO对立的顺序原则）、双端队列（Deque，可灵活支持FIFO和LIFO操作）、循环队列（Circular Queue，优化FIFO队列的空间复用问题）、优先队列（Priority Queue，打破FIFO顺序，按优先级处理元素）、FCFS调度（先来先服务，操作系统中基于FIFO的进程调度算法）。\", \"examples\": \"1. 打印机任务队列：用户提交的打印任务按顺序排队，先提交的任务先执行；2. 操作系统进程调度：FCFS算法中，进程按到达就绪队列的顺序依次获得CPU时间片；3. 消息中间件队列：如Kafka的主题分区或RabbitMQ的简单队列，消息按生产顺序被消费；4. 键盘输入缓冲区：用户按键的字符按敲击顺序存储，系统按相同顺序处理输入；5.  breadth-first search（BFS，广度优先搜索）：使用队列存储待访问节点，遵循FIFO顺序保证层序遍历。\", \"theoretical_basis\": \"FIFO的理论基础源于线性表的顺序操作模型，《算法导论》（第三版）将队列定义为遵循FIFO原则的线性数据结构，其抽象数据类型（ADT）包含enqueue（尾部插入）、dequeue（头部删除）、peek（返回头部元素）、isEmpty（判断是否为空）等操作。该原则的理论意义在于提供“时间顺序公平性”——每个元素的处理顺序仅由其进入时间决定，无额外优先级干预，是实现“顺序依赖型”算法（如BFS）和系统组件（如调度器）的核心理论支撑。\"}",
  "ec0e0352776bdf97821d1d0099485465": "{\"description\":\"Last-In-First-Out的缩写，是一种线性数据结构的访问原则，指最后加入（Push）的数据元素最先被移除（Pop），数据操作仅允许在结构的一端（通常称为栈顶，Top）进行\",\"key_characteristic\":\"1. 核心访问顺序为后进先出（Last-In-First-Out）；2. 所有数据操作（添加、移除、访问）均限制在结构的单一端点（栈顶，Top）；3. 基本操作的时间复杂度：{\\\"Push（添加元素到栈顶）\\\":\\\"O(1)\\\",\\\"Pop（移除并返回栈顶元素）\\\":\\\"O(1)\\\",\\\"Top（获取栈顶元素）\\\":\\\"O(1)\\\"}；4. 元素的插入顺序与移除顺序相反，具有逆序处理特性\",\"implications\":\"1. 数据结构设计：基于LIFO原则的栈结构具有极高的插入/删除效率，无需遍历即可完成核心操作；2. 算法应用：适用于处理嵌套结构（如递归、括号匹配）、逆序输出（如进制转换）、临时缓存（如表达式求值）等场景；3. 系统实现：操作系统和编译器中，函数调用栈通过LIFO管理函数上下文，确保递归或嵌套调用的正确返回；4. 局限性：无法直接访问非栈顶元素，不支持随机访问或顺序遍历，不适用于需要按插入顺序处理元素的场景（如队列问题）\",\"related_concepts\":[\"栈（Stack）\",\"FIFO（先进先出原则）\",\"Push操作\",\"Pop操作\",\"递归调用栈（Recursion Call Stack）\",\"后缀表达式求值（Postfix Expression Evaluation）\",\"撤销栈（Undo Stack）\"],\"examples\":[\"函数调用栈：递归函数执行时，每次调用将上下文压入栈，返回时弹出栈顶恢复状态；\",\"文本编辑器撤销：编辑操作压入撤销栈，撤销时弹出最后一次操作恢复；\",\"后缀表达式求值：用栈存储操作数，遇运算符弹出栈顶两元素计算并压回结果；\",\"浏览器后退：访问新页面压入栈，后退时弹出栈顶页面显示\"],\"theoretical_basis\":\"基于线性表的端点操作特性，《算法导论》（第三版）将栈定义为遵循LIFO原则的动态集合，其核心操作（Push、Pop、Top、Empty）的时间复杂度均为O(1)；LIFO原则通过限制操作端点确保最近添加的元素具有最高访问优先级，数学上对应线性结构的逆序访问策略，是递归、嵌套结构处理的理论基础\"}",
  "aab07475f28948f430a106bd8cdd6b00": "{\"description\": \"排序算法的重要性质之一，指当待排序序列中存在多个具有相同键值的元素时，排序后这些元素的相对顺序与排序前保持一致\", \"key_characteristic\": \"相同键值元素的相对顺序在排序前后不变；仅由排序算法对相同键值元素的处理逻辑决定\", \"implications\": \"稳定排序算法适用于需保留原始相对顺序的场景（如多关键字排序、含附属信息的排序）；不稳定排序可能破坏原有顺序，需根据业务需求选择\", \"related_concepts\": [\"排序算法\", \"键值（Key）\", \"相对顺序（Relative Order）\", \"稳定排序算法\", \"不稳定排序算法\"], \"examples\": [\"冒泡排序：相邻元素比较交换，相同键值元素不交换，保持相对顺序\", \"插入排序：将元素插入到已排序序列的相同键值元素之后，保持相对顺序\", \"快速排序：分区时相同键值元素可能被交换到pivot两侧，破坏相对顺序\", \"堆排序：堆调整过程中相同键值元素因结构调整改变相对顺序\"], \"theoretical_basis\": \"基于排序算法对相同键值元素的比较与移动策略；稳定排序通过相邻交换或尾部插入等方式不改变相同元素相对位置，不稳定排序通过跨元素交换或选择操作改变其相对顺序\"}",
  "9a84981747e0699930b2fee3f405e513": "{\"description\":\"原地排序是一种排序算法的设计原则，指算法在执行过程中仅使用常数级（O(1)）的额外空间，即不需要额外的大规模辅助数据结构，仅通过固定大小的临时变量或原数据结构内的位置调整来完成排序，操作直接作用于原始输入数据。\",\"key_characteristic\":\"1. 空间复杂度为O(1)（额外空间不随输入规模增长，仅用常数级临时存储）；2. 排序操作直接修改原始数据结构（如数组），不依赖与输入规模成比例的辅助存储；3. 通常通过元素交换、移动或局部调整策略实现有序化，无大规模数据拷贝。\",\"implications\":\"1. 空间效率优势：适合内存受限场景（如嵌入式系统、大数据处理），避免额外空间分配和数据拷贝的开销；2. 数据破坏性：直接修改原始数据，若需保留原数据需提前拷贝，增加额外成本；3. 算法设计约束：为满足原地性，需设计更巧妙的元素操作逻辑，可能影响时间复杂度（如快速排序的平均时间复杂度为O(n log n)但最坏为O(n²)）或稳定性（如快速排序不稳定，冒泡排序稳定）；4. 递归栈的特殊情况：部分原地排序（如快速排序）的递归实现会使用O(log n)的栈空间，但通常视为原地排序（迭代实现可消除递归栈）。\",\"related_concepts\":\"快速排序,冒泡排序,插入排序,堆排序,非原地排序（如归并排序、计数排序）,空间复杂度,算法稳定性\",\"examples\":\"1. 冒泡排序：通过相邻元素比较交换，逐次将极值移至正确位置，仅用1个临时变量交换元素，空间复杂度O(1)；2. 插入排序：将当前元素插入已排序部分的正确位置，通过元素后移实现，仅用1个临时变量存储待插入元素；3. 快速排序：通过partition划分数组为三部分（小于、等于、大于基准），划分操作仅用常数级空间，排序直接在原数组进行（递归栈除外）；4. 堆排序：在原数组上构建最大堆/最小堆，通过堆调整（heapify）和堆顶元素交换实现排序，空间复杂度O(1)。\",\"theoretical_basis\":\"原地排序的理论基础源于算法的空间复杂度分析，《算法导论》将**原地算法**定义为空间复杂度为O(1)的算法（额外空间与输入规模无关）。排序算法的原地性要求其额外存储空间不随输入规模n增长，仅通过原数据结构内的局部操作（如交换、移动）实现元素有序化。这一原则是空间效率优化的核心方向，本质是通过时间（或算法复杂度）换空间的权衡——用更复杂的元素操作逻辑替代大规模辅助存储，以降低内存占用。\"}",
  "312b09ace7b50a6c17f863f2a17c9eb8": "{\"description\":\"在计算机科学中，确定性指系统、算法或计算模型的行为完全由输入和初始状态唯一确定，执行过程中不存在随机选择或不确定的分支，每一步操作都有明确、唯一的定义\",\"key_characteristic\":\"1. 行为可预测性：给定相同输入和初始状态，每次执行的路径与结果完全一致；2. 无随机决策：执行过程不依赖随机数或概率选择；3. 状态转移唯一性：计算模型（如自动机、图灵机）中每个状态与输入对应的下一状态唯一\",\"implications\":\"1. 可重复性：便于调试、测试与结果验证，相同条件下结果一致；2. 复杂度分析简化：无需考虑概率分布，直接分析最坏/平均情况；3. 局限性：部分NP问题难用确定性算法多项式时间求解，需非确定性或启发式方法；4. 验证容易：正确性证明更直接，无需处理不确定性分支\",\"related_concepts\":\"确定性算法、确定性有限自动机（DFA）、确定性图灵机（DTM）、非确定性、算法的确定性特性、正则语言识别\",\"examples\":\"1. 冒泡排序：每步比较与交换位置由元素大小唯一确定；2. DFA识别正则语言：状态转移由当前状态和输入符号唯一决定；3. 线性搜索：遍历顺序与比较对象固定；4. 二分查找：中间位置由当前区间端点唯一计算\",\"theoretical_basis\":\"1. 图灵机模型：确定性图灵机（DTM）是计算理论基础，读写头移动与状态转移由当前状态和符号唯一确定；2. 算法形式定义：算法五大特性（输入、输出、确定性、有限性、有效性）之一，要求每步有唯一后继；3. 自动机理论：DFA的状态转移函数为单值函数（每个状态-输入对对应唯一状态）；4. 计算复杂性理论：确定性算法复杂度是问题难度分析基础，与NP类非确定性复杂度形成对比\"}",
  "14d99fa17ba75f327cf874147f7bc0ad": "{\n  \"description\": \"算法的基本特性之一，指算法必须在执行有限数量的步骤后终止，且每一步操作都能在有限的时间内完成\",\n  \"key_characteristic\": \"算法的执行步骤总数有限，且每一步的执行时间均为有限值\",\n  \"implications\": \"1. 不满足有穷性的过程无法被认定为有效算法；2. 保证问题求解过程可终止，避免无限循环或无限递归等无法结束的情况；3. 是算法实用性的基础，否则无法应用于实际场景求解问题\",\n  \"related_concepts\": [\"算法的确定性\", \"算法的可行性\", \"无限循环\", \"停机问题\", \"可计算性理论中的有效过程\"],\n  \"examples\": [\"求两个正整数最大公约数的欧几里得算法（通过不断取模操作缩小问题规模，步骤数有限且每步执行时间有限，满足有穷性）\", \"包含无限循环的程序（如while(true) { }，无法在有限步终止，不满足有穷性）\"],\n  \"theoretical_basis\": \"源自《算法导论》中对算法的定义（算法是解决特定问题的有限指令序列）；同时对应可计算性理论中“有效过程”的核心要求——步骤有限性，是算法与非算法过程的本质区别之一\"\n}",
  "0a174dcba37f2b10c6b49d66a6b6b2a5": "{\"description\": \"在计算机科学中，可行性通常指一个问题是否存在能够在有限时间和有限计算资源（如内存、处理器时间等）内解决的算法，或某个算法是否能在实际或理论的资源约束下有效执行，核心关注计算任务的可实现性与资源消耗的合理性\", \"key_characteristic\": \"1. 与计算资源的有限性强关联，要求算法执行的时间和空间消耗必须处于可接受的边界内；2. 是区分问题“可解”与“不可解”、算法“有效”与“无效”的核心判定标准；3. 依赖具体计算模型（如图灵机、随机存取机）定义“有限资源”的具体内涵；4. 对问题而言，可行性常关联到是否属于可计算类（如递归集）或具有多项式时间算法（如P类问题）\", \"implications\": \"1. 指导算法设计：优先选择可行性高的算法（如多项式时间复杂度），避免指数时间算法处理大规模数据；2. 推动问题分类：支撑计算复杂性理论中P、NP、NP难、不可判定问题等类别的划分；3. 工程决策依据：在实际系统中，可行性分析决定问题是否值得用计算机解决及技术方案选择（如近似算法、并行计算的应用）；4. 明确研究边界：界定计算机无法解决的问题（如停机问题），避免无效的算法探索\", \"related_concepts\": \"计算复杂性理论、可计算性理论、图灵机、丘奇-图灵论题、P类问题、NP类问题、不可判定问题、时间复杂度、空间复杂度、递归函数\", \"examples\": \"1. 排序问题：可行，归并排序（O(nlogn)）、快速排序（平均O(nlogn)）等多项式时间算法可在有限资源内处理大规模数据；2. 停机问题：不可行，不存在通用算法判断任意程序在任意输入下是否停机；3. 旅行商问题（TSP）：精确求解不可行（无多项式时间算法），但近似算法（如Christofides算法）可提供可行近似解；4. 整数加法：可行，基本算术操作在常数或线性时间内完成，符合有限资源要求\", \"theoretical_basis\": \"1. 图灵机模型：以“有限步骤内停机”定义可计算性，问题可行当且仅当存在图灵机在有限步内解决；2. 丘奇-图灵论题：将直观“可有效计算”等价于图灵机可计算，为可行性提供理论基石；3. 计算复杂性的资源约束：通过时间复杂度（执行步数）和空间复杂度（纸带单元格数）量化资源，将可行性与多项式时间/空间等可处理范围关联；4. 递归论：用递归函数和递归集定义不可判定问题的不可行性，如停机问题的不可解性证明\"}",
  "aa3e2061848ee8816ccc5f7624ad60b7": "{\"description\":\"最优子结构（Optimal Substructure）是动态规划等算法设计方法的核心性质之一，指问题的最优解可以由其子问题的最优解构造而来。具体而言，若要获得原问题的最优解，必须先求解其若干子问题的最优解，且原问题最优解的构造直接依赖于这些子问题最优解的结果\",\"key_characteristic\":\"问题的最优解包含其子问题的最优解；子问题的最优解可组合成原问题的最优解；支持自底向上（动态规划表填充）或自顶向下（记忆化搜索）的最优解构建方式\",\"implications\":\"是动态规划算法适用的必要条件之一（与重叠子问题共同构成动态规划的两大核心性质）；允许通过分解问题并复用子问题解降低时间复杂度；若问题不具备此性质，动态规划可能失效，需考虑贪心算法（依赖贪心选择性质）等其他方法\",\"related_concepts\":[\"动态规划（Dynamic Programming）\",\"重叠子问题（Overlapping Subproblems）\",\"贪心算法（Greedy Algorithm）\",\"子问题（Subproblem）\",\"记忆化搜索（Memoization）\"],\"examples\":[\"最短路径问题（如Dijkstra算法中，从源点到顶点v的最短路径包含从源点到路径上中间顶点u的最短路径）\",\"矩阵链乘法问题（最优括号化方案中，子链的括号化方式也是最优的）\",\"最长公共子序列（LCS）问题（两个序列的LCS最优解包含其前缀子序列的LCS最优解）\",\"0-1背包问题（选择是否放入第i个物品时，依赖前i-1个物品在剩余容量下的最优解）\"],\"theoretical_basis\":\"基于问题分解与最优解的可组合性，是递归算法优化为动态规划的理论支撑。《算法导论》明确指出，动态规划通过利用最优子结构和重叠子问题性质，将原本指数级时间复杂度的递归解法优化为多项式时间复杂度（如矩阵链乘法问题时间复杂度从O(2^n)降至O(n^3)）\"}",
  "3854fb7be219caa43735a29c2ca2d3f3": "{\"description\":\"贪心选择性质是贪心算法的核心性质之一，指全局最优解可通过一系列**局部最优的贪心选择**逐步构建而成。每一步选择仅依赖当前状态下的最优决策（即“贪心”地选取当前看起来最好的选项），无需回溯或考虑后续选择对当前决策的影响，最终由局部最优决策的累积得到全局最优解。\",\"key_characteristic\":\"1. 局部最优导向全局最优：每一步的局部最优选择最终能组合成问题的全局最优解；2. 无后效性：当前决策仅依赖当前状态，不受后续子问题决策的影响；3. 决策不可逆性：一旦做出贪心选择，该决策即被固定，后续步骤基于该选择继续构建解，无需修改或回溯；4. 决策单调性：贪心选择的方向（如“选最小权值”“选最早结束”）在整个求解过程中保持一致。\",\"implications\":\"1. 是贪心算法可行性的**必要条件**：若问题不满足贪心选择性质，贪心算法无法保证得到全局最优解；2. 简化求解复杂度：贪心选择避免了动态规划中对所有子问题解的枚举，通常使算法时间复杂度更低（如O(n log n)或O(m log n)）；3. 需严格证明：使用贪心算法前必须通过“交换论证”等方法证明问题满足该性质，否则可能得到次优解；4. 与最优子结构性质共同构成贪心算法正确性的**充要条件**。\",\"related_concepts\":[\"贪心算法（Greedy Algorithm）\",\"最优子结构性质（Optimal Substructure）\",\"动态规划（Dynamic Programming）\",\"霍夫曼编码（Huffman Coding）\",\"最小生成树（Minimum Spanning Tree）\",\"活动选择问题（Activity Selection Problem）\"],\"examples\":[\"活动选择问题：在一组互不重叠的活动中选最多活动，每次选**当前结束时间最早**的活动，最终得到全局最优解；\",\"霍夫曼编码：构造最优前缀码时，每次合并**当前频率最低**的两个节点，最终生成带权路径长度最短的霍夫曼树；\",\"最小生成树的Prim算法：每次选**连接当前树与剩余顶点的最小边**，逐步扩展生成树至包含所有顶点；\",\"最小生成树的Kruskal算法：按边权**从小到大**选不形成环的边，最终得到总权值最小的生成树。\"],\"theoretical_basis\":\"贪心选择性质的理论基础源于贪心算法的正确性证明框架。根据《算法导论》，贪心算法的正确性依赖于问题同时满足**贪心选择性质**和**最优子结构性质**。其中，贪心选择性质的证明通常采用**交换论证法**：假设存在一个全局最优解不包含当前的贪心选择，通过交换该解中的某个选择为贪心选择，证明交换后的解仍为全局最优，从而归纳得出“所有贪心选择的累积结果为全局最优”。这一性质是贪心算法区别于动态规划的核心——动态规划依赖子问题的最优解回溯，而贪心算法依赖当前的局部最优决策推进。\"}",
  "394654caecc3d9cb4f81903bd0ae7355": "{\"description\": \"全局最优是指在优化问题的整个可行解空间中，使目标函数（如最大化收益、最小化成本等）达到极值（最大值或最小值）的解，该解优于或等于所有其他可行解，是优化问题的理想目标解\", \"key_characteristic\": [\"考虑优化问题的完整可行解空间\", \"目标函数值优于或等于所有其他可行解\", \"其判定依赖于对整个解空间的评估（或通过理论性质推导）\", \"与局部最优形成对比：局部最优仅在邻域内最优，而全局最优是整体最优\"], \"implications\": [\"找到全局最优通常需要更高的计算成本（如遍历所有解或复杂搜索）\", \"对于NP难等复杂问题，全局最优可能无法在多项式时间内有效求解\", \"依赖目标函数和可行域的性质（如凸函数的局部最优即全局最优）\", \"是优化问题的终极目标，但实际中常因计算限制退而求其次使用局部最优\"], \"related_concepts\": [\"局部最优\", \"可行解空间\", \"凸优化\", \"全局搜索算法\", \"NP难问题\", \"目标函数\", \"极值定理\"], \"examples\": [\"线性规划问题的最优解（线性函数是凸的，其可行域为凸集，最优解必为全局最优）\", \"旅行商问题的精确解（找到遍历所有城市的最短路径，是全局最优但计算复杂度极高）\", \"凸函数f(x)=x²的最小值点x=0（所有局部极小值均为全局极小值）\", \"动态规划求解最长公共子序列（通过最优子结构组合得到全局最优解）\", \"枚举法求解小规模组合优化问题（遍历所有解找到全局最优）\"], \"theoretical_basis\": [\"极值定理：紧集上的连续函数必有最大值和最小值，为全局最优的存在性提供理论保障\", \"凸分析理论：凸函数在凸集上的任何局部极小值都是全局极小值，简化了全局最优的判定\", \"计算复杂性理论：NP完全问题的全局最优无法在多项式时间内求解（假设P≠NP）\", \"优化算法的正确性证明：如枚举法通过遍历所有解保证找到全局最优，动态规划通过最优子结构和重叠子问题保证全局最优\"]}",
  "d77f3b6efa5e57815fd0eab78a56143e": "{\"description\":\"重叠子问题是指在解决一个问题的递归过程中，多次重复计算相同子问题的现象，即不同的上层问题求解过程中需要用到同一个子问题的解\",\"key_characteristic\":\"1. 子问题在递归求解路径中被多次访问和计算；2. 问题的递归树中存在大量重复的子问题节点（即相同输入的子问题被多次展开）；3. 子问题的解具有复用性，可通过存储避免重复计算\",\"implications\":\"1. 直接递归求解会导致指数级时间复杂度（冗余计算导致时间浪费）；2. 是动态规划算法适用的必要条件之一（需与最优子结构共同满足）；3. 可通过动态规划的备忘录技术（Top-down记忆化搜索）或制表技术（Bottom-up迭代填表）优化，将时间复杂度降低至多项式级别；4. 提示问题适合用空间换时间的策略优化\",\"related_concepts\":[\"动态规划\",\"最优子结构\",\"备忘录法\",\"制表法\",\"斐波那契数列问题\",\"矩阵链乘法问题\",\"Floyd-Warshall算法\"],\"examples\":[\"1. 斐波那契数列递归计算：求f(5)时需计算f(4)和f(3)，求f(4)时需计算f(3)和f(2)，其中f(3)被重复计算2次；2. 矩阵链乘法递归求解：计算A₁A₂…Aₙ的最优括号化时，不同分割点可能重复计算同一子链Aᵢ…Aⱼ的最优乘积；3. 最长公共子序列问题：递归求解两个字符串的LCS时，子问题LCS(i,j)（前i个字符与前j个字符的LCS）会被多次调用\",\"theoretical_basis\":\"基于递归算法的时间复杂度分析：当子问题空间大小远小于递归树节点数时，重复计算会导致效率低下。其理论核心是通过缓存子问题的解（即“记忆”已解决的子问题），将时间复杂度从递归的指数级（如斐波那契的O(2ⁿ)）降为与子问题数量成正比的多项式级（如斐波那契动态规划的O(n)）。该概念由Richard Bellman在动态规划理论中正式提出，是动态规划算法设计的核心原则（参考《算法导论》第三版第15章“动态规划”）\"}",
  "e8ae8f1abb5083cff8ca46a8c08e141a": "{\"description\":\"局部最优是指在解决优化问题的过程中，每一步决策都选择当前局部范围内（即当前可用选项中）的最优解（如收益最大、成本最小等），而不考虑该选择对后续步骤或整体问题的长远影响\",\"key_characteristic\":\"1. 贪心策略的核心：是贪心算法的基本决策原则；2. 短视性：仅关注当前步骤的最优，不回溯调整之前的选择；3. 局部性：决策依据限于当前状态下的可用选项，不考虑全局状态的完整信息\",\"implications\":\"1. 正向影响：当问题满足贪心选择性质时，局部最优决策可直接导出全局最优解，简化问题求解复杂度（如活动选择、分数背包）；2. 负向影响：若问题不满足贪心选择性质，局部最优决策会导致全局次优解（如0-1背包问题用贪心策略）；3. 算法设计指导：局部最优为贪心算法提供了直观的决策依据，但需严格证明问题的贪心选择性质以确保正确性\",\"related_concepts\":\"贪心算法（局部最优是其决策基础）、全局最优（局部最优的目标终点，需验证局部到全局的推导关系）、贪心选择性质（局部最优能导出全局最优的关键条件）、动态规划（与贪心算法对比，通过记录子问题最优解处理全局依赖，避免局部最优的短视）、最优子结构（贪心算法和动态规划共需的理论条件，确保子问题最优性）\",\"examples\":\"1. 活动选择问题：每次选择当前结束时间最早的活动（局部最优），最终得到最大的兼容活动集合（全局最优）；2. 分数背包问题：每次选择价值密度（价值/重量）最高的物品装入（局部最优），最终得到最大总价值（全局最优）；3. 0-1背包问题的贪心尝试：若按价值密度排序选择物品，可能因剩余空间无法利用导致总价值低于动态规划解（局部最优导致全局次优）；4. 霍夫曼编码：每次选择频率最低的两个节点合并（局部最优），最终生成最优前缀码（全局最优）\",\"theoretical_basis\":\"局部最优的理论基础源于贪心算法的正确性证明框架，《算法导论》中指出贪心算法正确的两个必要条件：1. 贪心选择性质：可以通过做出局部最优选择来构造全局最优解，即无需考虑子问题的解即可做出当前的最优选择；2. 最优子结构：问题的最优解包含其子问题的最优解，即全局最优解的每一步局部选择也是对应子问题的最优解。只有同时满足这两个条件，局部最优决策才能保证全局最优\"}",
  "e60748538ccb506f1d6cb81416d15ef2": "{\"description\":\"顺序存储是一种数据存储方式，通过将数据元素按逻辑顺序依次存储在连续的物理内存空间中，使得元素的逻辑顺序与物理存储顺序完全一致\",\"key_characteristic\":\"1. 物理内存连续：所有元素占用连续的内存块；2. 逻辑-物理顺序一致：元素的逻辑位置（如第i个元素）与物理地址位置直接对应；3. 随机访问支持：可通过基地址和索引直接计算元素地址，实现O(1)时间的随机访问；4. 插入删除需移动元素：插入或删除非末尾元素时，需移动后续元素以保持连续性；5. 存储空间预分配或动态扩展：静态顺序存储（如固定大小数组）需预先分配空间，动态顺序存储（如动态数组）可按需扩展\",\"implications\":{\"访问效率\":\"随机访问效率极高（O(1)），适合查询频繁的场景；\",\"修改效率\":\"插入、删除操作效率较低（O(n)），因为需要移动大量元素；\",\"空间特性\":\"存储空间利用紧凑但可能存在预分配浪费（静态）或扩展时的额外开销（动态，如ArrayList扩容需复制元素）；\",\"适用场景\":\"适用于数据规模稳定、以随机访问为主、插入删除较少的场景，如静态数组、统计数据存储\"},\"related_concepts\":[\"数组（Array）\",\"顺序表（Sequential List）\",\"随机访问（Random Access）\",\"动态数组（Dynamic Array）\",\"链式存储（Linked Storage）\",\"内存连续分配（Contiguous Memory Allocation）\"],\"examples\":[\"C语言中的固定大小数组（如int arr[10]; 元素存储在连续内存中）\",\"Java中的ArrayList（动态顺序存储，底层通过数组实现，自动扩容）\",\"Python中的list（底层为动态数组，支持随机访问和动态扩展）\",\"C++中的std::vector（动态顺序容器，连续内存存储）\"],\"theoretical_basis\":\"1. 内存连续性原理：操作系统支持连续内存块的分配，通过基地址（首元素地址）和元素大小可计算任意元素的物理地址（地址计算公式：ElementAddress = BaseAddress + ElementSize × Index）；2. 逻辑结构与存储结构的对应关系：数据的逻辑结构（如线性结构）通过连续物理存储映射为顺序存储结构，保持逻辑顺序的一致性；3. 时间复杂度分析：基于元素移动次数的计算，插入删除操作的时间复杂度由移动元素的数量决定（最坏情况下需移动n个元素，故为O(n)）；4. 存储结构分类理论：数据结构的存储结构分为顺序存储和链式存储两大类，顺序存储是其中基于连续性的核心方式\"}",
  "0aa57b4d3a363477cd0f21da97187029": "{\"description\": \"链式存储（Linked Storage）是一种非连续、非顺序的存储结构，通过指针或引用将逻辑上相邻的元素（节点）链接起来，每个节点包含数据域（存储元素值）和指针域（存储后续节点的地址或引用）\", \"key_characteristic\": \"1. 存储单元非连续、非顺序，无需预先分配固定大小的存储空间；2. 每个节点由数据域和指针域组成，指针域用于建立节点间的逻辑关系；3. 元素的逻辑顺序通过指针链接实现，而非物理位置；4. 支持动态扩容/缩容，插入/删除操作无需移动大量元素；5. 访问元素需从头节点开始遍历，无法随机访问\", \"implications\": \"1. 插入和删除操作效率高（无需移动元素，仅修改指针），适用于频繁增删的场景；2. 无法随机访问元素（需遍历），随机访问效率低；3. 内存利用率灵活，但每个节点需额外存储指针域，存在内存开销；4. 对动态数据集合的适应性强，无需预先知道数据规模；5. 实现复杂数据结构（如链表、树、图）的基础存储方式\", \"related_concepts\": [\"链表（单链表、双链表、循环链表）\", \"顺序存储（数组）\", \"节点（Node）\", \"指针/引用\", \"动态内存分配\"], \"examples\": \"1. 单链表：每个节点包含数据域和一个指向后继节点的指针，仅能从表头向后遍历；2. 双链表：每个节点包含数据域、前驱指针和后继指针，支持双向遍历；3. 循环链表：最后一个节点的指针指向头节点（或第一个节点），形成环形结构；4. 链表实现的栈：通过头插法/尾插法实现栈的push（插入表头）和pop（删除表头）操作；5. 链表实现的队列：通过维护头指针和尾指针，实现队列的enqueue（尾插）和dequeue（头删）操作\", \"theoretical_basis\": \"1. 数据结构的存储结构分类理论：存储结构分为顺序存储和链式存储，分别对应物理位置连续和非连续的存储方式；2. 指针与内存地址理论：指针通过存储内存地址实现节点间的链接，是链式存储的核心机制；3. 动态内存分配理论：链式存储依赖动态内存分配（如C语言的malloc/free）来灵活创建和释放节点；4. 逻辑结构与物理结构的分离理论：链式存储将数据的逻辑顺序（如线性表的先后关系）与物理存储位置分离，通过指针维持逻辑关系\"}",
  "484406664a2e97890712246a8f9434cc": "{\"description\":\"数据结构的一种类型，其中数据元素按线性顺序排列，元素之间存在一对一的逻辑关系——存在唯一的起始元素（首元素）和唯一的终止元素（尾元素），除首元素外每个元素有且仅有一个直接前驱，除尾元素外每个元素有且仅有一个直接后继\",\"key_characteristic\":\"1. 逻辑结构的线性性：元素间是顺序的、一对一的相邻关系；2. 存储结构的两种形式：可采用连续存储（如数组，元素在内存中连续排列）或非连续存储（如链表，元素通过指针/引用链接）；3. 操作的顺序性：遍历、插入、删除等操作通常按线性顺序进行\",\"implications\":\"1. 存储结构影响操作效率：连续存储（数组）支持O(1)的随机访问，但插入/删除（非末尾）需移动元素，时间复杂度O(n)；非连续存储（链表）不支持随机访问（需O(n)遍历），但插入/删除（已知位置）仅需修改指针，时间复杂度O(1)；2. 适用场景明确：需频繁随机访问时选数组，需频繁插入/删除时选链表；3. 是栈、队列等抽象数据类型的基础结构\",\"related_concepts\":\"数组（Array）、链表（Linked List）、栈（Stack）、队列（Queue）、线性表（Linear List）、非线性结构（Non-linear Structure，如树、图）\",\"examples\":\"1. 数组（Array）：连续存储的线性结构，如int arr[5] = {1,2,3,4,5}；2. 单链表（Singly Linked List）：非连续存储，每个节点含数据和下一个节点的指针；3. 双链表（Doubly Linked List）：每个节点含前驱和后继指针的链表；4. 栈（Stack）：基于线性结构的后进先出（LIFO）结构，可由数组或链表实现；5. 队列（Queue）：基于线性结构的先进先出（FIFO）结构，可由数组或链表实现\",\"theoretical_basis\":\"基于“线性表”的数学定义（有限序列，元素间存在线性序关系），是《算法导论》中数据结构的基本分类之一（与非线性结构相对），其理论基础包括离散数学中的序列理论、内存分配策略（连续vs非连续）对操作复杂度的影响分析\"}",
  "da8a51969ee51bfd7ecf24440505a2a9": "{\"description\":\"有序序列是元素按照预先定义的顺序关系排列而成的数据集合，其中任意两个元素之间通常存在明确的可比较性（全序或偏序），元素的位置由其顺序关系决定\",\"key_characteristic\":\"1. 元素间存在严格或非严格的顺序关系（如≤、≥或自定义比较规则）；2. 支持按顺序访问元素（如从第一个到最后一个遍历）；3. 顺序关系满足自反性、反对称性和传递性（偏序），全序还满足完全性（任意两元素可比较）；4. 元素的位置与其顺序属性直接相关，而非仅依赖插入顺序\",\"implications\":\"1. 支持高效的有序操作（如二分查找，时间复杂度O(log n)，仅适用于全序且随机访问的有序序列）；2. 维护顺序需额外成本（如插入新元素时需找到正确位置，数组的插入复杂度为O(n)，链表为O(n)但无需移动元素）；3. 遍历操作具有可预测性（按顺序输出元素符合人类或算法的逻辑预期）；4. 依赖于稳定的比较规则，若比较规则改变则序列的有序性可能被破坏\",\"related_concepts\":\"全序集、偏序集、数组、链表、排序算法（如快速排序、归并排序）、二分查找、良序原理、比较器（Comparator）\",\"examples\":\"1. 按升序排列的整数数组：[1, 4, 6, 9, 12]；2. 按字典序排列的字符串列表：[\\\"cat\\\", \\\"dog\\\", \\\"elephant\\\", \\\"fox\\\"]；3. 按时间戳从早到晚排序的日志条目列表：[{time: 1620000000, content: \\\"start\\\"}, {time: 1620000001, content: \\\"process\\\"}, {time: 1620000002, content: \\\"end\\\"}]；4. 按优先级从高到低排列的任务队列：[Priority: High, Priority: Medium, Priority: Low]\",\"theoretical_basis\":\"基于集合论中的序理论（Order Theory），核心是偏序关系（Partial Order）和全序关系（Total Order）的定义：1. 偏序关系需满足自反性（a≤a）、反对称性（若a≤b且b≤a则a=b）、传递性（若a≤b且b≤c则a≤c）；2. 全序关系在偏序基础上增加完全性（任意a、b，要么a≤b要么b≤a）；3. 良序原理指出自然数集在通常的≤关系下是良序集（每个非空子集有最小元），为有序序列的遍历和归纳证明提供理论基础\"}",
  "87d268664fba6620497e0da9dc3d74d3": "{\"description\":\"无序序列是一种线性数据结构，其元素的排列不遵循任何预先定义的逻辑顺序（如数值大小、插入顺序或语义关联），元素的位置不反映其值或语义的相对关系\",\"key_characteristic\":[\"元素排列无固定逻辑顺序，不遵循升序、降序或插入顺序等规则\",\"元素的位置不承载其值或语义的相对关系\",\"访问特定元素通常需要线性遍历（无额外索引时）\",\"插入和删除操作无需维护顺序，位置选择不影响结构特性\"],\"implications\":[\"查找操作的时间复杂度通常为O(n)（线性遍历）\",\"插入/删除操作的时间复杂度较低（如链表插入头部为O(1)）\",\"适合以插入/删除为主、无需顺序访问的场景\",\"不适合频繁按顺序查询或范围查询的场景\"],\"related_concepts\":[\"有序序列\",\"线性表\",\"集合\",\"链表\",\"数组\",\"哈希表\"],\"examples\":[\"未按大小排序的整数数组（如[3,1,4,2,5]）\",\"每次插入到头部的链表（如依次插入5、3、7后的链表）\",\"存储随机用户ID的动态数组\",\"未维护插入顺序的元素集合（允许重复）\"],\"theoretical_basis\":\"基于序列抽象数据类型（ADT）的定义，去除顺序约束后形成的线性结构；其操作复杂度遵循线性查找的时间复杂度分析（如《算法导论》中线性搜索的O(n)最坏情况）；属于数据结构分类中按元素顺序性划分的非有序序列类别\"}",
  "3b7790a74874d8cd57e49d078556142f": "{\"description\":\"非线性结构是数据结构的一种类型，其数据元素之间的逻辑关系不满足线性顺序特征（即并非每个元素仅有唯一的前驱和后继），元素间通常存在一对多（如树）或多对多（如图）的关联关系\",\"key_characteristic\":\"1. 元素间逻辑关系非线性：存在一对多或多对多的复杂关联；2. 无固定线性顺序：无法通过单一线性序列完整表示所有元素的依赖或连接关系；3. 访问方式依赖结构特性：需通过路径遍历（如树的DFS/BFS）或搜索算法（如图的Dijkstra）访问元素，不支持线性结构的直接顺序/随机访问\",\"implications\":\"1. 算法设计复杂度提升：遍历、搜索等操作需针对结构特性定制（如树需处理层次，图需处理环路）；2. 建模灵活性增强：能高效表示现实中复杂关系（如社交网络、文件系统）；3. 操作效率分化：不同结构的时间复杂度差异大（如平衡树查找O(log n)，图的最短路径O(E log V)）\",\"related_concepts\":\"树（二叉树、平衡树、堆）、图（有向图、无向图、加权图）、森林、邻接表、邻接矩阵\",\"examples\":\"1. 数据结构实例：二叉搜索树（数据库索引）、无向图（社交网络好友关系）、最大堆（优先队列）；2. 现实场景：文件系统目录（树结构）、地图路由拓扑（图结构）、家谱（树结构）\",\"theoretical_basis\":\"1. 离散数学的树论与图论：树（连通无环图）、图（顶点-边二元组）的定义是核心理论基础；2. 数据结构分类体系：基于元素逻辑关系的线性性，将结构划分为线性与非线性的分类框架；3. 遍历与搜索理论：树的递归/迭代遍历、图的最短路径/连通性算法（如Dijkstra、Union-Find）的理论支撑\"}",
  "97c0e94c729373f49e31f47686bcb609": "{\"description\":\"二叉树（Binary Tree）是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点，且子节点的顺序固定（左子树与右子树不可互换）。空树或仅含根节点的结构均属于二叉树，是许多高级树形结构（如二叉搜索树、堆、AVL树）的基础。\",\"storage_method\":\"1. 链式存储：每个节点包含数据域和两个指针域（左指针指向左子节点，右指针指向右子节点），通过指针链接形成树结构，适用于任意形态的二叉树；2. 顺序存储：使用数组存储，完全二叉树中第i个节点（根节点索引为1）的左子节点为2i、右子节点为2i+1，非完全二叉树会因填充空节点导致数组空间浪费。\",\"properties\":\"1. 每个节点最多有2个子节点（左、右子树）；2. 子节点顺序有别，左右互换后为不同二叉树；3. 第k层最多含2^(k-1)个节点（k≥1）；4. 深度为h的二叉树最多含2^h - 1个节点（满二叉树）；5. 任意非空二叉树中，叶子节点数n₀等于度为2的节点数n₂加1（n₀ = n₂ + 1）；6. 完全二叉树的叶子节点仅出现在最后两层，且最后一层的节点靠左排列。\",\"time_complexity\":{\"前序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"中序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"后序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"层序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"插入节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"删除节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"查找节点\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":\"1. 链式存储：O(n)，每个节点需存储数据和两个指针，空间与节点数线性相关；2. 顺序存储：完全二叉树为O(n)，非完全二叉树为O(2^h - 1)（h为树的深度），空节点需占用数组位置。\",\"related_algorithms\":\"递归/迭代二叉树遍历算法、二叉搜索树插入/删除/查找算法、堆排序（基于完全二叉树）、Huffman树构造算法、AVL树平衡调整算法、红黑树插入修复算法、二叉树镜像反转算法、层序广度优先搜索（BFS）算法。\",\"common_operations\":[{\"operation_name\":\"前序遍历\",\"typical_usage\":\"用于打印二叉树结构、复制二叉树、前缀表达式求值等场景，遍历顺序为「根→左→右」\"},{\"operation_name\":\"中序遍历\",\"typical_usage\":\"用于二叉搜索树的有序访问（升序输出节点值）、查找前驱/后继节点等场景，遍历顺序为「左→根→右」\"},{\"operation_name\":\"后序遍历\",\"typical_usage\":\"用于删除二叉树（先删子节点再删根）、计算子树大小/总和等场景，遍历顺序为「左→右→根」\"},{\"operation_name\":\"层序遍历\",\"typical_usage\":\"用于按层打印树结构、寻找树的最小深度、广度优先搜索（BFS）等场景，遍历顺序为「按层次从左到右」\"},{\"operation_name\":\"插入节点\",\"typical_usage\":\"用于构建二叉树、向现有树中添加新数据等场景，需找到合适的叶子节点位置插入\"},{\"operation_name\":\"删除节点\",\"typical_usage\":\"用于维护树结构完整性，删除指定节点后需调整子树（如叶子节点直接删除、非叶子节点用后继节点替换）\"},{\"operation_name\":\"查找节点\",\"typical_usage\":\"用于寻找特定值的节点位置，如在二叉树中定位目标元素、统计节点出现次数等场景\"}]}",
  "e4b8bb922f6ad69c409f8daaa389b918": "{\"description\":\"树是一种非线性数据结构，由n（n≥0）个节点构成的有限集合；当n=0时为空树，n>0时存在唯一的根节点，其余节点可划分为若干互不相交的有限子集，每个子集本身也是树（称为根的子树）\",\"storage_method\":\"主要有两种存储方式：1. 顺序存储：利用数组存储，适用于完全二叉树，通过索引关系表示父子节点（如根节点索引为0时，第i个节点的左子节点为2i+1，右子节点为2i+2）；2. 链式存储：每个节点包含数据域和指向子节点的指针域（如二叉树节点含左、右指针，多叉树节点含子节点列表指针）\",\"properties\":\"1. 根节点无父节点，其余每个节点有且仅有一个父节点；2. 节点的子树互不相交；3. 树的高度（Height）是根节点到最远叶子节点的边数，节点的深度（Depth）是该节点到根节点的边数；4. 节点的度（Degree）是其子节点的数量，树的度是所有节点度的最大值；5. 叶子节点是度为0的节点\",\"time_complexity\":{\"查找（二叉搜索树）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"插入（二叉搜索树）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"删除（二叉搜索树）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"前序/中序/后序遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"层序遍历（BFS）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"求树的高度\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"顺序存储\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链式存储\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"递归遍历（栈空间）\":{\"best_case\":\"O(logn)\",\"average_case\":\"O(logn)\",\"worst_case\":\"O(n)\"},\"层序遍历（队列空间）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"related_algorithms\":[\"二叉搜索树插入/删除算法\",\"AVL树旋转算法\",\"红黑树调整算法\",\"堆排序算法\",\"广度优先搜索（BFS）\",\"深度优先搜索（DFS）\",\"哈夫曼编码算法\",\"并查集（Disjoint Set Union, DSU）算法\"],\"common_operations\":[{\"name\":\"遍历（前序/中序/后序/层序）\",\"typical_usage\":\"访问树中所有节点，用于打印节点内容、计算节点总和、查找特定元素等场景\"},{\"name\":\"插入节点\",\"typical_usage\":\"向树中添加新元素，如二叉搜索树中插入键值对以维持有序性\"},{\"name\":\"删除节点\",\"typical_usage\":\"移除树中指定元素，如从二叉搜索树中删除键并调整结构保持性质\"},{\"name\":\"查找节点\",\"typical_usage\":\"根据值或键定位节点，如判断二叉搜索树中是否存在目标键\"},{\"name\":\"求树的高度\",\"typical_usage\":\"计算树的深度，用于判断二叉树是否平衡（如AVL树平衡因子计算）\"},{\"name\":\"求节点的度\",\"typical_usage\":\"统计节点的子节点数量，用于多叉树构建或节点结构分析\"}]}",
  "e4319c9d9e9697d2f0009ba05f358fc0": "{\"description\":\"双向链表是一种线性数据结构，每个节点包含数据域和两个指针域（前驱指针prev与后继指针next），分别指向其前一个和后一个节点，支持从头部或尾部双向遍历及操作\",\"storage_method\":\"链式存储，通过节点的指针域连接元素，节点在内存中不连续分配，每个节点需额外存储前驱和后继指针\",\"properties\":\"1. 节点含prev和next双指针，支持双向遍历；2. 插入/删除无需移动元素仅调整指针；3. 动态扩展无需预分配固定内存；4. 额外前驱指针增加空间开销；5. 通常维护头（head）尾（tail）指针以支持首尾快速操作\",\"time_complexity\":{\"初始化\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"头部插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"尾部插入\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"中间插入\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"头部删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"尾部删除\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"中间删除\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"按值查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"按位置查找\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"related_algorithms\":[\"LRU缓存算法\",\"双向链表反转算法\",\"合并有序双向链表算法\",\"约瑟夫环问题求解算法\"],\"common_operations\":[{\"name\":\"初始化\",\"typical_usage\":\"创建空双向链表，初始化头指针和尾指针\"},{\"name\":\"头部插入\",\"typical_usage\":\"栈的push操作等需快速在开头添加元素的场景\"},{\"name\":\"尾部插入\",\"typical_usage\":\"队列的enqueue操作等需快速在末尾添加元素的场景\"},{\"name\":\"中间插入\",\"typical_usage\":\"有序链表中插入元素以保持有序的场景\"},{\"name\":\"头部删除\",\"typical_usage\":\"栈的pop操作或队列的dequeue操作等需快速删除开头元素的场景\"},{\"name\":\"尾部删除\",\"typical_usage\":\"双端队列的尾部弹出操作等需快速删除末尾元素的场景\"},{\"name\":\"中间删除\",\"typical_usage\":\"LRU缓存中删除最久未使用元素等需删除指定位置元素的场景\"},{\"name\":\"按值查找\",\"typical_usage\":\"检查元素是否存在于链表中的场景\"},{\"name\":\"按位置查找\",\"typical_usage\":\"访问链表第k个元素的场景\"},{\"name\":\"遍历\",\"typical_usage\":\"打印所有元素或统计元素个数等需依次访问所有元素的场景\"}]}",
  "00d23b9228985deb5f9dffe3f700f76b": "{\"description\":\"大根堆（Max-Heap）是满足大根堆性质的完全二叉树数据结构，每个节点的值大于等于其左右子节点的值（若存在），根节点为堆中最大值；通常采用数组存储，利用完全二叉树的索引特性（父节点i的左子为2i+1、右子为2i+2，子节点j的父为(j-1)//2）实现高效的父/子节点访问。\",\"storage_method\":\"大根堆通常采用数组存储，按完全二叉树的层序遍历顺序将节点存入数组；无需额外指针空间，通过索引计算即可快速访问父节点和子节点，空间利用率高。\",\"properties\":[\"结构特性：完全二叉树，除最后一层外均填满，最后一层节点靠左排列；\",\"堆序性质：每个节点的值≥其左右子节点的值；\",\"根节点特性：根节点是堆中的最大值；\",\"索引关系：数组存储时，父节点i的左子为2i+1、右子为2i+2，子节点j的父为(j-1)//2；\",\"高度特性：含n个元素的大根堆高度为⌊log₂n⌋（根到叶子的最长路径边数）\"],\"time_complexity\":{\"建堆（Build Max-Heap）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"插入（Insert）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"删除最大值（Extract Max）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"堆化（Max-Heapify）\":{\"best_case\":\"O(log n)\",\"average_case\":\"O(log n)\",\"worst_case\":\"O(log n)\"},\"获取最大值（Get Max）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"space_complexity\":\"总空间复杂度为O(n)（n为元素数量）；若采用迭代堆化，额外空间复杂度O(1)；若采用递归堆化，额外空间复杂度O(log n)（递归栈深度）。\",\"related_algorithms\":[\"堆排序（Heapsort）：利用大根堆性质实现的排序算法，时间复杂度O(n log n)；\",\"最大优先队列（Max Priority Queue）：大根堆是其核心实现结构，支持插入、提取最大值等操作；\",\"Dijkstra算法：求解单源最短路径时，用优先队列（大根堆/小根堆）快速获取当前最短路径节点；\",\"Prim算法：求解最小生成树时，用优先队列（大根堆/小根堆）选择下一个生成树节点；\",\"Top K问题：寻找数组前K小元素时，用大根堆维护候选的K个最小元素（新元素小于堆顶则替换并堆化）。\"],\"common_operations\":[{\"name\":\"建堆（Build Max-Heap）\",\"description\":\"将无序数组转换为满足大根堆性质的完全二叉树，通过从最后一个非叶子节点开始逐次堆化实现。\",\"typical_usage\":\"初始化堆结构，为堆排序或最大优先队列提供初始数据；\"},{\"name\":\"插入（Insert）\",\"description\":\"将新元素添加至堆末尾，通过向上调整（Sift Up）操作（与父节点比较并交换，直到满足堆序性质）恢复大根堆。\",\"typical_usage\":\"动态向最大优先队列添加元素，如任务调度系统中加入新的高优先级任务；\"},{\"name\":\"删除最大值（Extract Max）\",\"description\":\"移除堆顶最大值，将堆最后一个元素移至堆顶，通过向下调整（Sift Down）操作（与子节点比较并交换，直到满足堆序性质）恢复大根堆。\",\"typical_usage\":\"从最大优先队列中取出最高优先级元素，如任务调度中执行最紧急的任务；\"},{\"name\":\"堆化（Max-Heapify）\",\"description\":\"针对违反大根堆性质的节点（值小于子节点），递归/迭代地与最大子节点交换并调整，使该节点及其子树满足堆序性质。\",\"typical_usage\":\"建堆过程中修复局部堆结构，或删除元素后恢复整体堆性质；\"},{\"name\":\"获取最大值（Get Max）\",\"description\":\"直接返回堆顶元素（数组第一个元素），不修改堆结构。\",\"typical_usage\":\"快速查询堆中最大元素，如监控系统实时查看最高负载值或最高温度。\"}]}",
  "b95a93d4d1289e064fefa688ccf4e65d": "{\"description\":\"循环链表（Circular Linked List）是链表的一种变体，其最后一个节点的指针（next）指向链表的头节点（单向循环链表），或双向循环链表中头节点的前驱指针（prev）指向尾节点、尾节点的后继指针（next）指向头节点，形成闭合环形结构。与普通链表不同，循环链表无NULL终止指针，可从任意节点出发遍历整个链表\",\"storage_method\":\"采用链式存储结构，通过动态分配的节点（Node）存储数据。单向循环链表的节点含数据域（data）和后继指针域（next）；双向循环链表的节点额外含前驱指针域（prev）。节点间通过指针链接成闭合环，无需连续内存空间\",\"properties\":\"1. 闭合环形：尾节点与头节点相连，无NULL指针；2. 遍历灵活性：可从任意节点开始遍历全链表；3. 操作效率：维护尾指针时，单向循环链表的头尾插入/删除可优化至O(1)，双向循环链表头尾操作均为O(1)；4. 动态空间：节点动态分配，无需预分配固定大小；5. 适合循环场景：如约瑟夫环、轮询调度等需要环形遍历的问题\",\"time_complexity\":{\"初始化\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"头部插入（维护尾指针）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"尾部插入（维护尾指针）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"中间插入\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"头部删除（维护尾指针）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"尾部删除（单向循环无尾指针）\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"尾部删除（双向循环）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"查找（按值）\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"遍历\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"space_complexity\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"related_algorithms\":\"约瑟夫环问题求解算法、环形缓冲区实现算法、轮询调度（Round-Robin）算法、双向循环链表优化插入/删除算法、循环链表遍历算法\",\"common_operations\":[{\"operation_name\":\"初始化\",\"typical_usage\":\"创建空循环链表或带初始节点的循环链表，作为后续操作的基础\"},{\"operation_name\":\"头部插入（维护尾指针）\",\"typical_usage\":\"循环队列的队首添加元素，利用尾指针优化至O(1)操作\"},{\"operation_name\":\"尾部插入（维护尾指针）\",\"typical_usage\":\"循环队列的队尾添加元素，如生产者-消费者模型中的入队操作\"},{\"operation_name\":\"中间插入\",\"typical_usage\":\"按位置顺序插入元素，如在环形任务列表的指定位置插入新任务\"},{\"operation_name\":\"头部删除（维护尾指针）\",\"typical_usage\":\"循环队列的队首移除元素，如消费者从队列中取出最前元素\"},{\"operation_name\":\"尾部删除（双向循环）\",\"typical_usage\":\"双向循环链表中快速移除尾节点，如撤销操作中的最后一步回退\"},{\"operation_name\":\"查找（按值）\",\"typical_usage\":\"在约瑟夫环问题中查找待删除的节点，或轮询中定位目标节点\"},{\"operation_name\":\"遍历\",\"typical_usage\":\"轮询所有进程进行调度（如操作系统的Round-Robin调度），或从任意节点开始处理全链表元素\"}]}",
  "a2a6f2ba7cbd11b9a3fa74125ec24798": "{\"description\":\"图是一种非线性数据结构，由顶点集合V和边集合E组成，其中边是顶点之间的二元关系。边可以是有向的（表示顶点间的单向关系）或无向的（表示双向关系），边还可带有权值（称为加权图或网）。图用于建模实体间的复杂关系，如社交网络、路由网络等。\",\"storage_method\":\"图的常见存储方式包括：1. 邻接矩阵：使用二维数组存储顶点间的连接关系，若顶点i和j之间有边，则matrix[i][j]为边的权重（或1表示存在边），否则为0；适用于稠密图。2. 邻接表：使用数组或哈希表，每个顶点对应一个链表（或动态列表）存储其相邻顶点及边信息；适用于稀疏图。3. 邻接多重表：针对无向图的优化存储结构，每条边仅存储一次，避免邻接表中边的重复存储，适用于频繁删除边的场景。4. 十字链表：针对有向图的优化存储结构，每个顶点维护入边和出边两个链表，便于同时处理入度和出度相关操作。\",\"properties\":\"图的核心性质包括：1. 顶点度数：无向图中顶点的边数称为度数，有向图中分为入度（指向该顶点的边数）和出度（从该顶点出发的边数）；2. 路径与环：顶点序列v1,v2,...,vk中若相邻顶点间有边，则称为路径；起点等于终点且边数≥1的路径称为环；3. 连通性：无向图中任意两顶点可达则为连通图，否则为非连通图；有向图中任意两顶点互相可达则为强连通图；4. 稀疏与稠密：若边数E远小于顶点数平方V²（通常E≤VlogV）则为稀疏图，否则为稠密图；5. 权重：边可携带权值，用于表示顶点间的距离、成本等信息，带权图称为网。\",\"time_complexity\":{\"添加顶点\":{\"邻接矩阵\":{\"best_case\":\"O(n²)\",\"average_case\":\"O(n²)\",\"worst_case\":\"O(n²)\"},\"邻接表\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"删除顶点\":{\"邻接矩阵\":{\"best_case\":\"O(n²)\",\"average_case\":\"O(n²)\",\"worst_case\":\"O(n²)\"},\"邻接表\":{\"best_case\":\"O(1)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"}},\"添加边\":{\"邻接矩阵\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"邻接表\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"删除边\":{\"邻接矩阵\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"邻接表\":{\"best_case\":\"O(1)\",\"average_case\":\"O(d)\",\"worst_case\":\"O(d)\"}},\"查找边\":{\"邻接矩阵\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"邻接表\":{\"best_case\":\"O(1)\",\"average_case\":\"O(d)\",\"worst_case\":\"O(d)\"}},\"遍历邻接边\":{\"邻接矩阵\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"邻接表\":{\"best_case\":\"O(d)\",\"average_case\":\"O(d)\",\"worst_case\":\"O(d)\"}}},\"space_complexity\":{\"邻接矩阵\":\"O(V²)\",\"邻接表\":\"O(V + E)\",\"邻接多重表\":\"O(V + E)\",\"十字链表\":\"O(V + E)\"},\"related_algorithms\":\"图的相关算法包括：广度优先搜索（BFS）、深度优先搜索（DFS）、Dijkstra最短路径算法、Bellman-Ford最短路径算法、Floyd-Warshall全源最短路径算法、Prim最小生成树算法、Kruskal最小生成树算法、Kahn拓扑排序算法、Tarjan强连通分量算法、Kosaraju强连通分量算法、Ford-Fulkerson最大流算法、Edmonds-Karp最大流算法。\",\"common_operations\":[{\"operation_name\":\"添加顶点\",\"description\":\"向图中新增一个顶点\",\"typical_usage\":\"动态扩展图结构，如社交网络中添加新用户、地图系统中添加新地点\"},{\"operation_name\":\"删除顶点\",\"description\":\"从图中移除一个顶点及所有与该顶点相关的边\",\"typical_usage\":\"移除图中不再需要的节点，如社交网络中删除用户、推荐系统中移除失效物品\"},{\"operation_name\":\"添加边\",\"description\":\"在两个顶点之间建立一条边（可指定方向和权重）\",\"typical_usage\":\"建立顶点间的关系，如社交网络中添加好友关系、交通系统中新增道路连接\"},{\"operation_name\":\"删除边\",\"description\":\"移除两个顶点之间的边\",\"typical_usage\":\"解除顶点间的关系，如社交网络中解除好友关系、交通系统中关闭某条道路\"},{\"operation_name\":\"查找边\",\"description\":\"判断两个顶点之间是否存在边（或获取边的权重）\",\"typical_usage\":\"验证顶点间的关系，如查询社交网络中两人是否是好友、物流系统中检查两地是否有直达路线\"},{\"operation_name\":\"遍历邻接顶点\",\"description\":\"访问某顶点的所有相邻顶点\",\"typical_usage\":\"基于邻居的推荐系统（如推荐用户的好友）、网络爬虫中遍历网页的链接\"},{\"operation_name\":\"广度优先搜索（BFS）\",\"description\":\"从起始顶点出发，按层级顺序遍历所有可达顶点\",\"typical_usage\":\"寻找无权图中的最短路径（如社交网络中两人的最短好友链）、层级式数据处理（如组织架构的层级遍历）\"},{\"operation_name\":\"深度优先搜索（DFS）\",\"description\":\"从起始顶点出发，沿路径一直深入到无法继续，再回溯遍历其他路径\",\"typical_usage\":\"检测图中的环（如编译器中的循环依赖检测）、拓扑排序（如项目任务的依赖顺序安排）、深度挖掘数据（如文件系统的递归遍历）\"}]}",
  "d27ea67bf0b0f10bfa5364cc3eba148c": "{\"description\":\"具有相同数据类型的n（n≥0）个数据元素的有限序列，元素间存在一对一线性逻辑关系：首元素无前驱，尾元素无后继，其余元素有唯一前驱和后继\",\"storage_method\":\"分为顺序存储（顺序表，连续内存空间，逻辑与物理顺序一致，用数组实现）和链式存储（链表，非连续内存，元素含数据域与指针域，通过指针链接逻辑顺序，如单链表、双链表）\",\"properties\":\"1.逻辑线性性：元素按顺序排列，有明确前驱后继；2.元素同构性：所有元素数据类型一致；3.长度有限性：元素个数n有限，n=0时为空表；4.操作确定性：支持按位或按值访问修改；5.实现多样性：可通过顺序或链式方式实现，各有优缺点\",\"time_complexity\":{\"初始化\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"插入\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"删除\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"按位查找\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"按值查找\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"获取长度\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}},\"遍历\":{\"顺序实现\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"},\"链式实现\":{\"best_case\":\"O(n)\",\"average_case\":\"O(n)\",\"worst_case\":\"O(n)\"}},\"判断空\":{\"顺序实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"},\"链式实现\":{\"best_case\":\"O(1)\",\"average_case\":\"O(1)\",\"worst_case\":\"O(1)\"}}},\"space_complexity\":{\"顺序实现\":\"O(n)（需预分配连续内存，可能存在空间浪费）\",\"链式实现\":\"O(n)（每个元素需额外存储指针域，无预分配浪费）\"},\"related_algorithms\":[\"插入排序\",\"冒泡排序\",\"线性查找\",\"链表反转\",\"合并两个有序链表\",\"动态数组扩容\"],\"common_operations\":{\"初始化\":{\"typical_usage\":\"创建空线性表以存储后续数据，如初始化学生成绩列表\"},\"插入\":{\"typical_usage\":\"在指定位置添加元素，如在班级列表第3位插入新学生信息\"},\"删除\":{\"typical_usage\":\"移除指定位置元素，如删除退学学生的列表信息\"},\"按位查找\":{\"typical_usage\":\"获取特定位置元素，如查询数组第10个元素值\"},\"按值查找\":{\"typical_usage\":\"查找首个目标值元素位置，如找成绩列表中第一个满分学生位置\"},\"获取长度\":{\"typical_usage\":\"统计元素数量，如计算班级学生总数\"},\"遍历\":{\"typical_usage\":\"依次访问所有元素，如打印所有学生成绩或计算平均值\"},\"判断空\":{\"typical_usage\":\"检查是否无数据，如判断成绩列表是否未录入\"}}}}",
  "975edd4d88f483478846bb27f85e5de9": "{\"description\":\"生成森林是无向图的子图集合，由原图各连通分量的生成树组成，包含原图所有顶点，边集为原图边集的子集，且每个连通分量对应的子图是该分量的生成树（无环且连通），总边数为顶点数减去连通分量数。\",\"storage_method\":\"1. 邻接表：各连通分量的生成树用邻接表存储，整体为多邻接表集合；2. 父指针数组：每个顶点记录父节点（根节点父为自身或-1），通过父指针追溯连通分量及树结构；3. 邻接矩阵：空间效率低，仅适用于顶点数少的图。\",\"properties\":\"1. 结构组成：由各连通分量的生成树构成；2. 顶点覆盖：包含原图所有顶点；3. 边数特征：总边数=顶点数V-连通分量数k（E'=V-k）；4. 无环性：不含任何环；5. 极小连通性：每个生成树是对应分量的极小连通子图（删任意边会导致分量不连通）；6. 分量对应：每棵树对应原图一个连通分量。\",\"time_complexity\":{\"Kruskal算法构建\":{\"best_case\":\"O(E log E)\",\"average_case\":\"O(E log E)\",\"worst_case\":\"O(E log E)\"},\"Prim算法构建（邻接表+二叉堆）\":{\"best_case\":\"O(E log V)\",\"average_case\":\"O(E log V)\",\"worst_case\":\"O(E log V)\"},\"DFS构建\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"},\"BFS构建\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"}},\"space_complexity\":{\"邻接表存储\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"父指针数组存储\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"Kruskal算法构建空间\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"},\"Prim算法构建空间（邻接表+二叉堆）\":{\"best_case\":\"O(V + E)\",\"average_case\":\"O(V + E)\",\"worst_case\":\"O(V + E)\"},\"DFS构建空间\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"},\"BFS构建空间\":{\"best_case\":\"O(V)\",\"average_case\":\"O(V)\",\"worst_case\":\"O(V)\"}},\"related_algorithms\":\"Kruskal算法,Prim算法,深度优先搜索(DFS),广度优先搜索(BFS),并查集(Union-Find)\",\"common_operations\":{\"构建生成森林\":{\"description\":\"用Kruskal、Prim、DFS或BFS等算法，根据无向图生成其生成森林\",\"typical_usage\":\"网络设计中构建最小成本连通结构（最小生成森林）、图连通性分析、生成图的极小连通子图集合\"},\"查询连通分量\":{\"description\":\"通过父指针数组或邻接表，判断两顶点是否属同一连通分量\",\"typical_usage\":\"社交网络判断用户是否在同一社交圈、网络故障排查判断两节点是否在同一连通区域\"},\"添加边\":{\"description\":\"向生成森林加边前验证两顶点是否属不同连通分量，是则加边合并分量，否则拒绝以避免环\",\"typical_usage\":\"动态图新增边后维护生成森林结构，如社交网络新增好友后更新连通分量\"},\"删除边\":{\"description\":\"从生成森林删边，若边属某生成树则导致分量分裂，需重构分裂后的两分量生成树\",\"typical_usage\":\"动态图删边后调整生成森林，如网络链路失效后重新规划连通结构\"},\"获取连通分量数\":{\"description\":\"统计生成森林中的树数量，即原图的连通分量数\",\"typical_usage\":\"图拓扑分析统计独立连通区域数量，如城市道路网络统计独立街区数量\"}}}",
  "a5dfd815e3245de7bd79166f8c8a2c63": "{\"notation\":\"E[T(n)]（结合渐近符号如Θ、O、Ω等使用）\",\"description\":\"算法在所有可能的输入实例上的期望运行时间，其中输入实例服从预先定义的概率分布，用于量化算法在典型或随机输入下的平均性能表现\",\"typical_cases\":{\"快速排序（随机输入）\":\"Θ(n log n)\",\"哈希表（链地址法，负载因子α<1）\":\"O(1)\",\"线性查找（目标元素随机分布）\":\"Θ(n)\"},\"explanation\":\"平均情况复杂度通过期望运算整合了输入的概率分布信息，平衡了最坏情况的极端悲观性与最好情况的理想乐观性。其有效性高度依赖于输入分布假设的合理性——例如快速排序假设输入随机排列，若实际输入符合该假设，则平均情况复杂度能准确反映算法的典型性能；若假设偏离实际（如输入已有序），则结果可能与实际性能不符\",\"best_case\":\"未定义\",\"average_case\":\"未定义\",\"worst_case\":\"未定义\",\"example\":\"以快速排序为例，假设输入数组的所有排列等概率出现，其运行时间T(n)的期望满足递归式E[T(n)] = (2/n)Σ_{k=0}^{n-1} E[T(k)] + Θ(n)（边界条件E[T(0)]=E[T(1)]=Θ(1)）。通过展开递归式并利用调和级数性质，可证明E[T(n)] = Θ(n log n)，即快速排序的平均时间复杂度为Θ(n log n)；再如线性查找，若目标元素存在且每个位置的概率均等，则平均需要检查(n+1)/2个元素，故平均时间复杂度为Θ(n)\"}",
  "3f3850b6b6f66b3301bf85b8068f07ea": "{\"notation\":\"无特定符号表示，作为摊还复杂度分析方法使用\",\"description\":\"聚合分析（Aggregate Analysis）是摊还分析的基础方法之一，通过计算n个操作序列的总实际时间，将总时间除以操作次数n得到每个操作的平均摊还时间。其核心是忽略单个操作的最坏情况，通过整体总时间的上界保证平均意义下每个操作的高效性，是摊还分析中最直观的方法。\",\"typical_cases\":[\"二进制计数器递增操作的摊还复杂度分析\",\"动态数组（如C++ Vector、Java ArrayList）插入扩容的摊还复杂度分析\",\"栈的批量Pop操作（如每次弹出k个元素）的摊还复杂度分析\"],\"explanation\":\"聚合分析的核心逻辑是将操作序列视为整体，不单独分析每个操作的成本，而是计算所有操作的总实际时间T(n)，并证明T(n) ≤ C·n（C为常数）。此时每个操作的摊还时间定义为T(n)/n，即平均每个操作的成本。该方法适用于操作序列中高成本操作（如动态数组扩容、计数器高位翻转）发生频率较低的场景，通过整体总时间的上界直接推导平均表现，无需为单个操作分配不同的摊还成本。\",\"best_case\":{\"摊还时间复杂度\":\"O(1)\"},\"average_case\":{\"摊还时间复杂度\":\"O(1)\"},\"worst_case\":{\"摊还时间复杂度\":\"O(1)\"},\"example\":\"以二进制计数器的递增操作为例：计数器初始为全0，每次递增将最低位翻转，若该位为1则继续翻转更高位直到遇到0。计算n次递增的总翻转次数：最低位翻转n次，第二位翻转⌊n/2⌋次，第三位翻转⌊n/4⌋次，…，第k位翻转⌊n/2^(k-1)⌋次。总次数为Σ（i=0到∞）⌊n/2^i⌋ ≤ 2n，因此总时间T(n)=O(n)，每个递增操作的摊还时间为T(n)/n=O(1)。\\n另一个典型例子是动态数组的插入操作：初始容量为1，每次数组满时扩容至原容量的2倍。插入n个元素的总时间为1（第一次插入）+2（扩容后插入）+4（再次扩容后插入）+…+2^k（最后一次扩容后插入），其中2^k≥n。总和为2^(k+1)-1 ≤2n，因此总时间T(n)=O(n)，平均每个插入操作的摊还时间为O(1)。\"}"
}