一个长度为n的顺序表，删除第i个元素（1≤i≤n）的时间复杂度是：
A. O(1)
B. O(n)
C. O(logn)
D. O(n^2)
答案：B
一个单链表中，如果要删除指针p所指向的结点的后继结点，正确的操作是：
A. p->next = p->next->next
B. p->next = p->next->next->next
C. p->next->next = p->next
D. p->next = p
答案：A
一个栈的入栈序列为1,2,3,4,5，出栈序列不可能是：
A. 5,4,3,2,1
B. 4,5,3,2,1
C. 3,4,5,2,1
D. 1,2,3,4,5
答案：D
一个队列的入队序列为1,2,3,4,5，出队序列不可能是：
A. 1,2,3,4,5
B. 5,4,3,2,1
C. 2,1,3,4,5
D. 1,3,2,4,5
答案：B
以下关于二叉树的描述，哪项是错误的？
A. 二叉树的每个结点最多有两个子树
B. 二叉树的子树有左右之分
C. 二叉树的叶子结点数总是比度为2的结点数多1
D. 二叉树的深度等于其结点数
答案：D
一个二叉搜索树，如果前序遍历是[10,5,2,7,15,12,17]，那么中序遍历是：
A. [2,5,7,10,12,15,17]
B. [10,5,2,7,15,12,17]
C. [2,7,5,10,12,17,15]
D. [2,5,7,15,12,10,17]
答案：A
一个AVL树的平衡因子定义为：
A. 左子树高度-右子树高度
B. 右子树高度-左子树高度
C. 左子树高度+右子树高度
D. |左子树高度-右子树高度|
答案：A
以下关于红黑树的描述，哪项是错误的？
A. 红黑树的根节点是黑色的
B. 红黑树的每个叶子节点是黑色的
C. 红黑树中红色节点的子节点必须是黑色
D. 红黑树中从根到叶子的路径上，黑色节点数量可以不同
答案：D
B+树的叶子节点形成一个双向链表，这主要为了：
A. 提高B+树的平衡性
B. 提高范围查询的效率
C. 减少B+树的深度
D. 提高B+树的插入效率
答案：B
以下关于图的邻接矩阵表示法的描述，哪项是错误的？
A. 邻接矩阵适合稠密图
B. 邻接矩阵的空间复杂度是O(V^2)
C. 邻接矩阵的查询效率是O(1)
D. 邻接矩阵适合稀疏图
答案：D
一个有n个顶点的无向图，如果它是连通的，那么它至少有：
A. n-1条边
B. n条边
C. n(n-1)/2条边
D. n^2条边
答案：A
以下关于DFS和BFS的描述，哪项是正确的？
A. DFS使用队列实现，BFS使用栈实现
B. DFS可以用于寻找最短路径，BFS不能
C. BFS可以用于寻找最短路径，DFS不能
D. DFS和BFS在无权图中都能找到最短路径
答案：C
一个有n个顶点的有向无环图(DAG)，拓扑排序的可能结果数量是：
A. 1
B. n!
C. 2^n
D. 与图的结构有关
答案：D
以下关于Prim算法的描述，哪项是错误的？
A. Prim算法从一个顶点开始
B. Prim算法每次选择一个与当前生成树相连的最小权边
C. Prim算法的时间复杂度是O(ElogV)
D. Prim算法不能处理带负权边的图
答案：D
以下关于Dijkstra算法的描述，哪项是正确的？
A. Dijkstra算法可以处理带负权边的图
B. Dijkstra算法的时间复杂度是O(V^2)
C. Dijkstra算法使用栈实现
D. Dijkstra算法只能用于无向图
答案：B
以下关于快速排序的描述，哪项是错误的？
A. 快速排序的平均时间复杂度是O(nlogn)
B. 快速排序是不稳定的排序算法
C. 快速排序的最坏时间复杂度是O(n^2)
D. 快速排序在数据完全无序时性能最好
答案：D
以下关于归并排序的描述，哪项是正确的？
A. 归并排序的空间复杂度是O(1)
B. 归并排序是不稳定的排序算法
C. 归并排序的平均时间复杂度是O(nlogn)
D. 归并排序不适合于链表实现
答案：C
以下关于堆排序的描述，哪项是错误的？
A. 堆排序的平均时间复杂度是O(nlogn)
B. 堆排序是稳定的排序算法
C. 堆排序的空间复杂度是O(1)
D. 堆排序的最坏时间复杂度是O(nlogn)
答案：B
以下关于二分查找的描述，哪项是错误的？
A. 二分查找要求数据有序
B. 二分查找的时间复杂度是O(logn)
C. 二分查找可以用于链表
D. 二分查找的实现通常使用递归
答案：C
哈希表的负载因子是指：
A. 哈希表中已存储元素数量与哈希表容量的比值
B. 哈希表中哈希函数的数量与哈希表容量的比值
C. 哈希表中冲突数量与哈希表容量的比值
D. 哈希表中元素数量与哈希表中冲突数量的比值
答案：A
以下关于KMP算法的描述，哪项是正确的？
A. KMP算法的预处理时间复杂度是O(n)
B. KMP算法的匹配时间复杂度是O(m)
C. KMP算法的失败函数总是等于0
D. KMP算法的失败函数与模式串的长度无关
答案：A
以下关于递归的描述，哪项是错误的？
A. 递归函数必须有终止条件
B. 递归函数的空间复杂度与递归深度成正比
C. 递归函数的效率通常高于迭代实现
D. 递归函数可以简化问题的解决过程
答案：C
以下关于分治法的描述，哪项是正确的？
A. 分治法要求问题具有最优子结构
B. 分治法要求问题具有重叠子问题
C. 分治法的递归深度通常与问题规模成正比
D. 分治法总是比动态规划效率高
答案：A
以下关于动态规划的描述，哪项是正确的？
A. 动态规划要求问题具有最优子结构和重叠子问题
B. 动态规划要求问题具有最优子结构，但不需要重叠子问题
C. 动态规划的递归实现总是比迭代实现效率高
D. 动态规划不适用于求解最短路径问题
答案：A
以下关于贪心算法的描述，哪项是错误的？
A. 贪心算法总是能给出全局最优解
B. 贪心算法的局部最优选择可能不是全局最优
C. 贪心算法的时间复杂度通常较低
D. 贪心算法适用于某些特定问题
答案：A
以下关于大O表示法的描述，哪项是错误的？
A. 大O表示法描述算法的渐进时间复杂度
B. 大O表示法忽略常数因子和低阶项
C. 大O表示法描述算法的最坏情况性能
D. 大O表示法描述算法的平均情况性能
答案：D
以下关于二叉树的遍历，哪项是错误的？
A. 前序遍历的顺序是：根-左-右
B. 中序遍历的顺序是：左-根-右
C. 后序遍历的顺序是：左-右-根
D. 层次遍历的顺序是：根-左-右
答案：D
以下关于完全二叉树的描述，哪项是正确的？
A. 完全二叉树的叶子节点只可能在最底层和次底层
B. 完全二叉树的深度等于其结点数
C. 完全二叉树的叶子节点数总是等于度为2的结点数
D. 完全二叉树的结点数总是奇数
答案：A
以下关于线索二叉树的描述，哪项是错误的？
A. 线索二叉树可以提高遍历效率
B. 线索二叉树的每个结点有两个线索指针
C. 线索二叉树的线索指针指向的是前驱或后继
D. 线索二叉树的线索指针指向的是子树根节点
答案：D
以下关于哈夫曼树的描述，哪项是正确的？
A. 哈夫曼树是二叉树
B. 哈夫曼树的带权路径长度最短
C. 哈夫曼树的叶子节点权值越大，其深度越小
D. 以上都对
答案：D
以下关于图的强连通分量的描述，哪项是错误的？
A. 一个强连通图只有一个强连通分量
B. 一个有向图的强连通分量是最大的强连通子图
C. 强连通分量可以通过Kosaraju算法找到
D. 强连通分量的大小总是等于图的顶点数
答案：D
以下关于拓扑排序的描述，哪项是正确的？
A. 拓扑排序只适用于有向无环图
B. 拓扑排序可以用于检测有向图中的环
C. 一个有向无环图可能有多个拓扑排序
D. 以上都对
答案：D
以下关于B树的描述，哪项是正确的？
A. B树的阶数是树中每个节点的子节点数的最大值
B. B树的每个节点包含关键字和子节点指针
C. B树的叶子节点包含数据
D. 以上都对
答案：D
以下关于图的表示方法的描述，哪项是正确的？
A. 邻接矩阵表示法适合稠密图
B. 邻接表表示法适合稀疏图
C. 邻接表表示法的空间复杂度是O(V+E)
D. 以上都对
答案：D
以下关于DFS的描述，哪项是错误的？
A. DFS可以用于寻找连通分量
B. DFS可以用于检测图中的环
C. DFS可以用于寻找最短路径
D. DFS的实现通常使用栈
答案：C
以下关于BFS的描述，哪项是正确的？
A. BFS可以用于寻找最短路径
B. BFS可以用于检测图中的环
C. BFS的实现通常使用队列
D. 以上都对
答案：D
以下关于Kruskal算法的描述，哪项是正确的？
A. Kruskal算法使用并查集数据结构
B. Kruskal算法按边的权重从小到大排序
C. Kruskal算法可以处理带负权边的图
D. 以上都对
答案：D
以下关于Prim算法的描述，哪项是错误的？
A. Prim算法从一个顶点开始
B. Prim算法每次选择一个与当前生成树相连的最小权边
C. Prim算法的时间复杂度是O(ElogV)
D. Prim算法不能处理带负权边的图
答案：D
以下关于Dijkstra算法的描述，哪项是错误的？
A. Dijkstra算法可以处理带负权边的图
B. Dijkstra算法的时间复杂度是O(V^2)
C. Dijkstra算法使用优先队列实现
D. Dijkstra算法只能用于无向图
答案：A
以下关于快速排序的分区策略，哪项是错误的？
A. Hoare分区法使用两个指针从两端向中间移动
B. Lomuto分区法使用一个指针从左向右移动
C. Hoare分区法的分区结果总是将基准元素放在正确位置
D. Lomuto分区法的分区结果总是将基准元素放在正确位置
答案：C
以下关于归并排序的描述，哪项是错误的？
A. 归并排序使用分治法
B. 归并排序的合并过程需要额外空间
C. 归并排序的平均时间复杂度是O(nlogn)
D. 归并排序的最坏时间复杂度是O(n^2)
答案：D
以下关于堆的描述，哪项是正确的？
A. 最大堆的根节点是最大值
B. 最小堆的根节点是最小值
C. 堆是一种完全二叉树
D. 以上都对
答案：D
以下关于哈希表的冲突解决方法，哪项是错误的？
A. 开放定址法使用线性探测、二次探测等
B. 链地址法将冲突的元素存储在链表中
C. 开放定址法的空间利用率总是高于链地址法
D. 链地址法的平均查找长度与负载因子有关
答案：C
以下关于KMP算法的失败函数的描述，哪项是正确的？
A. 失败函数表示模式串中前缀和后缀的最长匹配长度
B. 失败函数的值总是小于模式串的长度
C. 失败函数的计算可以使用动态规划
D. 以上都对
答案：D
以下关于递归的描述，哪项是错误的？
A. 递归函数必须有终止条件
B. 递归函数的空间复杂度与递归深度成正比
C. 递归函数的效率通常高于迭代实现
D. 递归函数可以简化问题的解决过程
答案：C
以下关于分治法的描述，哪项是正确的？
A. 分治法要求问题具有最优子结构
B. 分治法要求问题具有重叠子问题
C. 分治法的递归深度通常与问题规模成正比
D. 分治法总是比动态规划效率高
答案：A
以下关于动态规划的描述，哪项是错误的？
A. 动态规划要求问题具有最优子结构和重叠子问题
B. 动态规划的递归实现可以使用备忘录
C. 动态规划的迭代实现通常比递归实现效率高
D. 动态规划总是比贪心算法效率高
答案：D
以下关于贪心算法的描述，哪项是错误的？
A. 贪心算法总是能给出全局最优解
B. 贪心算法的局部最优选择可能不是全局最优
C. 贪心算法的时间复杂度通常较低
D. 贪心算法适用于某些特定问题
答案：A
以下关于大O表示法的描述，哪项是错误的？
A. 大O表示法描述算法的渐进时间复杂度
B. 大O表示法忽略常数因子和低阶项
C. 大O表示法描述算法的最坏情况性能
D. 大O表示法描述算法的平均情况性能
答案：D
以下关于二叉树的深度的描述，哪项是错误的？
A. 一棵空树的深度为0
B. 一棵只有一个节点的树的深度为1
C. 一棵满二叉树的深度为log2(n+1)
D. 一棵完全二叉树的深度为log2(n+1)
答案：B
以下关于二叉搜索树的描述，哪项是正确的？
A. 二叉搜索树的中序遍历是有序的
B. 二叉搜索树的前序遍历是有序的
C. 二叉搜索树的后序遍历是有序的
D. 二叉搜索树的层次遍历是有序的
答案：A
以下关于AVL树的旋转操作，哪项是错误的？
A. 左旋：将右子树的根节点提升到父节点的位置
B. 右旋：将左子树的根节点提升到父节点的位置
C. 左-右旋：先左旋，再右旋
D. 右-左旋：先右旋，再左旋
答案：C
以下关于红黑树的描述，哪项是正确的？
A. 红黑树的根节点是黑色的
B. 红黑树的每个叶子节点是黑色的
C. 红黑树中红色节点的子节点必须是黑色
D. 以上都对
答案：D
以下关于B+树的描述，哪项是错误的？
A. B+树的内部节点只存储索引
B. B+树的叶子节点存储数据
C. B+树的叶子节点形成双向链表
D. B+树的内部节点也存储数据
答案：D
以下关于图的连通性的描述，哪项是正确的？
A. 无向图的连通性可以通过DFS或BFS检测
B. 有向图的强连通性可以通过Kosaraju算法检测
C. 无向图的连通分量是最大的连通子图
D. 以上都对
答案：D
以下关于Kruskal算法的描述，哪项是错误的？
A. Kruskal算法按边的权重从小到大排序
B. Kruskal算法使用并查集数据结构
C. Kruskal算法可以处理带负权边的图
D. Kruskal算法的最坏时间复杂度是O(ElogE)
答案：C
以下关于Prim算法的描述，哪项是正确的？
A. Prim算法从一个顶点开始
B. Prim算法每次选择一个与当前生成树相连的最小权边
C. Prim算法的时间复杂度是O(ElogV)
D. 以上都对
答案：D
以下关于Dijkstra算法的描述，哪项是错误的？
A. Dijkstra算法可以处理带负权边的图
B. Dijkstra算法的时间复杂度是O(V^2)
C. Dijkstra算法使用优先队列实现
D. Dijkstra算法可以用于有向图
答案：A
以下关于快速排序的描述，哪项是错误的？
A. 快速排序的平均时间复杂度是O(nlogn)
B. 快速排序是不稳定的排序算法
C. 快速排序的最坏时间复杂度是O(n^2)
D. 快速排序在数据完全有序时性能最好
答案：D
以下关于归并排序的描述，哪项是正确的？
A. 归并排序的空间复杂度是O(1)
B. 归并排序是稳定的排序算法
C. 归并排序的平均时间复杂度是O(nlogn)
D. 归并排序不适合于链表实现
答案：B
以下关于堆排序的描述，哪项是正确的？
A. 堆排序的平均时间复杂度是O(nlogn)
B. 堆排序是稳定的排序算法
C. 堆排序的空间复杂度是O(1)
D. 堆排序的最坏时间复杂度是O(nlogn)
答案：A
以下关于二分查找的描述，哪项是错误的？
A. 二分查找要求数据有序
B. 二分查找的时间复杂度是O(logn)
C. 二分查找可以用于链表
D. 二分查找的实现通常使用递归
答案：C
以下关于哈希表的负载因子的描述，哪项是正确的？
A. 负载因子是哈希表中已存储元素数量与哈希表容量的比值
B. 负载因子越小，哈希表的性能越好
C. 负载因子越大，哈希表的性能越好
D. 负载因子通常设置为0.75
答案：A
以下关于KMP算法的失败函数的描述，哪项是错误的？
A. 失败函数表示模式串中前缀和后缀的最长匹配长度
B. 失败函数的值总是小于模式串的长度
C. 失败函数的计算可以使用动态规划
D. 失败函数的值可以等于模式串的长度
答案：D
以下关于递归的描述，哪项是正确的？
A. 递归函数必须有终止条件
B. 递归函数的空间复杂度与递归深度成正比
C. 递归函数的效率通常低于迭代实现
D. 以上都对
答案：D
以下关于分治法的描述，哪项是错误的？
A. 分治法要求问题具有最优子结构
B. 分治法要求问题具有重叠子问题
C. 分治法的递归深度通常与问题规模成正比
D. 分治法总是比动态规划效率高
答案：B
以下关于动态规划的描述，哪项是正确的？
A. 动态规划要求问题具有最优子结构和重叠子问题
B. 动态规划的递归实现可以使用备忘录
C. 动态规划的迭代实现通常比递归实现效率高
D. 以上都对
答案：D
以下关于贪心算法的描述，哪项是正确的？
A. 贪心算法的局部最优选择可能不是全局最优
B. 贪心算法的时间复杂度通常较低
C. 贪心算法适用于某些特定问题
D. 以上都对
答案：D
以下关于大O表示法的描述，哪项是正确的？
A. 大O表示法描述算法的渐进时间复杂度
B. 大O表示法忽略常数因子和低阶项
C. 大O表示法描述算法的最坏情况性能
D. 以上都对
答案：D
以下关于二叉树的遍历的描述，哪项是正确的？
A. 前序遍历的顺序是：根-左-右
B. 中序遍历的顺序是：左-根-右
C. 后序遍历的顺序是：左-右-根
D. 以上都对
答案：D
以下关于完全二叉树的描述，哪项是错误的？
A. 完全二叉树的叶子节点只可能在最底层和次底层
B. 完全二叉树的深度等于其结点数
C. 完全二叉树的叶子节点数总是大于等于度为2的结点数
D. 完全二叉树的结点数可以是任意整数
答案：B
以下关于线索二叉树的描述，哪项是正确的？
A. 线索二叉树可以提高遍历效率
B. 线索二叉树的每个结点有两个线索指针
C. 线索二叉树的线索指针指向的是前驱或后继
D. 以上都对
答案：D
以下关于哈夫曼树的描述，哪项是错误的？
A. 哈夫曼树是二叉树
B. 哈夫曼树的带权路径长度最短
C. 哈夫曼树的叶子节点权值越大，其深度越小
D. 哈夫曼树的叶子节点权值越小，其深度越大
答案：C
以下关于图的强连通分量的描述，哪项是正确的？
A. 一个强连通图只有一个强连通分量
B. 一个有向图的强连通分量是最大的强连通子图
C. 强连通分量可以通过Kosaraju算法找到
D. 以上都对
答案：D
以下关于拓扑排序的描述，哪项是错误的？
A. 拓扑排序只适用于有向无环图
B. 拓扑排序可以用于检测有向图中的环
C. 一个有向无环图可能有多个拓扑排序
D. 拓扑排序的结果是唯一的
答案：D
以下关于B树的描述，哪项是错误的？
A. B树的阶数是树中每个节点的子节点数的最大值
B. B树的每个节点包含关键字和子节点指针
C. B树的叶子节点包含数据
D. B树的内部节点也包含数据
答案：A
以下关于图的表示方法的描述，哪项是错误的？
A. 邻接矩阵表示法适合稠密图
B. 邻接表表示法适合稀疏图
C. 邻接矩阵表示法的空间复杂度是O(V^2)
D. 邻接表表示法的空间复杂度是O(V^2)
答案：D
以下关于DFS的描述，哪项是正确的？
A. DFS可以用于寻找连通分量
B. DFS可以用于检测图中的环
C. DFS可以用于寻找最短路径
D. 以上都对
答案：A
以下关于BFS的描述，哪项是正确的？
A. BFS可以用于寻找最短路径
B. BFS可以用于检测图中的环
C. BFS的实现通常使用队列
D. 以上都对
答案：D
以下关于Kruskal算法的描述，哪项是正确的？
A. Kruskal算法按边的权重从小到大排序
B. Kruskal算法使用并查集数据结构
C. Kruskal算法的最坏时间复杂度是O(ElogE)
D. 以上都对
答案：D
以下关于Prim算法的描述，哪项是错误的？
A. Prim算法从一个顶点开始
B. Prim算法每次选择一个与当前生成树相连的最小权边
C. Prim算法的时间复杂度是O(ElogV)
D. Prim算法可以处理带负权边的图
答案：D
以下关于Dijkstra算法的描述，哪项是错误的？
A. Dijkstra算法可以处理带负权边的图
B. Dijkstra算法的时间复杂度是O(V^2)
C. Dijkstra算法使用优先队列实现
D. Dijkstra算法可以用于有向图
答案：A
以下关于快速排序的分区策略，哪项是错误的？
A. Hoare分区法使用两个指针从两端向中间移动
B. Lomuto分区法使用一个指针从左向右移动
C. Hoare分区法的分区结果总是将基准元素放在正确位置
D. Lomuto分区法的分区结果总是将基准元素放在正确位置
答案：C
以下关于归并排序的描述，哪项是错误的？
A. 归并排序使用分治法
B. 归并排序的合并过程需要额外空间
C. 归并排序的平均时间复杂度是O(nlogn)
D. 归并排序的最坏时间复杂度是O(n^2)
答案：D
以下关于堆的描述，哪项是错误的？
A. 最大堆的根节点是最大值
B. 最小堆的根节点是最小值
C. 堆是一种完全二叉树
D. 堆的插入操作时间复杂度是O(logn)
答案：D
以下关于哈希表的冲突解决方法，哪项是正确的？
A. 开放定址法使用线性探测、二次探测等
B. 链地址法将冲突的元素存储在链表中
C. 开放定址法的空间利用率总是高于链地址法
D. 链地址法的平均查找长度与负载因子有关
答案：D
以下关于KMP算法的失败函数的描述，哪项是错误的？
A. 失败函数表示模式串中前缀和后缀的最长匹配长度
B. 失败函数的值总是小于模式串的长度
C. 失败函数的计算可以使用动态规划
D. 失败函数的值可以等于模式串的长度
答案：D
以下关于递归的描述，哪项是错误的？
A. 递归函数必须有终止条件
B. 递归函数的空间复杂度与递归深度成正比
C. 递归函数的效率通常高于迭代实现
D. 递归函数可以简化问题的解决过程
答案：C
以下关于分治法的描述，哪项是正确的？
A. 分治法要求问题具有最优子结构
B. 分治法要求问题具有重叠子问题
C. 分治法的递归深度通常与问题规模成正比
D. 分治法总是比动态规划效率高
答案：A
以下关于动态规划的描述，哪项是错误的？
A. 动态规划要求问题具有最优子结构和重叠子问题
B. 动态规划的递归实现可以使用备忘录
C. 动态规划的迭代实现通常比递归实现效率高
D. 动态规划总是比贪心算法效率高
答案：D
以下关于贪心算法的描述，哪项是正确的？
A. 贪心算法的局部最优选择可能不是全局最优
B. 贪心算法的时间复杂度通常较低
C. 贪心算法适用于某些特定问题
D. 以上都对
答案：D
以下关于大O表示法的描述，哪项是正确的？
A. 大O表示法描述算法的渐进时间复杂度
B. 大O表示法忽略常数因子和低阶项
C. 大O表示法描述算法的最坏情况性能
D. 以上都对
答案：D
以下关于二叉树的深度的描述，哪项是错误的？
A. 一棵空树的深度为0
B. 一棵只有一个节点的树的深度为1
C. 一棵满二叉树的深度为log2(n+1)
D. 一棵完全二叉树的深度为log2(n+1)
答案：B
以下关于二叉搜索树的描述，哪项是错误的？
A. 二叉搜索树的中序遍历是有序的
B. 二叉搜索树的前序遍历是有序的
C. 二叉搜索树的后序遍历是有序的
D. 二叉搜索树的层次遍历是有序的
答案：B
以下关于AVL树的旋转操作，哪项是错误的？
A. 左旋：将右子树的根节点提升到父节点的位置
B. 右旋：将左子树的根节点提升到父节点的位置
C. 左-右旋：先左旋，再右旋
D. 右-左旋：先右旋，再左旋
答案：C
以下关于红黑树的描述，哪项是错误的？
A. 红黑树的根节点是黑色的
B. 红黑树的每个叶子节点是黑色的
C. 红黑树中红色节点的子节点必须是黑色
D. 红黑树中从根到叶子的路径上，黑色节点数量可以不同
答案：D
以下关于B+树的描述，哪项是正确的？
A. B+树的内部节点存储数据
B. B+树的叶子节点存储数据，并形成双向链表
C. B+树的内部节点存储索引，叶子节点不存储数据
D. B+树的深度总是小于B树
答案：B
以下关于图的最小生成树的描述，哪项是正确的？
A. 一个图的最小生成树是唯一的
B. 一个图的最小生成树可能有多个
C. 最小生成树的边权值之和最小
D. 以上都对
答案：D
以下关于堆的描述，哪项是错误的？
A. 最大堆的根节点是最大值
B. 最小堆的根节点是最小值
C. 堆可以是任意形状的二叉树
D. 堆的插入操作时间复杂度是O(logn)
答案：C
以下关于字符串匹配的描述，哪项是错误的？
A. KMP算法的匹配时间复杂度是O(n+m)
B. KMP算法的预处理时间复杂度是O(m)
C. KMP算法的失败函数可以避免回溯
D. KMP算法的匹配时间复杂度是O(nm)
答案：D
